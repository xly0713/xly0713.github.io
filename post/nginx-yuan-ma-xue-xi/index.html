<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Nginx 网络协议 DNS 云计算">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>Nginx源码分析之--内存池 | yg的小站</title>
<link rel="shortcut icon" href="/favicon.ico?v=1617605911953">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/mist.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/github.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163205066-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-163205066-1');
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?1be048b8c5c87a450b605c349e64ca47";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

  <meta name="description" content="Nginx源码分析之--内存池" />
  <meta name="keywords" content="Nginx,源码分析" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class=" mist">
  <header class="header bg-color ">
    <div class="blog-header box-shadow-wrapper  " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="">
              <span class="logo-line-before">
                <i class=""></i>
              </span>
              <span class="main-title">yg的小站</span>
              <span class="logo-line-after">
                <i class=""></i>
              </span>
            </a>  
          
        </div>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout mist bg-color">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper  right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body mist" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper ">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">yg的小站</p>
    <p class="site-description right-motion">Day day up!</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">11</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">10</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/xly0713">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
        
        
      </div>
    </div>
  

  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9">内存池的优点</a></li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">内存池相关的数据结构</a>
<ul>
<li><a href="#%E7%BB%93%E6%9E%84%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE">结构体示意图</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89">数据结构定义</a></li>
</ul>
</li>
<li><a href="#%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0">内存池主要函数</a>
<ul>
<li><a href="#%E6%96%B0%E5%BB%BA%E5%86%85%E5%AD%98%E6%B1%A0">新建内存池</a></li>
<li><a href="#%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98">从内存池申请内存</a></li>
<li><a href="#%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%B0%8F%E5%9D%97%E5%86%85%E5%AD%98">从内存池申请内存小块内存</a></li>
<li><a href="#%E6%96%B0%E5%BB%BA%E5%B0%8F%E5%86%85%E5%AD%98%E5%9D%97%E5%86%8D%E5%88%86%E9%85%8D">新建小内存块再分配</a></li>
<li><a href="#%E5%88%86%E9%85%8D%E5%A4%A7%E5%86%85%E5%AD%98">分配大内存</a></li>
<li><a href="#%E9%94%80%E6%AF%81%E5%86%85%E5%AD%98%E6%B1%A0">销毁内存池</a></li>
<li><a href="#%E9%87%8D%E7%BD%AE%E5%86%85%E5%AD%98%E6%B1%A0">重置内存池</a></li>
<li><a href="#%E5%9B%9E%E6%94%B6%E5%A4%A7%E5%9D%97%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8%E4%B8%8A%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98">回收大块内存链表上的某个节点内存</a></li>
</ul>
</li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/">
      Nginx源码分析之--内存池
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-04-11</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://xly0713.github.io/tag/ZUZBgmRmp/">
        <span>Nginx</span>
      </a>、
      
      
      
      <a href="https://xly0713.github.io/tag/1FH1KPhrG/">
        <span>源码分析</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>9分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>1761<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <p>Nginx作为高性能的web服务器，它是如何管理内存的呢？</p>
<!-- more -->
<h2 id="内存池的优点">内存池的优点</h2>
<ol>
<li>pool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;</li>
<li>内存统一分配和回收，避免内存泄漏；</li>
<li>整块分配，避免内存过于碎片化;</li>
<li>内存对齐处理，减少CPU读取内存次数，提高寻址效率；</li>
</ol>
<h2 id="内存池相关的数据结构">内存池相关的数据结构</h2>
<h3 id="结构体示意图">结构体示意图</h3>
<figure data-type="image" tabindex="1"><img src="https://xly0713.github.io/post-images/1587183416580.jpg" alt="" loading="lazy"></figure>
<h3 id="数据结构定义">数据结构定义</h3>
<pre><code>typedef struct ngx_pool_s            ngx_pool_t;
typedef struct ngx_pool_large_s  ngx_pool_large_t;

struct ngx_pool_s { //内存池头部结构
    ngx_pool_data_t       d;        //内存池的数据区，即真正分配内存的区域
    size_t                max;      //每次可分配最大内存，用于判定是走大内存分配还是小内存分配逻辑
    ngx_pool_t           *current;  //指向当前内存池小块内存可用的首个节点
    ngx_chain_t          *chain;    //缓冲区链表
    ngx_pool_large_t     *large;    //内存块大于max内存块的链表
    ngx_pool_cleanup_t   *cleanup;  //销毁内存池回调函数
    ngx_log_t            *log;      //错误日志指针
};

typedef struct {
    u_char               *last;     //当前内存块已使用到此处，下一次使用从此处开始
    u_char               *end;      //内存块结束位置
    ngx_pool_t           *next;     //内存池有很多内存块，通过next指针组成链表
    ngx_uint_t            failed;   //内存块分配失败次数
} ngx_pool_data_t; //小内存块(链表)

//大内存块(链表)
struct ngx_pool_large_s {
    ngx_pool_large_t     *next;  //下一数据块地址
    void                 *alloc; //当前数据块地址
};
</code></pre>
<h2 id="内存池主要函数">内存池主要函数</h2>
<h3 id="新建内存池">新建内存池</h3>
<pre><code>/*
 * 新建一个内存池
 */
ngx_pool_t *
ngx_create_pool(size_t size, ngx_log_t *log)
{
    ngx_pool_t  *p;

    //调用系统内存分配函数，分配一块堆内存，且做对齐处理
    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
    if (p == NULL) {
        return NULL;
    }

    p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t);
    p-&gt;d.end = (u_char *) p + size;
    p-&gt;d.next = NULL;
    p-&gt;d.failed = 0;

    size = size - sizeof(ngx_pool_t);
    //max最大为pagesize-1(比如:x86时为4095), 即：无论小块内存空间是否足够，超过pagesize-1大小的内存均走large块分配
    p-&gt;max = (size &lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;

    p-&gt;current = p;
    p-&gt;chain = NULL;
    p-&gt;large = NULL;
    p-&gt;cleanup = NULL;
    p-&gt;log = log;

    return p;
}
</code></pre>
<h3 id="从内存池申请内存">从内存池申请内存</h3>
<ul>
<li>先对齐再分配内存</li>
</ul>
<pre><code>/*
 * 从内存池中申请一块内存
 * （1）如果申请的内存小于定义的max，则从内存池中分配内存，需先对齐再分配
 * （2）否则分配大块内存挂载到large指针上
 */
void *
ngx_palloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size &lt;= pool-&gt;max) {
        return ngx_palloc_small(pool, size, 1); //小块内存(先对齐)
    }
#endif

    return ngx_palloc_large(pool, size);
}
</code></pre>
<ul>
<li>先对齐再分配内存, 并填充0</li>
</ul>
<pre><code>/*
 * 从内存池中申请内存，并填充0
 */
void *
ngx_pcalloc(ngx_pool_t *pool, size_t size)
{
    void *p;

    p = ngx_palloc(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}
</code></pre>
<ul>
<li>不用对齐分配内存</li>
</ul>
<pre><code>/*
 * 从内存池中申请一块内存 （小块内存无需先对齐）
 */
void *
ngx_pnalloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size &lt;= pool-&gt;max) {
        return ngx_palloc_small(pool, size, 0); //小块内存（无需先对齐）
    }
#endif

    return ngx_palloc_large(pool, size);
}
</code></pre>
<h3 id="从内存池申请内存小块内存">从内存池申请内存小块内存</h3>
<pre><code>/*
 * 分配小块内存
 * 1. 循环遍历内存块ngx_pool_data_t链表
 * 2. 如果当前内存块剩余大小满足申请的内存大小，则移动相应指针，返回分配的内存指针
 * 3. 否则，移动到下一个内存块
 * 4. 如果所有内存块都没能满足申请的内存大小，则重新申请一块内存块挂载到链表上，并返回分配的内存地址
 */
static ngx_inline void *
ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)
{
    u_char      *m;
    ngx_pool_t  *p;

    p = pool-&gt;current;

    do {
        m = p-&gt;d.last; //最后使用位置

        if (align) {
            m = ngx_align_ptr(m, NGX_ALIGNMENT); //先内存对齐, 减少CPU读取内存次数
        }

        if ((size_t) (p-&gt;d.end - m) &gt;= size) { //当前内存块剩余空间足够
            p-&gt;d.last = m + size; //最后使用位置更新，剩余空间变小

            return m;
        }

        p = p-&gt;d.next;

    } while (p);

    //现有小块内存均无法分配，则新建内存块后再分配
    return ngx_palloc_block(pool, size);
}
</code></pre>
<h3 id="新建小内存块再分配">新建小内存块再分配</h3>
<pre><code>/*
 * 再次申请小块内存，并挂载到小块内存链表上，并返回当次申请的内存指针
*/
static void *
ngx_palloc_block(ngx_pool_t *pool, size_t size)
{
    u_char      *m;
    size_t       psize;
    ngx_pool_t  *p, *new;

    psize = (size_t) (pool-&gt;d.end - (u_char *) pool);

    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&gt;log);
    if (m == NULL) {
        return NULL;
    }

    new = (ngx_pool_t *) m;

    new-&gt;d.end = m + psize;
    new-&gt;d.next = NULL;
    new-&gt;d.failed = 0;

    m += sizeof(ngx_pool_data_t);
    m = ngx_align_ptr(m, NGX_ALIGNMENT);
    new-&gt;d.last = m + size;

    for (p = pool-&gt;current; p-&gt;d.next; p = p-&gt;d.next) {
        //调整各个内存块分配失败次数，如果失败次数大于4，则此块内存节点不再使用
        if (p-&gt;d.failed++ &gt; 4) {
            pool-&gt;current = p-&gt;d.next;
        }
    }

    p-&gt;d.next = new;

    return m;
}
</code></pre>
<h3 id="分配大内存">分配大内存</h3>
<pre><code>/*
 * 分配大内存块
 */
static void *
ngx_palloc_large(ngx_pool_t *pool, size_t size)
{
    void              *p;
    ngx_uint_t         n;
    ngx_pool_large_t  *large;

    p = ngx_alloc(size, pool-&gt;log); //向系统申请size大小堆内存
    if (p == NULL) {
        return NULL;
    }

    n = 0;

    //查找一个空的large区，如果有，则将分配的空间p交由它管理（最多3次）
    for (large = pool-&gt;large; large; large = large-&gt;next) {
        if (large-&gt;alloc == NULL) { //ngx_pfree函数会产生空的large区
            large-&gt;alloc = p;
            return p;
        }

        if (n++ &gt; 3) { //超过一定次数，放弃查找空的large区
            break;
        }
    }

    //创建一个新的large节点
    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    //新分配的空间p交由新建的large节点管理，并且插入到large链表头部
    large-&gt;alloc = p;
    large-&gt;next = pool-&gt;large;
    pool-&gt;large = large;

    return p;
}
</code></pre>
<h3 id="销毁内存池">销毁内存池</h3>
<pre><code>/*
 * 销毁内存池
 */
void
ngx_destroy_pool(ngx_pool_t *pool)
{
    ngx_pool_t          *p, *n;
    ngx_pool_large_t    *l;
    ngx_pool_cleanup_t  *c;

    for (c = pool-&gt;cleanup; c; c = c-&gt;next) {
        if (c-&gt;handler) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,
                           &quot;run cleanup: %p&quot;, c);
            c-&gt;handler(c-&gt;data);
        }
    }

#if (NGX_DEBUG)

    /*
     * we could allocate the pool-&gt;log from this pool
     * so we cannot use this log while free()ing the pool
     */

    for (l = pool-&gt;large; l; l = l-&gt;next) {
        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0, &quot;free: %p&quot;, l-&gt;alloc);
    }

    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) {
        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,
                       &quot;free: %p, unused: %uz&quot;, p, p-&gt;d.end - p-&gt;d.last);

        if (n == NULL) {
            break;
        }
    }

#endif

    //释放大内存块（链表）
    for (l = pool-&gt;large; l; l = l-&gt;next) {
        if (l-&gt;alloc) {
            ngx_free(l-&gt;alloc);
        }
    }

    //释放小内存块 (链表)
    for (p = pool, n = pool-&gt;d.next; /* void */; p = n, n = n-&gt;d.next) {
        ngx_free(p);

        if (n == NULL) {
            break;
        }
    }
}
</code></pre>
<h3 id="重置内存池">重置内存池</h3>
<pre><code>/*
 * 重置内存池
 * 1. 释放大块内存
 * 2. 重置可开始分配位置指针、分配失败次数为0、可用小内存块current指针指向首个内存块
 */
void
ngx_reset_pool(ngx_pool_t *pool)
{
    ngx_pool_t        *p;
    ngx_pool_large_t  *l;

    for (l = pool-&gt;large; l; l = l-&gt;next) { //遍历大块内存链表，释放内存
        if (l-&gt;alloc) {
            ngx_free(l-&gt;alloc);
        }
    }

    for (p = pool; p; p = p-&gt;d.next) {
        p-&gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //恢复至初始为位置
        p-&gt;d.failed = 0; //分配失败次数重置为0
    }

    pool-&gt;current = pool; //current指向首个内存块
    pool-&gt;chain = NULL;
    pool-&gt;large = NULL;
}
</code></pre>
<h3 id="回收大块内存链表上的某个节点内存">回收大块内存链表上的某个节点内存</h3>
<pre><code>/*
 * 回收大块内存链表上的某个节点内存
 */
ngx_int_t
ngx_pfree(ngx_pool_t *pool, void *p)
{
    ngx_pool_large_t  *l;

    for (l = pool-&gt;large; l; l = l-&gt;next) {
        if (p == l-&gt;alloc) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&gt;log, 0,
                           &quot;free: %p&quot;, l-&gt;alloc);
            ngx_free(l-&gt;alloc);
            l-&gt;alloc = NULL;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}
</code></pre>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      yg的小站
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/" title="Nginx源码分析之--内存池">https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://xly0713.github.io/tag/ZUZBgmRmp/"># Nginx</a>
    
      <a href="https://xly0713.github.io/tag/1FH1KPhrG/"># 源码分析</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="ATS入门" href="https://xly0713.github.io/post/ats-ru-men/">ATS入门</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="ATS入门" href="https://xly0713.github.io/post/ats-ru-men/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="gperftools分析Nginx" href="https://xly0713.github.io/post/gperftools-fen-xi-nginx/">gperftools分析Nginx</a>
        <a class="nav-mobile-next" title="gperftools分析Nginx" href="https://xly0713.github.io/post/gperftools-fen-xi-nginx/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '52d02c95d4f1500d9f75',
    clientSecret: '878436bbe0814eb17153aae1f385fe271ceff250',
    repo: 'xly0713.github.io',
    owner: 'xly0713',
    admin: ['xly0713'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
    <div class="drawer-box left" id="drawer_box">
      <span class="muse-line muse-line-first"></span>
      <span class="muse-line muse-line-middle"></span>
      <span class="muse-line muse-line-last"></span>
    </div>
  
  <div class="mist back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
  </div>
  
  
    

<link rel="stylesheet" href="/media/live2d/histoire/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;" data-key="">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
      <div class="live_talk_input_name_body">
        <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
      </div>
      <div class="live_talk_input_text_body">
        <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
        <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
      </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
      <div class="live_ico_item type_info" id="showInfoBtn"></div>
      <div class="live_ico_item type_talk" id="showTalkBtn"></div>
      
      <div class="live_ico_item type_youdu" id="youduButton"></div>
      <div class="live_ico_item type_quit" id="hideButton"></div>
      <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
      <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
      <input id="duType" value="douqilai" type="hidden">
      
    </div>
  </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
var message_Path = '/media/live2d/histoire/';
let landlord = document.querySelector('#landlord');
var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/histoire/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/histoire/js/message.js"></script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/functional-options-in-go/"" data-c="
          &lt;p&gt;go语言编码使用functional options是常见用法，但是在hot path处要慎用。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;p&gt;之前用go写过一个IO密集型的程序，pprof性能测试发现使用functional options竟然占用较多的CPU时间。经测试，直接对结构体的字段赋值，速度是使用functional options的一百倍。测试代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
        &amp;quot;fmt&amp;quot;
        &amp;quot;time&amp;quot;
)

type user struct {
        Age int
}

type userOpt func(*user)

func WithUserAge(age int) userOpt {
        return func(u *user) {
                u.Age = age
        }
}

func main() {
        u := &amp;amp;user{}
        now := time.Now()

        //f := WithUserAge
        for i := 0; i &amp;lt; 100000000; i++ {
                u.Age = i
                //f(i)(u)   //实测性能是上一行(直接赋值)的百分之一
        }

        diff := time.Since(now)
        fmt.Printf(&amp;quot;diff: %v\n&amp;quot;, diff)
}
&lt;/code&gt;&lt;/pre&gt;
">Functional options in Go</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/defer-de-miao-yong/"" data-c="
          &lt;p&gt;defer是go关键字，一般用来清理释放资源，在了解go-kit微服务时，发现了有意思的用法&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;一般用法-清理释放资源&#34;&gt;一般用法--清理释放资源&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;fd, err := os.Open(filename)
if err != nil {
    return
}
defer fd.Close()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使用defer可以避免忘记释放资源。曾经使用&lt;code&gt;lsof -p $pid | grep deleted&lt;/code&gt;帮一个C++老手找出过程序资源句柄忘记Close的问题，go的defer可以有效避免此类问题。&lt;/p&gt;
&lt;h2 id=&#34;defer的妙用-中间件middleware&#34;&gt;defer的妙用--中间件MiddleWare&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
        &amp;quot;fmt&amp;quot;
        &amp;quot;io&amp;quot;
        &amp;quot;os&amp;quot;
        &amp;quot;strings&amp;quot;
        &amp;quot;time&amp;quot;
)

func main() {
    var svc stringService
    svc = &amp;amp;stringSvc{}
    svc = setupLogMiddle(os.Stdout)(svc)
    ret := svc.ToUpper(&amp;quot;hello&amp;quot;)
    fmt.Println(ret)
}

// 定义接口
type stringService interface {
    ToUpper(string) string
}

type stringSvc struct{}

// 真正的业务service
func (ss *stringSvc) ToUpper(input string) (ret string) {
    return strings.ToUpper(input)
}

// 中间件type
type middle func(stringService) stringService

type log struct {
    writer io.Writer
    stringService
}

// 安装中间件
func setupLogMiddle(writer io.Writer) middle {
    return func(ss stringService) stringService {
        return &amp;amp;log{writer, ss}
    }
}

func (l *log) ToUpper(input string) (ret string) {
    // 此处defer执行log中间件
    defer func(begin time.Time) {
        fmt.Fprintf(l.writer, &amp;quot;method: %s, input: %s, output: %s, took: %v\n&amp;quot;,
            &amp;quot;ToUpper&amp;quot;, input, ret, time.Since(begin))
    }(time.Now())

    ret = l.stringService.ToUpper(input)
    return ret
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以上是从&lt;a href=&#34;https://github.com/go-kit/kit&#34;&gt;go-kit&lt;/a&gt;看到的，挺有意思，记录下来。&lt;/p&gt;
">defer的妙用</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/rtmp-xie-yi/"" data-c="
          &lt;p&gt;RTMP是直播业务使用的重要协议，整理以备查。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h1 id=&#34;简介&#34;&gt;简介&lt;/h1&gt;
&lt;h1 id=&#34;rtmp-handshake&#34;&gt;RTMP HandShake&lt;/h1&gt;
&lt;p&gt;RTMP握手成功后，保证了两端支持RTMP协议，然后才能进行RTMP协议层面的消息交互。&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592733025853.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h1 id=&#34;rtmp-chunk&#34;&gt;RTMP Chunk&lt;/h1&gt;
&lt;h2 id=&#34;chunk-format&#34;&gt;Chunk Format&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1592057208742.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;basic-header&#34;&gt;Basic Header&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Basic Header的总长度可能是: 1, 2 或 3字节， 实际是哪一种取决于字段CSID的范围&lt;/li&gt;
&lt;li&gt;包含2个字段:
&lt;ul&gt;
&lt;li&gt;Chunk Type: Format, 简写: &lt;strong&gt;fmt&lt;/strong&gt;。长度固定为: 2bit(比特位)&lt;/li&gt;
&lt;li&gt;Chunk stream ID: 简称&lt;strong&gt;CSID&lt;/strong&gt;。Basic Header的总长度(1, 2或3字节)减去fmt使用的2bit即是CSID可能的长度，长度可能为: 6(8-2), 14(16-2)或22(24-2)bit&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;协议规定: 支持用户自定义[3, 65599]之间的CSID，而0, 1, 2由协议保留用作表示特殊信息
&lt;ul&gt;
&lt;li&gt;0: 表示Basic Header总共要占用2个字节, CSID在[64, 319]之间&lt;/li&gt;
&lt;li&gt;1: 表示Basic Header总共要占用3个字节, CSID在[64, 65599]之间&lt;/li&gt;
&lt;li&gt;2: 表示该Chunk是控制信息和一些命令信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;当basic-header的长度为1字节时&#34;&gt;当Basic Header的长度为1字节时&lt;/h4&gt;
&lt;p&gt;如图所示: CSID长度为6bit,  除去保留的CSID，自定义范围为[3, 63]&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592104838393.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;当basic-header的长度为2字节时&#34;&gt;当Basic Header的长度为2字节时&lt;/h4&gt;
&lt;p&gt;如图所示: 此时协议要求将与&lt;strong&gt;fmt&lt;/strong&gt;所在字节的后6bit位都设置为0，剩下的1个字节表示&lt;strong&gt;CSID - 64&lt;/strong&gt;。8bit位可表示[0, 255]共256个数，即&lt;strong&gt;CSID&lt;/strong&gt;的范围为[64, 319]。&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592104748432.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;当basic-header的长度为3字节时&#34;&gt;当Basic Header的长度为3字节时&lt;/h4&gt;
&lt;p&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1592105487440.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;br&gt;
如果所示: 此时协议要求将与&lt;strong&gt;fmt&lt;/strong&gt;所在字节的后6比特位设置为1(即000001), 剩下的2个字节(小端存储)表示&lt;strong&gt;CSID-64&lt;/strong&gt;。16bit位可表示[0, 65535], 即&lt;strong&gt;CSID&lt;/strong&gt;的范围为[64, 65599]。&lt;br&gt;
另外，可以观察到Basic Header的长度为2字节时的&lt;strong&gt;CSID&lt;/strong&gt;的范围[64, 319]是[64, 65599]的子集。&lt;/p&gt;
&lt;h4 id=&#34;wireshark抓包&#34;&gt;wireshark抓包&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CSID&lt;/strong&gt;值为2时（协议保留值）&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592106094882.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;CSID&lt;/strong&gt;值在区间[3, 64]时 (Basic Header的长度为1字节)&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592106424214.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;伪代码&#34;&gt;伪代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;first_byte = read_1byte()
b_27 = first_byte &amp;amp; 0x3f
if b_27 == 0:
    basic_header_len = 2 (bytes)
else if b_27 == 1:
    basic_header_len = 3 (bytes)
else if b_27 &amp;gt; 1:
    basis_header_len = 1 (bytes)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;message-header&#34;&gt;Message Header&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Message Header的总长度可能是: 11, 7, 3 或 0 字节，实际是哪一种取决于Basic Header的&lt;strong&gt;fmt&lt;/strong&gt;字段的值(2bit位，共4种可能)&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;当fmt-0时-总长度为11字节&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 0时, 总长度为11字节&lt;/h4&gt;
&lt;p&gt;包含如下4个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;timestamp: 时间戳，占用3个字节。
&lt;ul&gt;
&lt;li&gt;3个字节最多表示到16777215 = 2^24 - 1, 当它的值超过这个最大值时，这3个字节全部需置为1。这样实际的时间戳会转存到Extended Timestamp字段中，接收端在判断timestamp字段这3个字节全部为1时，需要去解析Extended Timestamp字段获取时间戳。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;message length: 消息数据的长度，占用3个字节。
&lt;ul&gt;
&lt;li&gt;表示实际发送的数据(如: 音频帧、视频帧)等数据的长度，单位是: 字节&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;message type id: 消息类型的ID，占用1个字节。
&lt;ul&gt;
&lt;li&gt;表示实际发送的数据的类型，比如：8代表音频数据，9代表视频数据&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;message stream id: 消息流的ID，占用4个字节。
&lt;ul&gt;
&lt;li&gt;表示该chunk所在的流的ID，和Basic Header的&lt;strong&gt;CSID&lt;/strong&gt;一样，采用小端存储方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;当fmt-1时总长度为7字节&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 1时，总长度为7字节&lt;/h4&gt;
&lt;p&gt;与&lt;strong&gt;fmt&lt;/strong&gt; = 0相比，省掉了message stream id字段(4个字节)。包含3个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;timestamp delta: 占用3个字节。
&lt;ul&gt;
&lt;li&gt;与&lt;strong&gt;fmt&lt;/strong&gt; = 0时的timestamp含义不同，存储的是和上一个chunk的时间差。同样，超过最大值后，需用到Extended Timestamp字段&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;message length: 消息数据的长度，占用3个字节。&lt;/li&gt;
&lt;li&gt;message type id: 消息类型的ID，占用1个字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;当fmt-2时总长度为3字节&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 2时，总长度为3字节&lt;/h4&gt;
&lt;p&gt;与&lt;strong&gt;fmt&lt;/strong&gt; = 1相比，省掉了message length字段(3字节)和message type id(1字节)。仅包含1个字段:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;timestamp delta: 占用3个字节。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;当fmt-3时总长度为0字节&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 3时，总长度为0字节&lt;/h4&gt;
&lt;p&gt;0字节。表示这个chunk的Message Header和前一个Chunk完全相同。&lt;/p&gt;
&lt;h3 id=&#34;extended-timestamp&#34;&gt;Extended Timestamp&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;含义：扩展时间戳&lt;/li&gt;
&lt;li&gt;协议规定：
&lt;ul&gt;
&lt;li&gt;只有当Message Header中的timestamp (delta)字段设置为全1 (0x00ffffff)时，本字段才能存在&lt;/li&gt;
&lt;li&gt;如果Message Header中的timestamp (delta)字段的值小于0x00ffffff, 则本字段一定不能出现&lt;/li&gt;
&lt;li&gt;如果Message Header中的timestamp (delta)字段不存在(&lt;strong&gt;fmt&lt;/strong&gt; = 3时)， 则本字段也一定不能出现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;chunk-data&#34;&gt;Chunk Data&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;含义: 用户层面上真正想要发送的与协议无关的数据&lt;/li&gt;
&lt;li&gt;长度：在(0, ChunkSize)之间，由Message Header的message length(Body size)字段指定大小&lt;/li&gt;
&lt;li&gt;抓包示例：&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592232838104.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;协议控制消息protocol-control-message&#34;&gt;协议控制消息(Protocol Control Message)&lt;/h2&gt;
&lt;p&gt;chunk流使用一些特殊的值表示协议的控制消息，特殊值协议规定:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basic Header字段&lt;strong&gt;CSID&lt;/strong&gt;必须为2&lt;/li&gt;
&lt;li&gt;Message Header的字段&lt;strong&gt;message stream id&lt;/strong&gt;必须为0（0表示控制信息）&lt;/li&gt;
&lt;li&gt;Message Header的字段&lt;strong&gt;message type id&lt;/strong&gt;可能的值: 1～6&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set-chunk-size&#34;&gt;Set Chunk Size&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 1&lt;/li&gt;
&lt;li&gt;含义：设置Chunk Data的最大长度，Message Header的字段&lt;strong&gt;message length&lt;/strong&gt;不能超过该值。如果要发送的Message超过设置的Chunk Size, 则必须拆分成Chunk发送。&lt;/li&gt;
&lt;li&gt;Chunk Data: Chunk Size值&lt;/li&gt;
&lt;li&gt;wireshark抓包&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592625812774.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;abort-message&#34;&gt;Abort Message&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 2&lt;/li&gt;
&lt;li&gt;含义: 当一个Message被拆分为多个Chunk，接收端只接收到了部分Chunk时:
&lt;ul&gt;
&lt;li&gt;如果发送该控制消息给发送端，可以告知发送端不再传输该Message的Chunk&lt;/li&gt;
&lt;li&gt;而接收端如果收到该控制消息，则需要丢弃这些不完整的Chunk&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Chunk Data: &lt;strong&gt;CSID&lt;/strong&gt;, 表示丢弃该CSID的所有已接收到的Chunk&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;acknowledgement&#34;&gt;Acknowledgement&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 3&lt;/li&gt;
&lt;li&gt;含义: 当收到对端的消息大小等于窗口大小时，接收端需发送该控制消息给对端，告诉对端可以继续发送数据
&lt;ul&gt;
&lt;li&gt;窗口大小是在没有接收端对端的ACK确认消息之前能发送的字节数的最大值&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Chunk Data: 序列号Sequence Number, 表明到当前时间为止已经接收到的字节数（4byte大小）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;user-control-message&#34;&gt;User Control Message&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 4&lt;/li&gt;
&lt;li&gt;含义：用户控制消息，客户端或服务端发送本消息通知对方用户的控制消息&lt;/li&gt;
&lt;li&gt;Chunk Data: 本消息承载事件类型和事件数据
&lt;ul&gt;
&lt;li&gt;头两个字节用于标识事件类型 （2byte）&lt;/li&gt;
&lt;li&gt;事件类型之后是事件数据, 长度是可变的&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;window-acknowledgement-size&#34;&gt;Window Acknowledgement Size&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 5&lt;/li&gt;
&lt;li&gt;含义: 发送端在收到接收端的两个Acknowledgement消息间最多可以发送的字节数&lt;/li&gt;
&lt;li&gt;wireshark抓包&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592627273256.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;set-peer-bandwidth&#34;&gt;Set Peer Bandwidth&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 6&lt;/li&gt;
&lt;li&gt;含义: 发送本消息更新对端的输出带宽&lt;/li&gt;
&lt;li&gt;Chunk Data:
&lt;ul&gt;
&lt;li&gt;aws: Acknowledgement Windows Size (4byte)&lt;/li&gt;
&lt;li&gt;Limit type: 0-硬限制  1-软限制  2-动态限制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;wireshark抓包&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592627673621.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据消息&#34;&gt;数据消息&lt;/h2&gt;
&lt;h3 id=&#34;audio-message&#34;&gt;Audio Message&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 8&lt;/li&gt;
&lt;li&gt;含义: 音频数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;video-message&#34;&gt;Video Message&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 9&lt;/li&gt;
&lt;li&gt;含义: 视频数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;metadata-message&#34;&gt;Metadata Message&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 18&lt;/li&gt;
&lt;li&gt;含义: 音视频编码、视频宽高等元数据信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;命令消息command-message&#34;&gt;命令消息(Command Message)&lt;/h2&gt;
&lt;p&gt;协议规定&lt;strong&gt;message type id&lt;/strong&gt;= 17 或 20 表示命令消息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命令消息由3部分组成：命令的名字(如: connect)、TransactionID表示命令的标识、Object表示相关参数。使用AMF编码。&lt;/li&gt;
&lt;li&gt;接收端收到命令消息后，返回如下3种消息之一:
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;_result&lt;/strong&gt;消息: 表示接受命令，对端可以继续往下执行流程&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;_error&lt;/strong&gt;消息: 表示拒绝该命令要执行的操作&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;method name&lt;/strong&gt;消息: 方法名，例如: verifyClient或contactExternalServer。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netconnection-commands连接层的命令&#34;&gt;NetConnection Commands(连接层的命令)&lt;/h3&gt;
&lt;h4 id=&#34;connect&#34;&gt;connect&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 用于客户端向服务器发起连接请求&lt;/li&gt;
&lt;li&gt;Chunk Data字段:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 如: &amp;quot;connect&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为1&lt;/li&gt;
&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;
&lt;li&gt;Optional User Arguments: 自定义的额外参数(Object)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;wireshark抓包&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592725806865.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;call&#34;&gt;Call&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 用于在对端执行某函数，即RPC&lt;/li&gt;
&lt;li&gt;Chunk Data字段:
&lt;ul&gt;
&lt;li&gt;Procedure Name: 要调用的远程方法(String)&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number)。如果需对端反馈响应，则该值设置为非0，否则设置为0&lt;/li&gt;
&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;
&lt;li&gt;Optional User Arguments: 自定义的额外参数(Object)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果发送Call命令端的Transaction ID非0，则接收命令端需作出响应，响应的字段如下:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String)&lt;/li&gt;
&lt;li&gt;Transaction ID: 接收到的消息的Transaction ID&lt;/li&gt;
&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;
&lt;li&gt;Response: 命令已成功执行(Object)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;createstream&#34;&gt;createStream&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 创建传递具体消息的stream通道，从而可以在这路流中传递具体信息&lt;/li&gt;
&lt;li&gt;Chunk Data字段:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 如: &amp;quot;createStream&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number)&lt;/li&gt;
&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;wireshark抓包&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592728480012.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;netstream-commands流连接上的命令&#34;&gt;NetStream Commands(流连接上的命令)&lt;/h3&gt;
&lt;p&gt;NetStream建立在NetConnection之上。一个TCP连接上只能创建一个NetConnection，但一个NetConnection之上可以创建多个NetStream来建立不同的流通道传输数据。&lt;/p&gt;
&lt;p&gt;服务端收到NetStream Commands后，会通过onStatus的命令来响应客户端，描述当前NetStream状态。&lt;br&gt;
onStatus命令的字段结构如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;onStatus&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;InfoObject: 状态信息(Object)，至少包含3个属性
&lt;ul&gt;
&lt;li&gt;level: String类型，可能值: &amp;quot;warning&amp;quot;、&amp;quot;status&amp;quot;、&amp;quot;error&amp;quot;&lt;/li&gt;
&lt;li&gt;code: String类型，代表具体的状态, 比如: &amp;quot;NetStream.Play.Start&amp;quot;表示开始播流&lt;/li&gt;
&lt;li&gt;description:  String类型，状态的文字描述&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;wireshark抓包示例&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592729790350.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;play&#34;&gt;play&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 客户端请求服务器接收数据(如果传输的信息时视频的话，则请求开始播流)&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;play&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;Stream Name: 流名字(String)&lt;/li&gt;
&lt;li&gt;Start: 开始位置(Number, 可选参数), 表示从何时开始播流，以秒为单位
&lt;ul&gt;
&lt;li&gt;-2: 表示播放直播流，如果直播流不存在，则播放录播文件，如果录播文件也没有，则等待流开播 (默认值)&lt;/li&gt;
&lt;li&gt;-1: 表示只播放直播流，忽略录播文件&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;=0: 表示从该流的该时间点开始播放&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Duration：时长(Number, 可选参数)，以秒为单位
&lt;ul&gt;
&lt;li&gt;-1: 表示直播或录播停止后才能回退播放（默认值）&lt;/li&gt;
&lt;li&gt;0: 表示从当前帧开始播放&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;reset: Boolean类型，可选参数
&lt;ul&gt;
&lt;li&gt;true: 表示清除之前的流，重新开始一路播放&lt;/li&gt;
&lt;li&gt;false: 表示保留原来的流，向本地的播放列表中再添加一条播放流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;play2&#34;&gt;play2&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 和play不同的是, 该命令可以将当前正在播放的流切换到同样数据但不同码率的流上，服务器会维护多种码率的文件来供客户端使用play2命令来切换&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;play2&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为2&lt;/li&gt;
&lt;li&gt;Start Time:&lt;/li&gt;
&lt;li&gt;oldStreamName:&lt;/li&gt;
&lt;li&gt;Stream Name:&lt;/li&gt;
&lt;li&gt;Duration:&lt;/li&gt;
&lt;li&gt;Transition:&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;deletestream&#34;&gt;deleteStream&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 当NetStream对象销毁的时候发送删除流命令&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下：
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;deleteStream&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;Stream ID: Number类型，要销毁的流的ID&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端不返回任何响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;receiveaudio&#34;&gt;receiveAudio&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 告知服务端是否要发送音频&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下：
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;receiveAudio&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;Bool Flag: Boolean类型, 表示是否接收音频流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端不返回任何响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;receivevideo&#34;&gt;receiveVideo&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 告知服务端是否要发送视频&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下：
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;receiveAudio&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;Bool Flag: Boolean类型, 表示是否接收视频流&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;服务端不返回任何响应&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;publish&#34;&gt;publish&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 客户端向服务器发起请求推流到服务器&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下：
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;publish&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;Publishing Name: 流名字(String)&lt;/li&gt;
&lt;li&gt;Publishing Type：推流类型(String)
&lt;ul&gt;
&lt;li&gt;&amp;quot;live&amp;quot;: 表示推流文件无需在服务器端存储&lt;/li&gt;
&lt;li&gt;&amp;quot;record&amp;quot;: 将推流数据保存在服务器端覆盖写&lt;/li&gt;
&lt;li&gt;&amp;quot;append&amp;quot;: 将推流数据保存在服务器端，追加写&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;wireshark抓包示例&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1592732391519.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;seek&#34;&gt;seek&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 定位到视频或音频的某个位置，以毫秒为单位&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;seek&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;milliSeconds: Number类型，表示定位到该文件的xx毫秒处&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;pause&#34;&gt;pause&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;含义: 客户端告知服务端停止或恢复播放&lt;/li&gt;
&lt;li&gt;Chunk Data字段如下:
&lt;ul&gt;
&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;pause&amp;quot;&lt;/li&gt;
&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;
&lt;li&gt;Command Object: Null类型&lt;/li&gt;
&lt;li&gt;Pause/Unpause Flag: Boolean类型。true表示暂停，false表示恢复&lt;/li&gt;
&lt;li&gt;milliSeconds: Number类型，表示暂停或者恢复的时间，以毫秒为单位&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
">RTMP协议整理</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/epoll-shi-jian-qu-dong/"" data-c="
          &lt;p&gt;Linux系统下，Nginx会默认使用epoll作为事件驱动机制，使用epoll是Nginx性能高的一个重要原因。&lt;br&gt;
本文对epoll工作机制稍作整理。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;事件驱动&#34;&gt;事件驱动&lt;/h2&gt;
&lt;p&gt;事件驱动又称作IO多路复用，epoll是Linux内核实现一种IO多路复用机制&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IO： 在Linux系统下，一切皆文件。文件可读/可写即称作IO，比如：普通文件、socket套接字、进程之间通信的管道pipe，都是可以IO的对象。Linux系统统一用文件描述符fd表示。&lt;/li&gt;
&lt;li&gt;事件：
&lt;ul&gt;
&lt;li&gt;可读事件：当fd关联的内核读缓冲区可读时，则触发可读事件 （可写：内核缓冲区非空）&lt;/li&gt;
&lt;li&gt;可写事件：当fd关联的内科写缓冲区可写时，则触发可写事件   (可读：内核缓冲区不满)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;事件通知方式
&lt;ul&gt;
&lt;li&gt;主动通知：仅当有fd有事件发生时，内核主动通知上层应用有事件发生的fd集合&lt;/li&gt;
&lt;li&gt;被动通知：上层应用向内核轮询检查fd集合中的fd是否有事件发生&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;epoll-api介绍&#34;&gt;epoll API介绍&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1589288969778.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;epoll_create&#34;&gt;epoll_create&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原型：int epoll_create(int size)
&lt;ul&gt;
&lt;li&gt;功能：创建一个epoll实例，内核会返回一个表示epoll实例的fd&lt;/li&gt;
&lt;li&gt;入参
&lt;ul&gt;
&lt;li&gt;size: 原本表示所要监视fd的最多个数。现在Linux版中无意义，只要传值大于0的整数即可&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回值: epoll实例的fd&lt;/li&gt;
&lt;li&gt;说明：调用该API，内核会产生一个epoll实例数据结构，然后返回一个文件描述符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;epoll_ctl&#34;&gt;epoll_ctl&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原型: int epoll_ctl(int epfd， int op， int fd， struct epoll_event *event)
&lt;ul&gt;
&lt;li&gt;功能：添加/删除/修改要监听的事件&lt;/li&gt;
&lt;li&gt;入参
&lt;ul&gt;
&lt;li&gt;epfd: 即epoll_create创建的epoll实例描述符&lt;/li&gt;
&lt;li&gt;op: 添加、删除或修改
&lt;ul&gt;
&lt;li&gt;EPOLL_CTL_ADD: 添加一个需要监视的fd&lt;/li&gt;
&lt;li&gt;EPOLL_CTL_DEL: 删除一个fd&lt;/li&gt;
&lt;li&gt;EPOLL_CTL_MOD: 修改一个fd&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;fd: IO对象描述符&lt;/li&gt;
&lt;li&gt;event结构体&lt;pre&gt;&lt;code&gt;struct epoll_event {
    __uint32_t events;
    epoll_data_t data;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;events字段：感兴趣的事件描述，可多选
&lt;ul&gt;
&lt;li&gt;EPOLLIN：fd处于可读状态&lt;/li&gt;
&lt;li&gt;EPOLLOUT：fd处于可写状态&lt;/li&gt;
&lt;li&gt;EPOLLET：通知模式为边缘触发模式，相对于水平触发模式而言&lt;/li&gt;
&lt;li&gt;EPOLLONESHOT：第一次进行通知，之后不再检测&lt;/li&gt;
&lt;li&gt;EPOLLHUP： 本端产生一个挂断事件，默认检测事件&lt;/li&gt;
&lt;li&gt;EPOLLDHUP：对端产生一个挂断事件&lt;/li&gt;
&lt;li&gt;EPOLLPRI：由带外数据触发&lt;/li&gt;
&lt;li&gt;EPOLLERR：产生错误时触发，默认检测事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;data字段：是一个union结构&lt;pre&gt;&lt;code&gt;typedef union epoll_data {
    void *ptr;
    int fd;
    __uint32_t u32;
    __uint64_t u64;
};
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;如果不需要额外的信息，只需简单的赋值: &lt;code&gt;epoll_data.fd = fd&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果需要额外信息，则可以使用&lt;code&gt;void *ptr&lt;/code&gt;, 这样epoll_wait返回时可以使用&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;返回值: 如果返回-1表示调用失败&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;epoll_wait&#34;&gt;epoll_wait&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原型：int epoll_wait(int epfd， struct epoll_event *events， int maxevents， int timeout)
&lt;ul&gt;
&lt;li&gt;功能：阻塞等待已注册的事件发生，返回事件的数目，并将触发的事件写入events数组中&lt;/li&gt;
&lt;li&gt;入参：
&lt;ul&gt;
&lt;li&gt;epfd: 即epoll_create创建的epoll实例描述符&lt;/li&gt;
&lt;li&gt;events：用来记录被触发的事件数组，其大小应该和maxevents一致&lt;/li&gt;
&lt;li&gt;maxevents: 返回的events的最大个数&lt;/li&gt;
&lt;li&gt;timeout: 阻塞超时(以ms为单位)
&lt;ul&gt;
&lt;li&gt;如果传参-1， 则调用一直阻塞，直到有事件发生或捕获其他信号&lt;/li&gt;
&lt;li&gt;如果传参0，则非阻塞检测是否有事件发生，无论有事件还是没事件，调用立即返回&lt;/li&gt;
&lt;li&gt;如果传参大于0， 则最多等待timeout时间返回，如果等待期间有事件发生则立即返回&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;水平触发和边缘触发&#34;&gt;水平触发和边缘触发&lt;/h2&gt;
&lt;h3 id=&#34;水平触发&#34;&gt;水平触发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;只要缓冲区有数据，则返回可读事件&lt;/li&gt;
&lt;li&gt;只要缓冲区还不满，则返回可写事件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;边缘触发&#34;&gt;边缘触发&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可读事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当缓冲区数据为空变为非空时，则返回可读事件&lt;/li&gt;
&lt;li&gt;当缓冲区接收到新数据时，即缓冲区待读数据变多时，返回可读事件&lt;/li&gt;
&lt;li&gt;当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时，返回可读事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可写事件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当缓冲区由不可写变为可写时，则返回可写事件&lt;/li&gt;
&lt;li&gt;当有旧数据被发送走，即缓冲区中的内容变少的时候，返回可写事件&lt;/li&gt;
&lt;li&gt;当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时，返回可写事件&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;代码示例&#34;&gt;代码示例&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;unistd.h&amp;gt;
#include &amp;lt;sys/epoll.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

#define MAX_EVENTS 5
#define READ_SIZE 10

int main() {
    int running = 1, event_count, i;
    size_t bytes_read;
    char read_buffer[READ_SIZE + 1];
    struct epoll_event event, events[MAX_EVENTS];

    int epoll_fd = epoll_create1(0);
    if (epoll_fd == -1) {
        fprintf(stderr, &amp;quot;Failed to create epoll fd\n&amp;quot;);
        return 1;
    }

    event.events = EPOLLIN;
    event.data.fd = 0;

    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, 0, &amp;amp;event) == -1) {
        fprintf(stderr, &amp;quot;Failed to add fd to epoll\n&amp;quot;);
        return 1;
    }

    while (running) {
        printf(&amp;quot;\nPolling for input...\n&amp;quot;);
        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, 30000);
        printf(&amp;quot;%d ready events\n&amp;quot;, event_count);
        for (i = 0; i &amp;lt; event_count; i++) {
            printf(&amp;quot;Reading fd &#39;%d&#39; -- &amp;quot;, events[i].data.fd);
            bytes_read = read(events[i].data.fd, read_buffer, READ_SIZE);
            printf(&amp;quot;%zd bytes read.\n&amp;quot;, bytes_read);
            read_buffer[bytes_read] = &#39;\0&#39;;
            printf(&amp;quot;Read &#39;%s&#39;\n&amp;quot;, read_buffer);

            if (!strncmp(read_buffer, &amp;quot;stop\n&amp;quot;, 5)) {
                running = 0;
            }
        }
    }

    if (close(epoll_fd)) {
        fprintf(stderr, &amp;quot;Failed to close epoll fd\n&amp;quot;);
        return 1;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
">epoll事件驱动</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/nginx-yuan-ma-fen-xi-zhi-http-kuang-jia/"" data-c="
          &lt;p&gt;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;http框架初始化流程图&#34;&gt;http框架初始化流程图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1589099904999.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;结合流程简图和代码描述总体流程&#34;&gt;结合流程简图和代码描述总体流程&lt;/h2&gt;
&lt;p&gt;当配置文件nginx.conf配置了http{...}并被解析到时，http框架通过执行ngx_http_block函数开始初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static char *
ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                        *rv;
    ngx_uint_t                   mi, m, s;
    ngx_conf_t                   pcf;
    ngx_http_module_t           *module;
    ngx_http_conf_ctx_t         *ctx;
    ngx_http_core_loc_conf_t    *clcf;
    ngx_http_core_srv_conf_t   **cscfp;
    ngx_http_core_main_conf_t   *cmcf;

    if (*(ngx_http_conf_ctx_t **) conf) {
        return &amp;quot;is duplicate&amp;quot;;
    }

    /* the main http context */

    ctx = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(ngx_http_conf_ctx_t **) conf = ctx;

    /*初始化所有HTTP模块的ctx_index序号*/
    ngx_http_max_module = ngx_count_modules(cf-&amp;gt;cycle, NGX_HTTP_MODULE);

    /*分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组main_conf、srv_conf、loc_conf*/
    ctx-&amp;gt;main_conf = ngx_pcalloc(cf-&amp;gt;pool,
                                 sizeof(void *) * ngx_http_max_module);
    if (ctx-&amp;gt;main_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    ctx-&amp;gt;srv_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);
    if (ctx-&amp;gt;srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    ctx-&amp;gt;loc_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);
    if (ctx-&amp;gt;loc_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    /*
     * 处理http{}块内的main级别配置时，对每个HTTP模块，都会调用create_(main|srv|loc)_conf等3个方法
     */
    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue; //跳过非http模块
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;
        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;

        if (module-&amp;gt;create_main_conf) {
            ctx-&amp;gt;main_conf[mi] = module-&amp;gt;create_main_conf(cf); //main级别
            if (ctx-&amp;gt;main_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        if (module-&amp;gt;create_srv_conf) {
            ctx-&amp;gt;srv_conf[mi] = module-&amp;gt;create_srv_conf(cf); //server级别
            if (ctx-&amp;gt;srv_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        if (module-&amp;gt;create_loc_conf) {
            ctx-&amp;gt;loc_conf[mi] = module-&amp;gt;create_loc_conf(cf); //location级别
            if (ctx-&amp;gt;loc_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }
    }

    pcf = *cf;
    cf-&amp;gt;ctx = ctx;

    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;preconfiguration) {
            if (module-&amp;gt;preconfiguration(cf) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    /* 解析http{} main配置 */
    cf-&amp;gt;module_type = NGX_HTTP_MODULE;
    cf-&amp;gt;cmd_type = NGX_HTTP_MAIN_CONF;
    rv = ngx_conf_parse(cf, NULL); //解析内部配置

    if (rv != NGX_CONF_OK) {
        goto failed;
    }

    cmcf = ctx-&amp;gt;main_conf[ngx_http_core_module.ctx_index];
    cscfp = cmcf-&amp;gt;servers.elts;

    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;
        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;

        //调用所有HTTP模块的init_main_conf方法，保存main级别配置
        if (module-&amp;gt;init_main_conf) {
            rv = module-&amp;gt;init_main_conf(cf, ctx-&amp;gt;main_conf[mi]);
            if (rv != NGX_CONF_OK) {
                goto failed;
            }
        }

        //合并ngx_modules[m]模块main、srv、loc配置
        rv = ngx_http_merge_servers(cf, cmcf, module, mi);
        if (rv != NGX_CONF_OK) {
            goto failed;
        }
    }

    /* 构造location组成的静态二叉平衡查找树 */
    for (s = 0; s &amp;lt; cmcf-&amp;gt;servers.nelts; s++) {

        clcf = cscfp[s]-&amp;gt;ctx-&amp;gt;loc_conf[ngx_http_core_module.ctx_index];

        //将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序
        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) {
            return NGX_CONF_ERROR;
        }

        //根据已经排序过的的双向链表，构建静态的二叉查找树
        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) {
            return NGX_CONF_ERROR;
        }
    }

    /* 初始化可添加处理方法的HTTP阶段的动态数组 */
    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    /* 调用所有HTTP模块的postconfiguration方法，使之可以介入HTTP请求处理阶段 */
    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;postconfiguration) {
            if (module-&amp;gt;postconfiguration(cf) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    if (ngx_http_variables_init_vars(cf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    /*
     * http{}&#39;s cf-&amp;gt;ctx was needed while the configuration merging
     * and in postconfiguration process
     */

    *cf = pcf;

    //根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组
    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }


    //构造监听端口与server间的关联关系，设置新连接事件的回调方法
    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&amp;gt;ports) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;

failed:

    *cf = pcf;

    return rv;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化所有http模块的ctx_index序号&#34;&gt;初始化所有HTTP模块的ctx_index序号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ctx_index表示模块在同类型模块中的索引，比如ngx_http_core_module是HTTP模块（NGX_HTTP_MODULE）的首个模块，那么该模块的ctx_index为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分配解析http块下main级别配置项时存放http模块结构体指针的3个数组&#34;&gt;分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分配main_conf数组用于保存各个HTTP模块在main级别可能创建的xx_main_conf_t结构体&lt;/li&gt;
&lt;li&gt;分配srv_conf数组用于保存各个HTTP模块在main级别可能创建的xx_srv_conf_t结构体&lt;/li&gt;
&lt;li&gt;分配loc_conf数组用于保存各个HTTP模块在main级别可能创建的xx_loc_conf_t结构体&lt;/li&gt;
&lt;li&gt;另外，必须同时创建3个数组。因为对于HTTP模块来说，某个指令有可能同时出现在main、srv、loc级别。实际应用配置项时，具体以那个级别的配置项为准，需要合并处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;依次调用所有http模块的create_mainsrvloc_conf共3个方法&#34;&gt;依次调用所有HTTP模块的create_(main|srv|loc)_conf共3个方法&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的这3个回调方法，如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用create_main_conf，分配每个HTTP模块main级别的xx_main_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;li&gt;调用create_srv_conf，分配每个HTTP模块main级别的xx_srv_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;li&gt;调用create_loc_conf，分配每个HTTP模块main级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用所有http模块的preconfiguration方法&#34;&gt;调用所有HTTP模块的preconfiguration方法&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;preconfiguration&lt;/code&gt;回调方法，如果实现，则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用preconfiguration方法, 一般用于添加变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解析http块下的所有main级别配置项&#34;&gt;解析http{}块下的所有main级别配置项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交由conf模块解析http{}块下的配置
&lt;ul&gt;
&lt;li&gt;特别的，如果内部碰到server{}块时，则会分配srv_conf、loc_conf数组分别用于保存各个HTTP模块在server级别可能创建的xx_srv_conf_t、xx_loc_conf_t结构体。然后调用create_srv_conf、create_loc_conf分配每个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体内存，并对字段赋初始值
&lt;ul&gt;
&lt;li&gt;特别的，如果内部碰到location{}块时，则会分配loc_conf数组分别用于保存各个HTTP模块在location级别可能创建的xx_loc_conf_t结构体。然后调用create_loc_conf分配每个HTTP模块在location级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;li&gt;location{}下的配置解析完，则各个HTTP模块在location级别的xxx_loc_conf_t结构体赋值完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;server{}下的配置解析完，则各个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体赋值完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用所有http模块的init_main_conf方法&#34;&gt;调用所有HTTP模块的init_main_conf方法&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的init_main_conf回调方法, 如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置解析完成后，调用init_main_conf方法，最终确定并保存各个HTTP模块在main级别的xx_main_conf_t配置结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;合并main-srv-loc级别下server-location相关的配置项&#34;&gt;合并main、srv、loc级别下server、location相关的配置项&lt;/h3&gt;
&lt;p&gt;对每一server{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_srv_conf和merge_loc_conf回调方法, 如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用merge_srv_conf和merge_loc_conf方法，最终确定并保存各个HTTP模块在server级别的xx_(srv|loc)_conf_t配置结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每一个location{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_loc_conf回调方法, 如果实现, 则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用merge_loc_conf方法，最终确定并保存各个HTTP模块在location级别的xx_loc_conf_t配置结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造location组成的静态二叉平衡查找树&#34;&gt;构造location组成的静态二叉平衡查找树&lt;/h3&gt;
&lt;p&gt;对于每一个server而言，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序&lt;/li&gt;
&lt;li&gt;根据已经排序过的的双向链表，构建静态的二叉查找树。这样处理请求时可以加速找到location&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初始化可添加处理方法的http阶段的动态数组&#34;&gt;初始化可添加处理方法的HTTP阶段的动态数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;http请求处理的11个阶段，分配数组，用于后续添加模块自定义的handler方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用所有http模块的postconfiguration方法使之可以介入http阶段&#34;&gt;调用所有HTTP模块的postconfiguration方法使之可以介入HTTP阶段&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;postconfiguration&lt;/code&gt;方法，如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用postconfiguration，将handler方法添加到上一步常见的某个阶段(哪个阶段由模块自行决定，但只有7个阶段可以介入)的数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;根据各个http模块介入的处理方法构造出phase_engine_handlers数组&#34;&gt;根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根据前两步构造的的动态数组，调用&lt;code&gt;ngx_http_init_phase_handlers&lt;/code&gt;函数构造出phase_engine_handlers数组&lt;/li&gt;
&lt;li&gt;特别的，有四个阶段不允许介入或者介入无效，分别是：&lt;code&gt;NGX_HTTP_FIND_CONFIG_PHASE&lt;/code&gt;、&lt;br&gt;
&lt;code&gt;NGX_HTTP_POST_REWRITE_PHASE&lt;/code&gt;、&lt;code&gt;NGX_HTTP_POST_ACCESS_PHASE&lt;/code&gt;、&lt;br&gt;
&lt;code&gt;NGX_HTTP_PRECONTENT_PHASE&lt;/code&gt;(旧的Nginx的try_files阶段)&lt;/li&gt;
&lt;li&gt;特别的，&lt;code&gt;NGX_HTTP_CONTENT_PHASE&lt;/code&gt;阶段，除了常规的postconfiguration介入方式(这种方式影响所有的location)。另外可以直接以ngx_command_t指定location的handler方式介入，只对location有该指令的location生效&lt;/li&gt;
&lt;li&gt;特别的,  记录http日志（最后一个阶段log）特殊处理，并不会出现在phase_engine_handlers数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造server虚拟主机构成的支持通配符的散列表&#34;&gt;构造server虚拟主机构成的支持通配符的散列表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ngx_http_server_names&lt;/code&gt;将server虚拟主机和对应的ngx_http_core_srv_conf_t结构体指针哈希化关联起来，这样处理请求时可以快速匹配server&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造监听端口与server间的关联关系并设置新连接事件的回调方法&#34;&gt;构造监听端口与server间的关联关系，并设置新连接事件的回调方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将监听端口&lt;code&gt;ngx_http_conf_port_t&lt;/code&gt;和addr地址&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;关联&lt;/li&gt;
&lt;li&gt;进一步，将&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;和server虚拟主机关联。该结构体有3个哈希表结构字段，&lt;br&gt;
分别用于索引完全匹配的sever_name、通配符前置、通配符后置的server虚拟主机结构体&lt;code&gt;ngx_http_core_srv_conf_t&lt;/code&gt;结构体指针&lt;/li&gt;
&lt;li&gt;设置新连接事件的回调方法: &lt;code&gt;ngx_http_init_connection&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http请求的11个阶段&#34;&gt;http请求的11个阶段&lt;/h2&gt;
&lt;h3 id=&#34;构造phase_engine_handlers数组&#34;&gt;构造phase_engine_handlers数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_init_phase_handlers函数在http初始化时调用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组
static ngx_int_t
ngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
{
    ngx_int_t                   j;
    ngx_uint_t                  i, n;
    ngx_uint_t                  find_config_index, use_rewrite, use_access;
    ngx_http_handler_pt        *h;
    ngx_http_phase_handler_t   *ph;
    ngx_http_phase_handler_pt   checker;

    cmcf-&amp;gt;phase_engine.server_rewrite_index = (ngx_uint_t) -1;
    cmcf-&amp;gt;phase_engine.location_rewrite_index = (ngx_uint_t) -1;
    find_config_index = 0;
    use_rewrite = cmcf-&amp;gt;phases[NGX_HTTP_REWRITE_PHASE].handlers.nelts ? 1 : 0;
    use_access = cmcf-&amp;gt;phases[NGX_HTTP_ACCESS_PHASE].handlers.nelts ? 1 : 0;

    n = 1                  /* find config phase */
        + use_rewrite      /* post rewrite phase */
        + use_access;      /* post access phase */

    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意:不包含NGX_HTTP_LOG_PHASE阶段,该阶段另行特殊处理
        n += cmcf-&amp;gt;phases[i].handlers.nelts; //累加计算总的HTTP阶段处理方法个数
    }

    ph = ngx_pcalloc(cf-&amp;gt;pool,
                     n * sizeof(ngx_http_phase_handler_t) + sizeof(void *));
    if (ph == NULL) {
        return NGX_ERROR;
    }

    cmcf-&amp;gt;phase_engine.handlers = ph;
    n = 0;

    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意: 不包含NGX_HTTP_LOG_PHASE阶段
        h = cmcf-&amp;gt;phases[i].handlers.elts;

        switch (i) {

        case NGX_HTTP_SERVER_REWRITE_PHASE:
            if (cmcf-&amp;gt;phase_engine.server_rewrite_index == (ngx_uint_t) -1) {
                cmcf-&amp;gt;phase_engine.server_rewrite_index = n;
            }
            checker = ngx_http_core_rewrite_phase;

            break;

        case NGX_HTTP_FIND_CONFIG_PHASE:
            find_config_index = n;

            ph-&amp;gt;checker = ngx_http_core_find_config_phase;
            n++;
            ph++;

            continue;

        case NGX_HTTP_REWRITE_PHASE:
            if (cmcf-&amp;gt;phase_engine.location_rewrite_index == (ngx_uint_t) -1) {
                cmcf-&amp;gt;phase_engine.location_rewrite_index = n;
            }
            checker = ngx_http_core_rewrite_phase;

            break;

        case NGX_HTTP_POST_REWRITE_PHASE:
            if (use_rewrite) {
                ph-&amp;gt;checker = ngx_http_core_post_rewrite_phase;
                ph-&amp;gt;next = find_config_index;
                n++;
                ph++;
            }

            continue;

        case NGX_HTTP_ACCESS_PHASE:
            checker = ngx_http_core_access_phase;
            n++;
            break;

        case NGX_HTTP_POST_ACCESS_PHASE:
            if (use_access) {
                ph-&amp;gt;checker = ngx_http_core_post_access_phase;
                ph-&amp;gt;next = n;
                ph++;
            }

            continue;

        case NGX_HTTP_CONTENT_PHASE:
            checker = ngx_http_core_content_phase;
            break;

        default: //NGX_HTTP_POST_READ_PHASE、NGX_HTTP_PREACCESS_PHASE、NGX_HTTP_PRECONTENT_PHASE
            checker = ngx_http_core_generic_phase;
        }

        n += cmcf-&amp;gt;phases[i].handlers.nelts; //跳过本阶段的所有handler, 也即下一阶段的首个handler

        //注意:每个HTTP处理阶段中最后加入到handlers[]中的会首先添加到cmcf-&amp;gt;phase_engine.handlers
        for (j = cmcf-&amp;gt;phases[i].handlers.nelts - 1; j &amp;gt;= 0; j--) {
            ph-&amp;gt;checker = checker;
            ph-&amp;gt;handler = h[j];
            ph-&amp;gt;next = n; //下一阶段的首个handler序号
            ph++;
        }
    }

    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;checker方法&#34;&gt;checker方法&lt;/h3&gt;
&lt;h4 id=&#34;ngx_http_core_generic_phase&#34;&gt;ngx_http_core_generic_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_(POST_READ | PREACCESS | PRECONTENT)_PHASE等阶段的checker方法
 */
ngx_int_t
ngx_http_core_generic_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    /*
     * generic phase checker,
     * used by the post read and pre-access phases
     */

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;generic phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    //调用HTTP模块添加的handler处理方法(由各个HTTP模块的postconfiguration钩子函数添加)
    rc = ph-&amp;gt;handler(r);

    if (rc == NGX_OK) {
        r-&amp;gt;phase_handler = ph-&amp;gt;next; //rc为NGX_OK时，进入下一阶段就行处理, 当前阶段即使有其他处理方法也会跳过
        return NGX_AGAIN;
    }

    if (rc == NGX_DECLINED) {
        r-&amp;gt;phase_handler++; //下一个处理方法，可能仍是当前阶段，也有可能是下一个阶段的首个处理方法
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块
    }

    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc); //返回错误NGX_ERROR或者NGX_HTTP_开头的返回码，则结束请求

    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_rewrite_phase&#34;&gt;ngx_http_core_rewrite_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_(SERVER_REWRITE | REWRITE)_PHASE等阶段的checker方法
 */
ngx_int_t
ngx_http_core_rewrite_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    rc = ph-&amp;gt;handler(r); //执行挂载的handler方法

    if (rc == NGX_DECLINED) {
        r-&amp;gt;phase_handler++; //当前处理方法执行完毕，执行下一个处理方法
        return NGX_AGAIN;
    }

    if (rc == NGX_DONE) {
        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块
    }

    /* NGX_OK, NGX_AGAIN, NGX_ERROR, NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc); //结束请求

    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_find_config_phase&#34;&gt;ngx_http_core_find_config_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 根据请求的URI寻找匹配的location表达式，不允许用户模块介入。即使介入也无效，因为入参ph未使用
 */
ngx_int_t
ngx_http_core_find_config_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    u_char                    *p;
    size_t                     len;
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    r-&amp;gt;content_handler = NULL;
    r-&amp;gt;uri_changed = 0;

    rc = ngx_http_core_find_location(r);

    if (rc == NGX_ERROR) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!r-&amp;gt;internal &amp;amp;&amp;amp; clcf-&amp;gt;internal) {
        ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);
        return NGX_OK;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;using configuration \&amp;quot;%s%V\&amp;quot;&amp;quot;,
                   (clcf-&amp;gt;noname ? &amp;quot;*&amp;quot; : (clcf-&amp;gt;exact_match ? &amp;quot;=&amp;quot; : &amp;quot;&amp;quot;)),
                   &amp;amp;clcf-&amp;gt;name);

    ngx_http_update_location_config(r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;http cl:%O max:%O&amp;quot;,
                   r-&amp;gt;headers_in.content_length_n, clcf-&amp;gt;client_max_body_size);

    if (r-&amp;gt;headers_in.content_length_n != -1
        &amp;amp;&amp;amp; !r-&amp;gt;discard_body
        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size
        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size &amp;lt; r-&amp;gt;headers_in.content_length_n)
    {
        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                      &amp;quot;client intended to send too large body: %O bytes&amp;quot;,
                      r-&amp;gt;headers_in.content_length_n);

        r-&amp;gt;expect_tested = 1;
        (void) ngx_http_discard_request_body(r);
        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);
        return NGX_OK;
    }

    if (rc == NGX_DONE) {
        ngx_http_clear_location(r);

        r-&amp;gt;headers_out.location = ngx_list_push(&amp;amp;r-&amp;gt;headers_out.headers);
        if (r-&amp;gt;headers_out.location == NULL) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return NGX_OK;
        }

        r-&amp;gt;headers_out.location-&amp;gt;hash = 1;
        ngx_str_set(&amp;amp;r-&amp;gt;headers_out.location-&amp;gt;key, &amp;quot;Location&amp;quot;);

        if (r-&amp;gt;args.len == 0) {
            r-&amp;gt;headers_out.location-&amp;gt;value = clcf-&amp;gt;name;

        } else {
            len = clcf-&amp;gt;name.len + 1 + r-&amp;gt;args.len;
            p = ngx_pnalloc(r-&amp;gt;pool, len);

            if (p == NULL) {
                ngx_http_clear_location(r);
                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                return NGX_OK;
            }

            r-&amp;gt;headers_out.location-&amp;gt;value.len = len;
            r-&amp;gt;headers_out.location-&amp;gt;value.data = p;

            p = ngx_cpymem(p, clcf-&amp;gt;name.data, clcf-&amp;gt;name.len);
            *p++ = &#39;?&#39;;
            ngx_memcpy(p, r-&amp;gt;args.data, r-&amp;gt;args.len);
        }

        ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);
        return NGX_OK;
    }

    r-&amp;gt;phase_handler++; //下一阶段
    return NGX_AGAIN;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_post_rewrite_phase&#34;&gt;ngx_http_core_post_rewrite_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_POST_REWRITE_PHASE阶段的checker方法
 */
ngx_int_t
ngx_http_core_post_rewrite_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_http_core_srv_conf_t  *cscf;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;post rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    if (!r-&amp;gt;uri_changed) {
        r-&amp;gt;phase_handler++;
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;uri changes: %d&amp;quot;, r-&amp;gt;uri_changes);

    /*
     * gcc before 3.3 compiles the broken code for
     *     if (r-&amp;gt;uri_changes-- == 0)
     * if the r-&amp;gt;uri_changes is defined as
     *     unsigned  uri_changes:4
     */

    r-&amp;gt;uri_changes--;

    if (r-&amp;gt;uri_changes == 0) { //url改写次数超限，结束请求
        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                      &amp;quot;rewrite or internal redirection cycle &amp;quot;
                      &amp;quot;while processing \&amp;quot;%V\&amp;quot;&amp;quot;, &amp;amp;r-&amp;gt;uri);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    r-&amp;gt;phase_handler = ph-&amp;gt;next;

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
    r-&amp;gt;loc_conf = cscf-&amp;gt;ctx-&amp;gt;loc_conf;

    return NGX_AGAIN;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_access_phase&#34;&gt;ngx_http_core_access_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_ACCESS_PHASE阶段的checker方法
 */
ngx_int_t
ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    if (r != r-&amp;gt;main) { //子请求
        r-&amp;gt;phase_handler = ph-&amp;gt;next; //跳到下一个阶段
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    rc = ph-&amp;gt;handler(r); //执行模块挂载的handler方法

    if (rc == NGX_DECLINED) {
        r-&amp;gt;phase_handler++; //下一个处理方法
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf-&amp;gt;satisfy == NGX_HTTP_SATISFY_ALL) {

        if (rc == NGX_OK) {
            r-&amp;gt;phase_handler++; //satisfy all, 则执行下一个handler方法
            return NGX_AGAIN;
        }

    } else { //satisfy any
        if (rc == NGX_OK) {
            r-&amp;gt;access_code = 0;

            if (r-&amp;gt;headers_out.www_authenticate) {
                r-&amp;gt;headers_out.www_authenticate-&amp;gt;hash = 0;
            }

            r-&amp;gt;phase_handler = ph-&amp;gt;next; //satisfy any, 则跳到下一个阶段
            return NGX_AGAIN;
        }

        if (rc == NGX_HTTP_FORBIDDEN || rc == NGX_HTTP_UNAUTHORIZED) {
            if (r-&amp;gt;access_code != NGX_HTTP_UNAUTHORIZED) {
                r-&amp;gt;access_code = rc;
            }

            r-&amp;gt;phase_handler++; //下一个handler方法
            return NGX_AGAIN;
        }
    }

    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc); //结束请求
    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_post_access_phase&#34;&gt;ngx_http_core_post_access_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_POST_ACCESS_PHASE阶段的checker方法, 入参ph未使用，即不允许介入
 */
ngx_int_t
ngx_http_core_post_access_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_int_t  access_code;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;post access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    access_code = r-&amp;gt;access_code;

    if (access_code) { //access_code非0，表明没有访问权限
        if (access_code == NGX_HTTP_FORBIDDEN) {
            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                          &amp;quot;access forbidden by rule&amp;quot;);
        }

        r-&amp;gt;access_code = 0;
        ngx_http_finalize_request(r, access_code);
        return NGX_OK;
    }

    r-&amp;gt;phase_handler++;
    return NGX_AGAIN;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_content_phase&#34;&gt;ngx_http_core_content_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_CONTENT_PHASE阶段的checker方法
 */
ngx_int_t
ngx_http_core_content_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    size_t     root;
    ngx_int_t  rc;
    ngx_str_t  path;

    if (r-&amp;gt;content_handler) { //介入的特殊方式: 某location特有的handler方法, 不影响其他location
        r-&amp;gt;write_event_handler = ngx_http_request_empty_handler;
        ngx_http_finalize_request(r, r-&amp;gt;content_handler(r));
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;content phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    rc = ph-&amp;gt;handler(r); //执行postconfiguration钩子函数添加的handler方法

    if (rc != NGX_DECLINED) {
        ngx_http_finalize_request(r, rc);
        return NGX_OK;
    }

    /* rc == NGX_DECLINED */

    ph++;

    if (ph-&amp;gt;checker) {
        r-&amp;gt;phase_handler++; //下一个handler方法
        return NGX_AGAIN;
    }

    /* no content handler was found */

    if (r-&amp;gt;uri.data[r-&amp;gt;uri.len - 1] == &#39;/&#39;) {

        if (ngx_http_map_uri_to_path(r, &amp;amp;path, &amp;amp;root, 0) != NULL) {
            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                          &amp;quot;directory index of \&amp;quot;%s\&amp;quot; is forbidden&amp;quot;, path.data);
        }

        ngx_http_finalize_request(r, NGX_HTTP_FORBIDDEN);
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0, &amp;quot;no handler found&amp;quot;);

    ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND); //404
    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;处理请求经过10个阶段&#34;&gt;处理请求经过10个阶段&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 10个阶段处理HTTP请求
 */
void
ngx_http_core_run_phases(ngx_http_request_t *r)
{
    ngx_int_t                   rc;
    ngx_http_phase_handler_t   *ph;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    ph = cmcf-&amp;gt;phase_engine.handlers;

    while (ph[r-&amp;gt;phase_handler].checker) {

        rc = ph[r-&amp;gt;phase_handler].checker(r, &amp;amp;ph[r-&amp;gt;phase_handler]);

        if (rc == NGX_OK) {
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;记录http日志阶段特殊处理&#34;&gt;记录http日志阶段特殊处理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 记录访问日志。log阶段的handler链并不是在ngx_http_core_run_phases函数中执行, 它只需在请求处理逻辑结束后才执行一次
 */
static void
ngx_http_log_request(ngx_http_request_t *r)
{
    ngx_uint_t                  i, n;
    ngx_http_handler_pt        *log_handler;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    log_handler = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.elts;
    n = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.nelts;

    for (i = 0; i &amp;lt; n; i++) {
        log_handler[i](r);
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Nginx源码分析之--http框架</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/zsh-ti-dai-bash/"" data-c="
          &lt;p&gt;zsh替换bash，可以让命令行操作少敲很多字符👍&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装zsh&#34;&gt;安装zsh&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;yum install zsh -y
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装oh-my-zsh&#34;&gt;安装oh-my-zsh&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装zsh-autosuggestions插件&#34;&gt;安装zsh-autosuggestions插件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修改~zshrc文件&#34;&gt;修改~/.zshrc文件&lt;/h2&gt;
&lt;p&gt;找到plugins变量，增加zsh-autosuggestions，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins=(zsh-autosuggestions)
&lt;/code&gt;&lt;/pre&gt;
">zsh替代bash</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/ats-ru-men/"" data-c="
          &lt;p&gt;本文是对ATS的安装、配置、日志等相关基础知识的整理。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装-以trafficserver-805版本为例&#34;&gt;安装 （以trafficserver-8.0.5版本为例）&lt;/h2&gt;
&lt;h3 id=&#34;下载源代码并解压&#34;&gt;下载源代码并解压&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget
wget https://mirror.bit.edu.cn/apache/trafficserver/trafficserver-8.0.5.tar.bz2
tar xf trafficserver-8.0.5.tar.bz2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;准备c17编译环境&#34;&gt;准备c++17编译环境&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install centos-release-scl
yum -y install yum-utils
yum-config-manager --enable rhel-server-rhscl-7-rpms
yum -y install devtoolset-7

scl enable devtoolset-7 zsh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装tcl-dev-package&#34;&gt;安装TCL dev package&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install tcl-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装openssl-devel&#34;&gt;安装openssl-devel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install openssl-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装lua-devel&#34;&gt;安装lua-devel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install lua-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装ncurses-devel&#34;&gt;安装ncurses-devel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install ncurses-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生成makefile&#34;&gt;生成Makefile&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/opt/ats
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;构建-测试-安装&#34;&gt;构建、测试、安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;汇总安装步骤&#34;&gt;汇总安装步骤&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget tcl-devel openssl-devel lua-devel  ncurses-devel 
yum -y install centos-release-scl yum-utils
yum-config-manager --enable rhel-server-rhscl-7-rpms
yum -y install devtoolset-7
scl enable devtoolset-7 zsh

./configure --prefix=/opt/ats
make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;h3 id=&#34;核心配置文件recordsconfig&#34;&gt;核心配置文件records.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;li&gt;特别的，可以配置启用UI方便查看ATS运行时关键信息、检索和删除缓存等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反向代理回源映射配置文件remapconfig&#34;&gt;反向代理回源映射配置文件remap.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存相关配置文件cacheconfig&#34;&gt;缓存相关配置文件cache.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储配置storageconfig&#34;&gt;存储配置storage.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在records.config中配置日志路径、分割方式等&lt;/li&gt;
&lt;li&gt;squid风格的日志，使用traffic_logcat查看&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/portl4t/ts-lua&#34;&gt;lua插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.trafficserver.apache.org/en/8.0.x/admin-guide/plugins/index.en.html&#34;&gt;官方插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.trafficserver.apache.org/en/8.0.x/developer-guide/plugins/index.en.html&#34;&gt;插件开发指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">ATS入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/"" data-c="
          &lt;p&gt;Nginx作为高性能的web服务器，它是如何管理内存的呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;内存池的优点&#34;&gt;内存池的优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;pool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;&lt;/li&gt;
&lt;li&gt;内存统一分配和回收，避免内存泄漏；&lt;/li&gt;
&lt;li&gt;整块分配，避免内存过于碎片化;&lt;/li&gt;
&lt;li&gt;内存对齐处理，减少CPU读取内存次数，提高寻址效率；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内存池相关的数据结构&#34;&gt;内存池相关的数据结构&lt;/h2&gt;
&lt;h3 id=&#34;结构体示意图&#34;&gt;结构体示意图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1587183416580.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;typedef struct ngx_pool_s            ngx_pool_t;
typedef struct ngx_pool_large_s  ngx_pool_large_t;

struct ngx_pool_s { //内存池头部结构
    ngx_pool_data_t       d;        //内存池的数据区，即真正分配内存的区域
    size_t                max;      //每次可分配最大内存，用于判定是走大内存分配还是小内存分配逻辑
    ngx_pool_t           *current;  //指向当前内存池小块内存可用的首个节点
    ngx_chain_t          *chain;    //缓冲区链表
    ngx_pool_large_t     *large;    //内存块大于max内存块的链表
    ngx_pool_cleanup_t   *cleanup;  //销毁内存池回调函数
    ngx_log_t            *log;      //错误日志指针
};

typedef struct {
    u_char               *last;     //当前内存块已使用到此处，下一次使用从此处开始
    u_char               *end;      //内存块结束位置
    ngx_pool_t           *next;     //内存池有很多内存块，通过next指针组成链表
    ngx_uint_t            failed;   //内存块分配失败次数
} ngx_pool_data_t; //小内存块(链表)

//大内存块(链表)
struct ngx_pool_large_s {
    ngx_pool_large_t     *next;  //下一数据块地址
    void                 *alloc; //当前数据块地址
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;内存池主要函数&#34;&gt;内存池主要函数&lt;/h2&gt;
&lt;h3 id=&#34;新建内存池&#34;&gt;新建内存池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 新建一个内存池
 */
ngx_pool_t *
ngx_create_pool(size_t size, ngx_log_t *log)
{
    ngx_pool_t  *p;

    //调用系统内存分配函数，分配一块堆内存，且做对齐处理
    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
    if (p == NULL) {
        return NULL;
    }

    p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t);
    p-&amp;gt;d.end = (u_char *) p + size;
    p-&amp;gt;d.next = NULL;
    p-&amp;gt;d.failed = 0;

    size = size - sizeof(ngx_pool_t);
    //max最大为pagesize-1(比如:x86时为4095), 即：无论小块内存空间是否足够，超过pagesize-1大小的内存均走large块分配
    p-&amp;gt;max = (size &amp;lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;

    p-&amp;gt;current = p;
    p-&amp;gt;chain = NULL;
    p-&amp;gt;large = NULL;
    p-&amp;gt;cleanup = NULL;
    p-&amp;gt;log = log;

    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从内存池申请内存&#34;&gt;从内存池申请内存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先对齐再分配内存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 从内存池中申请一块内存
 * （1）如果申请的内存小于定义的max，则从内存池中分配内存，需先对齐再分配
 * （2）否则分配大块内存挂载到large指针上
 */
void *
ngx_palloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size &amp;lt;= pool-&amp;gt;max) {
        return ngx_palloc_small(pool, size, 1); //小块内存(先对齐)
    }
#endif

    return ngx_palloc_large(pool, size);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;先对齐再分配内存, 并填充0&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 从内存池中申请内存，并填充0
 */
void *
ngx_pcalloc(ngx_pool_t *pool, size_t size)
{
    void *p;

    p = ngx_palloc(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不用对齐分配内存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 从内存池中申请一块内存 （小块内存无需先对齐）
 */
void *
ngx_pnalloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size &amp;lt;= pool-&amp;gt;max) {
        return ngx_palloc_small(pool, size, 0); //小块内存（无需先对齐）
    }
#endif

    return ngx_palloc_large(pool, size);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从内存池申请内存小块内存&#34;&gt;从内存池申请内存小块内存&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 分配小块内存
 * 1. 循环遍历内存块ngx_pool_data_t链表
 * 2. 如果当前内存块剩余大小满足申请的内存大小，则移动相应指针，返回分配的内存指针
 * 3. 否则，移动到下一个内存块
 * 4. 如果所有内存块都没能满足申请的内存大小，则重新申请一块内存块挂载到链表上，并返回分配的内存地址
 */
static ngx_inline void *
ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)
{
    u_char      *m;
    ngx_pool_t  *p;

    p = pool-&amp;gt;current;

    do {
        m = p-&amp;gt;d.last; //最后使用位置

        if (align) {
            m = ngx_align_ptr(m, NGX_ALIGNMENT); //先内存对齐, 减少CPU读取内存次数
        }

        if ((size_t) (p-&amp;gt;d.end - m) &amp;gt;= size) { //当前内存块剩余空间足够
            p-&amp;gt;d.last = m + size; //最后使用位置更新，剩余空间变小

            return m;
        }

        p = p-&amp;gt;d.next;

    } while (p);

    //现有小块内存均无法分配，则新建内存块后再分配
    return ngx_palloc_block(pool, size);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新建小内存块再分配&#34;&gt;新建小内存块再分配&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 再次申请小块内存，并挂载到小块内存链表上，并返回当次申请的内存指针
*/
static void *
ngx_palloc_block(ngx_pool_t *pool, size_t size)
{
    u_char      *m;
    size_t       psize;
    ngx_pool_t  *p, *new;

    psize = (size_t) (pool-&amp;gt;d.end - (u_char *) pool);

    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&amp;gt;log);
    if (m == NULL) {
        return NULL;
    }

    new = (ngx_pool_t *) m;

    new-&amp;gt;d.end = m + psize;
    new-&amp;gt;d.next = NULL;
    new-&amp;gt;d.failed = 0;

    m += sizeof(ngx_pool_data_t);
    m = ngx_align_ptr(m, NGX_ALIGNMENT);
    new-&amp;gt;d.last = m + size;

    for (p = pool-&amp;gt;current; p-&amp;gt;d.next; p = p-&amp;gt;d.next) {
        //调整各个内存块分配失败次数，如果失败次数大于4，则此块内存节点不再使用
        if (p-&amp;gt;d.failed++ &amp;gt; 4) {
            pool-&amp;gt;current = p-&amp;gt;d.next;
        }
    }

    p-&amp;gt;d.next = new;

    return m;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分配大内存&#34;&gt;分配大内存&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 分配大内存块
 */
static void *
ngx_palloc_large(ngx_pool_t *pool, size_t size)
{
    void              *p;
    ngx_uint_t         n;
    ngx_pool_large_t  *large;

    p = ngx_alloc(size, pool-&amp;gt;log); //向系统申请size大小堆内存
    if (p == NULL) {
        return NULL;
    }

    n = 0;

    //查找一个空的large区，如果有，则将分配的空间p交由它管理（最多3次）
    for (large = pool-&amp;gt;large; large; large = large-&amp;gt;next) {
        if (large-&amp;gt;alloc == NULL) { //ngx_pfree函数会产生空的large区
            large-&amp;gt;alloc = p;
            return p;
        }

        if (n++ &amp;gt; 3) { //超过一定次数，放弃查找空的large区
            break;
        }
    }

    //创建一个新的large节点
    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    //新分配的空间p交由新建的large节点管理，并且插入到large链表头部
    large-&amp;gt;alloc = p;
    large-&amp;gt;next = pool-&amp;gt;large;
    pool-&amp;gt;large = large;

    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;销毁内存池&#34;&gt;销毁内存池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 销毁内存池
 */
void
ngx_destroy_pool(ngx_pool_t *pool)
{
    ngx_pool_t          *p, *n;
    ngx_pool_large_t    *l;
    ngx_pool_cleanup_t  *c;

    for (c = pool-&amp;gt;cleanup; c; c = c-&amp;gt;next) {
        if (c-&amp;gt;handler) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,
                           &amp;quot;run cleanup: %p&amp;quot;, c);
            c-&amp;gt;handler(c-&amp;gt;data);
        }
    }

#if (NGX_DEBUG)

    /*
     * we could allocate the pool-&amp;gt;log from this pool
     * so we cannot use this log while free()ing the pool
     */

    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {
        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0, &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);
    }

    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {
        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,
                       &amp;quot;free: %p, unused: %uz&amp;quot;, p, p-&amp;gt;d.end - p-&amp;gt;d.last);

        if (n == NULL) {
            break;
        }
    }

#endif

    //释放大内存块（链表）
    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {
        if (l-&amp;gt;alloc) {
            ngx_free(l-&amp;gt;alloc);
        }
    }

    //释放小内存块 (链表)
    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {
        ngx_free(p);

        if (n == NULL) {
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重置内存池&#34;&gt;重置内存池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 重置内存池
 * 1. 释放大块内存
 * 2. 重置可开始分配位置指针、分配失败次数为0、可用小内存块current指针指向首个内存块
 */
void
ngx_reset_pool(ngx_pool_t *pool)
{
    ngx_pool_t        *p;
    ngx_pool_large_t  *l;

    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) { //遍历大块内存链表，释放内存
        if (l-&amp;gt;alloc) {
            ngx_free(l-&amp;gt;alloc);
        }
    }

    for (p = pool; p; p = p-&amp;gt;d.next) {
        p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //恢复至初始为位置
        p-&amp;gt;d.failed = 0; //分配失败次数重置为0
    }

    pool-&amp;gt;current = pool; //current指向首个内存块
    pool-&amp;gt;chain = NULL;
    pool-&amp;gt;large = NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;回收大块内存链表上的某个节点内存&#34;&gt;回收大块内存链表上的某个节点内存&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 回收大块内存链表上的某个节点内存
 */
ngx_int_t
ngx_pfree(ngx_pool_t *pool, void *p)
{
    ngx_pool_large_t  *l;

    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {
        if (p == l-&amp;gt;alloc) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,
                           &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);
            ngx_free(l-&amp;gt;alloc);
            l-&amp;gt;alloc = NULL;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}
&lt;/code&gt;&lt;/pre&gt;
">Nginx源码分析之--内存池</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/gperftools-fen-xi-nginx/"" data-c="
          &lt;h2 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install libunwind-devel graphviz-devel ghostscript automake libtool -y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译gpreftools&#34;&gt;编译gpreftools&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;源代码：https://github.com/gperftools/gperftools/archive/gperftools-2.7.tar.gz&lt;/li&gt;
&lt;li&gt;编译安装
&lt;ul&gt;
&lt;li&gt;./autogen.sh&lt;/li&gt;
&lt;li&gt;./configure&lt;/li&gt;
&lt;li&gt;make &amp;amp;&amp;amp; make install&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;导出LD_LIBRARY_PATH
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export LD_LIBRARY_PATH=&amp;quot;$LD_LIBRARY_PATH:/usr/local/lib&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;nginx使用tcmalloc和启用google_perftools_module模块&#34;&gt;nginx使用tcmalloc和启用google_perftools_module模块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--with-ld-opt=-ltcmalloc --with-google_perftools_module&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
">gperftools分析Nginx</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/tcp-xie-yi/"" data-c="
          &lt;p&gt;好记性不如烂笔头，本文是tcp协议部分基础知识的整理。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;tcp建连-断连&#34;&gt;tcp建连、断连&lt;/h2&gt;
&lt;h3 id=&#34;示意图&#34;&gt;示意图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1586241639078.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;为什么需要三次握手&#34;&gt;为什么需要三次握手？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;防止失效的连接请求到达服务器。&lt;/li&gt;
&lt;li&gt;具体描述：如果client发送的连接请求SYN包在网络中滞留了较长时间，server最终仍会收到并发回连接确认SYN+ACK。而client等待一个超时时间后，认为刚才滞留的连接请求包丢失了，则会重新发送SYN包发起连接请求。如果不进行第三次握手，那么server收到滞留的SYN包就打开的连接是无效的；如果有第三次握手，那么client会忽略server对滞留的SYN包的响应SYN+ACK，不回复ACK包，server收不到第三次握手ACK包就不会新建连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp面向连接什么含义&#34;&gt;tcp面向连接什么含义？&lt;/h3&gt;
&lt;p&gt;为了在client和server间维护连接，需建立一定的数据结构来维护双方的交互状态，用这样的数据结构来保证面向连接的特性。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要四次挥手&#34;&gt;为什么需要四次挥手？&lt;/h3&gt;
&lt;p&gt;一端发送FIN包请求释放连接，对端收到这个FIN报文后进入了&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态。这个状态下，仍然可以向对方发送未发送完毕的数据，数据发送完毕后也要向对端发送FIN报文释放连接，忘了发FIN包(调用close())会导致bug。也就是说，TCP是全双工传输，两端都必须发送FIN包，才能完全断开连接。&lt;/p&gt;
&lt;h3 id=&#34;time_wait状态&#34;&gt;TIME_WAIT状态&lt;/h3&gt;
&lt;p&gt;主动发送FIN包的一端，在收到对端的FIN报文后进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，这个状态一般要保持一个较长的时间2MSL。原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保最后一个应答FIN的报文ACK能够到达。因为如果对端没有收到ACK应答，则会重发FIN包。&lt;/li&gt;
&lt;li&gt;让当前连接在网络中可能的所有报文达到生存期上限后消失，使得下一个新的连接不会收到旧的连接的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三次握手内核实现原理示意图&#34;&gt;三次握手内核实现原理示意图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1586239797212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;队列长度配置&#34;&gt;队列长度配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SYN队列长度配置: &lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态连接的最大个数&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;ACCEPT队列长度：
&lt;ul&gt;
&lt;li&gt;系统全局： &lt;code&gt;net.core.somaxconn = 262144 #系统全局ACCPET队列最大长度的配置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用层: socket API listen传参控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syn攻击&#34;&gt;SYN攻击&lt;/h3&gt;
&lt;p&gt;攻击者迅速伪造不同IP地址的SYN报文，快速占满SYN队列，使得正常的SYN包无法加入队列。&lt;/p&gt;
&lt;h4 id=&#34;应对syn攻击的参数&#34;&gt;应对SYN攻击的参数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;net.core.netdev_max_backlog = 262144 #接收自网卡、但是未被内核协议栈处理的IP报文队列长度&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_abort_on_overflow = 1 #设置为1时表示: 队列满则响应RST包，丢弃连接&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;tcp_syncookies&#34;&gt;tcp_syncookies&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1 #启用tcp cookie, 使得SYN队列满仍能建立连接&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;控制tcp三次握手的参数&#34;&gt;控制TCP三次握手的参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SYN_SENT状态&lt;br&gt;
&lt;code&gt;net.ip4.tcp_syn_retries = 6 #主动建立连接，发送SYN的重试次数&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.ip_local_port_range = 32768 60999 #建立连接时的本地端口可选范围&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN_RCVD状态&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_synack_retries = 3 #被动建立连接时，发送SYN/ACK的重试次数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tfotcp-fast-open&#34;&gt;TFO(TCP Fast Open)&lt;/h2&gt;
&lt;p&gt;配置: &lt;code&gt;net.ipv4.tcp_fastopen&lt;/code&gt;。（&lt;strong&gt;注意&lt;/strong&gt;：内核版本要求在Linux 3.7以上）&lt;br&gt;
可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0: 关闭(默认)&lt;/li&gt;
&lt;li&gt;1: 作为客户端时可以使用TFO&lt;/li&gt;
&lt;li&gt;2: 作为服务端时可以使用TFO&lt;/li&gt;
&lt;li&gt;3: 都可以使用TFO，无论是作为服务端还是客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示意图-2&#34;&gt;示意图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1586580242109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">TCP协议基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/dns/"" data-c="
          &lt;p&gt;web冲浪，DNS是必不可少的协议。本文主要介绍DNS的工作机制，对DNS的某些信息(比如历史)不做介绍。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;dns是什么&#34;&gt;DNS是什么？&lt;/h2&gt;
&lt;p&gt;DNS是互联网世界的地址薄，类似于电话本，主要提供将域名映射到IP地址的功能。&lt;/p&gt;
&lt;h2 id=&#34;dns的树状层次结构&#34;&gt;DNS的树状层次结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一层: 根DNS服务器，负责返回顶级DNS(TLD)服务器的IP地址。目前全世界有13台服务节点。&lt;/li&gt;
&lt;li&gt;第二层: TLD服务器，负责返回权威DNS服务器的IP地址。&lt;/li&gt;
&lt;li&gt;第三层: 权威DNS服务器，负责返回相应主机或域名的IP地址。&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1586003718190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns的解析流程&#34;&gt;DNS的解析流程&lt;/h2&gt;
&lt;p&gt;在未命中缓存的情况下，DNS完成域名的解析需要经过如下步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户在浏览器中输入“example.com”, 查询由本地DNS服务(&lt;strong&gt;递归服务器&lt;/strong&gt;)解析器接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;查询&lt;strong&gt;根DNS域名服务器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根DNS服务器&lt;/strong&gt;使用&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;(例如.com或.net)的地址响应给&lt;strong&gt;递归服务器&lt;/strong&gt;。如：“example.com”，则返回.com TLD的IP地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向.com&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;发出请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;响应&lt;strong&gt;权威DNS服务器&lt;/strong&gt;的IP地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向&lt;strong&gt;权威DNS服务器&lt;/strong&gt;翻出请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权威DNS服务器&lt;/strong&gt;响应example.com的IP地址给&lt;strong&gt;递归服务器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归DNS服务器&lt;/strong&gt;将example.com的IP地址响应给浏览器。（&lt;em&gt;DNS解析完成&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;浏览器向example.com的IP地址发出HTTP请求...&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1586005095657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dns缓存&#34;&gt;DNS缓存&lt;/h2&gt;
&lt;p&gt;在未命中缓存的情形下，DNS解析的流程是复杂且耗时的。DNS数据可以被缓存在多个位置，每个位置可以在一段时间内(记录生存时间TTL)缓存DNS数据记录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器DNS缓存&lt;/li&gt;
&lt;li&gt;操作系统级DNS缓存&lt;/li&gt;
&lt;li&gt;递归DNS服务器级别缓存。&lt;em&gt;如果域名缓存未命中，但是命中了该域名的NS记录，则跳过请求根和TLD服务器；如果没有NS记录，但是命中了TLD的记录，则跳过请求根服务器；如果没有命中TLD的记录，则要完整走完迭代访问根DNS服务器到权威服务器这一全流程了。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns记录类型&#34;&gt;DNS记录类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常见类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;A记录: 域名映射的IPv4地址。&lt;/li&gt;
&lt;li&gt;CNAME记录：域名别名映射，将域名指向另外一个域名。&lt;/li&gt;
&lt;li&gt;NS记录：域名映射的权威服务器记录。&lt;/li&gt;
&lt;li&gt;AAAA记录：域名映射的IPv6地址。&lt;/li&gt;
&lt;li&gt;MX记录：域名映射的邮箱服务器地址。&lt;/li&gt;
&lt;li&gt;TXT记录：允许管理员在记录中存储文本。&lt;/li&gt;
&lt;li&gt;SOA记录：存储有关域的管理员信息。&lt;/li&gt;
&lt;li&gt;SRV记录：指定特定服务的端口。&lt;/li&gt;
&lt;li&gt;PTR记录：在反向查询中提供域名。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dns协议报文格式&#34;&gt;DNS协议报文格式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://jocent.me/2017/06/18/dns-protocol-principle.html&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;胶水记录glue-record&#34;&gt;胶水记录(Glue record)&lt;/h2&gt;
&lt;p&gt;当给&lt;strong&gt;域名A&lt;/strong&gt;配置NS记录时，如果NS记录为&lt;strong&gt;域名A&lt;/strong&gt;的子域名，则必须配置NS记录的A记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常需要在域名提供商哪里申请两个域名，而不建议采用胶水记录方式。&lt;/li&gt;
&lt;li&gt;参考链接：https://www.jianshu.com/p/7d69ec2976c7&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns优秀的go开源项目&#34;&gt;DNS优秀的go开源项目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/miekg/dns&lt;/li&gt;
&lt;li&gt;https://github.com/EmilHernvall/dnsguide&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;demo&lt;/strong&gt;:  https://github.com/xly0713/xdns 😜&lt;/li&gt;
&lt;/ul&gt;
">DNS协议基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;本站主要用来记录一些技术，帮助自己整理零碎的知识，希望对他人有所帮助。欢迎&lt;a href=&#34;/atom.xml&#34;&gt;RSS&lt;/a&gt;订阅本站。&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;博主是一名后台研发攻城狮，关注云计算相关领域，目前专注于CDN技术和直播技术。&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;邮件: xly880713@gmail.com&lt;/li&gt;
&lt;/ul&gt;
">关于</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;go语言编码使用functional options是常见用法，但是在hot path处要慎用。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;p&gt;之前用go写过一个IO密集型的程序，pprof性能测试发现使用functional options竟然占用较多的CPU时间。经测试，直接对结构体的字段赋值，速度是使用functional options的一百倍。测试代码如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n        &amp;quot;fmt&amp;quot;\n        &amp;quot;time&amp;quot;\n)\n\ntype user struct {\n        Age int\n}\n\ntype userOpt func(*user)\n\nfunc WithUserAge(age int) userOpt {\n        return func(u *user) {\n                u.Age = age\n        }\n}\n\nfunc main() {\n        u := &amp;amp;user{}\n        now := time.Now()\n\n        //f := WithUserAge\n        for i := 0; i &amp;lt; 100000000; i++ {\n                u.Age = i\n                //f(i)(u)   //实测性能是上一行(直接赋值)的百分之一\n        }\n\n        diff := time.Since(now)\n        fmt.Printf(&amp;quot;diff: %v\\n&amp;quot;, diff)\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;functional-options-in-go&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;go语言编码使用functional options是常见用法，但是在hot path处要慎用。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Functional options in Go&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;golang&#34;,&#34;slug&#34;:&#34;golang&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/golang/&#34;}],&#34;date&#34;:&#34;2020-06-20 13:34:30&#34;,&#34;dateFormat&#34;:&#34;2020-06-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/functional-options-in-go/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:46000,&#34;words&#34;:168,&#34;minutes&#34;:1},&#34;description&#34;:&#34;go语言编码使用functional options是常见用法，但是在hot path处要慎用。\n\n之前用go写过一个IO密集型的程序，pprof性能测试发现使用functional options竟然占用较多的CPU时间。经测试，直接对结...&#34;,&#34;toc&#34;:&#34;&#34;},{&#34;content&#34;:&#34;&lt;p&gt;defer是go关键字，一般用来清理释放资源，在了解go-kit微服务时，发现了有意思的用法&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;一般用法-清理释放资源\&#34;&gt;一般用法--清理释放资源&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;fd, err := os.Open(filename)\nif err != nil {\n    return\n}\ndefer fd.Close()\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;使用defer可以避免忘记释放资源。曾经使用&lt;code&gt;lsof -p $pid | grep deleted&lt;/code&gt;帮一个C++老手找出过程序资源句柄忘记Close的问题，go的defer可以有效避免此类问题。&lt;/p&gt;\n&lt;h2 id=\&#34;defer的妙用-中间件middleware\&#34;&gt;defer的妙用--中间件MiddleWare&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;package main\n\nimport (\n        &amp;quot;fmt&amp;quot;\n        &amp;quot;io&amp;quot;\n        &amp;quot;os&amp;quot;\n        &amp;quot;strings&amp;quot;\n        &amp;quot;time&amp;quot;\n)\n\nfunc main() {\n    var svc stringService\n    svc = &amp;amp;stringSvc{}\n    svc = setupLogMiddle(os.Stdout)(svc)\n    ret := svc.ToUpper(&amp;quot;hello&amp;quot;)\n    fmt.Println(ret)\n}\n\n// 定义接口\ntype stringService interface {\n    ToUpper(string) string\n}\n\ntype stringSvc struct{}\n\n// 真正的业务service\nfunc (ss *stringSvc) ToUpper(input string) (ret string) {\n    return strings.ToUpper(input)\n}\n\n// 中间件type\ntype middle func(stringService) stringService\n\ntype log struct {\n    writer io.Writer\n    stringService\n}\n\n// 安装中间件\nfunc setupLogMiddle(writer io.Writer) middle {\n    return func(ss stringService) stringService {\n        return &amp;amp;log{writer, ss}\n    }\n}\n\nfunc (l *log) ToUpper(input string) (ret string) {\n    // 此处defer执行log中间件\n    defer func(begin time.Time) {\n        fmt.Fprintf(l.writer, &amp;quot;method: %s, input: %s, output: %s, took: %v\\n&amp;quot;,\n            &amp;quot;ToUpper&amp;quot;, input, ret, time.Since(begin))\n    }(time.Now())\n\n    ret = l.stringService.ToUpper(input)\n    return ret\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;p&gt;以上是从&lt;a href=\&#34;https://github.com/go-kit/kit\&#34;&gt;go-kit&lt;/a&gt;看到的，挺有意思，记录下来。&lt;/p&gt;\n&#34;,&#34;fileName&#34;:&#34;defer-de-miao-yong&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;defer是go关键字，一般用来清理释放资源，在了解go-kit微服务时，发现了有意思的用法&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;defer的妙用&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;golang&#34;,&#34;slug&#34;:&#34;golang&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/golang/&#34;}],&#34;date&#34;:&#34;2020-06-20 12:57:11&#34;,&#34;dateFormat&#34;:&#34;2020-06-20&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/defer-de-miao-yong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:87000,&#34;words&#34;:295,&#34;minutes&#34;:2},&#34;description&#34;:&#34;defer是go关键字，一般用来清理释放资源，在了解go-kit微服务时，发现了有意思的用法\n\n一般用法--清理释放资源\nfd, err := os.Open(filename)\nif err != nil {\n    return\n}\nd...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%80%E8%88%AC%E7%94%A8%E6%B3%95-%E6%B8%85%E7%90%86%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90\&#34;&gt;一般用法--清理释放资源&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#defer%E7%9A%84%E5%A6%99%E7%94%A8-%E4%B8%AD%E9%97%B4%E4%BB%B6middleware\&#34;&gt;defer的妙用--中间件MiddleWare&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;RTMP是直播业务使用的重要协议，整理以备查。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h1 id=\&#34;简介\&#34;&gt;简介&lt;/h1&gt;\n&lt;h1 id=\&#34;rtmp-handshake\&#34;&gt;RTMP HandShake&lt;/h1&gt;\n&lt;p&gt;RTMP握手成功后，保证了两端支持RTMP协议，然后才能进行RTMP协议层面的消息交互。&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592733025853.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h1 id=\&#34;rtmp-chunk\&#34;&gt;RTMP Chunk&lt;/h1&gt;\n&lt;h2 id=\&#34;chunk-format\&#34;&gt;Chunk Format&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1592057208742.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;basic-header\&#34;&gt;Basic Header&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Basic Header的总长度可能是: 1, 2 或 3字节， 实际是哪一种取决于字段CSID的范围&lt;/li&gt;\n&lt;li&gt;包含2个字段:\n&lt;ul&gt;\n&lt;li&gt;Chunk Type: Format, 简写: &lt;strong&gt;fmt&lt;/strong&gt;。长度固定为: 2bit(比特位)&lt;/li&gt;\n&lt;li&gt;Chunk stream ID: 简称&lt;strong&gt;CSID&lt;/strong&gt;。Basic Header的总长度(1, 2或3字节)减去fmt使用的2bit即是CSID可能的长度，长度可能为: 6(8-2), 14(16-2)或22(24-2)bit&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;协议规定: 支持用户自定义[3, 65599]之间的CSID，而0, 1, 2由协议保留用作表示特殊信息\n&lt;ul&gt;\n&lt;li&gt;0: 表示Basic Header总共要占用2个字节, CSID在[64, 319]之间&lt;/li&gt;\n&lt;li&gt;1: 表示Basic Header总共要占用3个字节, CSID在[64, 65599]之间&lt;/li&gt;\n&lt;li&gt;2: 表示该Chunk是控制信息和一些命令信息&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;当basic-header的长度为1字节时\&#34;&gt;当Basic Header的长度为1字节时&lt;/h4&gt;\n&lt;p&gt;如图所示: CSID长度为6bit,  除去保留的CSID，自定义范围为[3, 63]&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592104838393.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;当basic-header的长度为2字节时\&#34;&gt;当Basic Header的长度为2字节时&lt;/h4&gt;\n&lt;p&gt;如图所示: 此时协议要求将与&lt;strong&gt;fmt&lt;/strong&gt;所在字节的后6bit位都设置为0，剩下的1个字节表示&lt;strong&gt;CSID - 64&lt;/strong&gt;。8bit位可表示[0, 255]共256个数，即&lt;strong&gt;CSID&lt;/strong&gt;的范围为[64, 319]。&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592104748432.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;当basic-header的长度为3字节时\&#34;&gt;当Basic Header的长度为3字节时&lt;/h4&gt;\n&lt;p&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1592105487440.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;br&gt;\n如果所示: 此时协议要求将与&lt;strong&gt;fmt&lt;/strong&gt;所在字节的后6比特位设置为1(即000001), 剩下的2个字节(小端存储)表示&lt;strong&gt;CSID-64&lt;/strong&gt;。16bit位可表示[0, 65535], 即&lt;strong&gt;CSID&lt;/strong&gt;的范围为[64, 65599]。&lt;br&gt;\n另外，可以观察到Basic Header的长度为2字节时的&lt;strong&gt;CSID&lt;/strong&gt;的范围[64, 319]是[64, 65599]的子集。&lt;/p&gt;\n&lt;h4 id=\&#34;wireshark抓包\&#34;&gt;wireshark抓包&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;CSID&lt;/strong&gt;值为2时（协议保留值）&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592106094882.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;CSID&lt;/strong&gt;值在区间[3, 64]时 (Basic Header的长度为1字节)&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592106424214.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;伪代码\&#34;&gt;伪代码&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;first_byte = read_1byte()\nb_27 = first_byte &amp;amp; 0x3f\nif b_27 == 0:\n    basic_header_len = 2 (bytes)\nelse if b_27 == 1:\n    basic_header_len = 3 (bytes)\nelse if b_27 &amp;gt; 1:\n    basis_header_len = 1 (bytes)\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;message-header\&#34;&gt;Message Header&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;Message Header的总长度可能是: 11, 7, 3 或 0 字节，实际是哪一种取决于Basic Header的&lt;strong&gt;fmt&lt;/strong&gt;字段的值(2bit位，共4种可能)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;当fmt-0时-总长度为11字节\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 0时, 总长度为11字节&lt;/h4&gt;\n&lt;p&gt;包含如下4个字段：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;timestamp: 时间戳，占用3个字节。\n&lt;ul&gt;\n&lt;li&gt;3个字节最多表示到16777215 = 2^24 - 1, 当它的值超过这个最大值时，这3个字节全部需置为1。这样实际的时间戳会转存到Extended Timestamp字段中，接收端在判断timestamp字段这3个字节全部为1时，需要去解析Extended Timestamp字段获取时间戳。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;message length: 消息数据的长度，占用3个字节。\n&lt;ul&gt;\n&lt;li&gt;表示实际发送的数据(如: 音频帧、视频帧)等数据的长度，单位是: 字节&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;message type id: 消息类型的ID，占用1个字节。\n&lt;ul&gt;\n&lt;li&gt;表示实际发送的数据的类型，比如：8代表音频数据，9代表视频数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;message stream id: 消息流的ID，占用4个字节。\n&lt;ul&gt;\n&lt;li&gt;表示该chunk所在的流的ID，和Basic Header的&lt;strong&gt;CSID&lt;/strong&gt;一样，采用小端存储方式&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;当fmt-1时总长度为7字节\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 1时，总长度为7字节&lt;/h4&gt;\n&lt;p&gt;与&lt;strong&gt;fmt&lt;/strong&gt; = 0相比，省掉了message stream id字段(4个字节)。包含3个字段：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;timestamp delta: 占用3个字节。\n&lt;ul&gt;\n&lt;li&gt;与&lt;strong&gt;fmt&lt;/strong&gt; = 0时的timestamp含义不同，存储的是和上一个chunk的时间差。同样，超过最大值后，需用到Extended Timestamp字段&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;message length: 消息数据的长度，占用3个字节。&lt;/li&gt;\n&lt;li&gt;message type id: 消息类型的ID，占用1个字节。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;当fmt-2时总长度为3字节\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 2时，总长度为3字节&lt;/h4&gt;\n&lt;p&gt;与&lt;strong&gt;fmt&lt;/strong&gt; = 1相比，省掉了message length字段(3字节)和message type id(1字节)。仅包含1个字段:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;timestamp delta: 占用3个字节。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;当fmt-3时总长度为0字节\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 3时，总长度为0字节&lt;/h4&gt;\n&lt;p&gt;0字节。表示这个chunk的Message Header和前一个Chunk完全相同。&lt;/p&gt;\n&lt;h3 id=\&#34;extended-timestamp\&#34;&gt;Extended Timestamp&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;含义：扩展时间戳&lt;/li&gt;\n&lt;li&gt;协议规定：\n&lt;ul&gt;\n&lt;li&gt;只有当Message Header中的timestamp (delta)字段设置为全1 (0x00ffffff)时，本字段才能存在&lt;/li&gt;\n&lt;li&gt;如果Message Header中的timestamp (delta)字段的值小于0x00ffffff, 则本字段一定不能出现&lt;/li&gt;\n&lt;li&gt;如果Message Header中的timestamp (delta)字段不存在(&lt;strong&gt;fmt&lt;/strong&gt; = 3时)， 则本字段也一定不能出现&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;chunk-data\&#34;&gt;Chunk Data&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 用户层面上真正想要发送的与协议无关的数据&lt;/li&gt;\n&lt;li&gt;长度：在(0, ChunkSize)之间，由Message Header的message length(Body size)字段指定大小&lt;/li&gt;\n&lt;li&gt;抓包示例：&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592232838104.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;协议控制消息protocol-control-message\&#34;&gt;协议控制消息(Protocol Control Message)&lt;/h2&gt;\n&lt;p&gt;chunk流使用一些特殊的值表示协议的控制消息，特殊值协议规定:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Basic Header字段&lt;strong&gt;CSID&lt;/strong&gt;必须为2&lt;/li&gt;\n&lt;li&gt;Message Header的字段&lt;strong&gt;message stream id&lt;/strong&gt;必须为0（0表示控制信息）&lt;/li&gt;\n&lt;li&gt;Message Header的字段&lt;strong&gt;message type id&lt;/strong&gt;可能的值: 1～6&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;set-chunk-size\&#34;&gt;Set Chunk Size&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 1&lt;/li&gt;\n&lt;li&gt;含义：设置Chunk Data的最大长度，Message Header的字段&lt;strong&gt;message length&lt;/strong&gt;不能超过该值。如果要发送的Message超过设置的Chunk Size, 则必须拆分成Chunk发送。&lt;/li&gt;\n&lt;li&gt;Chunk Data: Chunk Size值&lt;/li&gt;\n&lt;li&gt;wireshark抓包&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592625812774.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;abort-message\&#34;&gt;Abort Message&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 2&lt;/li&gt;\n&lt;li&gt;含义: 当一个Message被拆分为多个Chunk，接收端只接收到了部分Chunk时:\n&lt;ul&gt;\n&lt;li&gt;如果发送该控制消息给发送端，可以告知发送端不再传输该Message的Chunk&lt;/li&gt;\n&lt;li&gt;而接收端如果收到该控制消息，则需要丢弃这些不完整的Chunk&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Chunk Data: &lt;strong&gt;CSID&lt;/strong&gt;, 表示丢弃该CSID的所有已接收到的Chunk&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;acknowledgement\&#34;&gt;Acknowledgement&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 3&lt;/li&gt;\n&lt;li&gt;含义: 当收到对端的消息大小等于窗口大小时，接收端需发送该控制消息给对端，告诉对端可以继续发送数据\n&lt;ul&gt;\n&lt;li&gt;窗口大小是在没有接收端对端的ACK确认消息之前能发送的字节数的最大值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Chunk Data: 序列号Sequence Number, 表明到当前时间为止已经接收到的字节数（4byte大小）&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;user-control-message\&#34;&gt;User Control Message&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 4&lt;/li&gt;\n&lt;li&gt;含义：用户控制消息，客户端或服务端发送本消息通知对方用户的控制消息&lt;/li&gt;\n&lt;li&gt;Chunk Data: 本消息承载事件类型和事件数据\n&lt;ul&gt;\n&lt;li&gt;头两个字节用于标识事件类型 （2byte）&lt;/li&gt;\n&lt;li&gt;事件类型之后是事件数据, 长度是可变的&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;window-acknowledgement-size\&#34;&gt;Window Acknowledgement Size&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 5&lt;/li&gt;\n&lt;li&gt;含义: 发送端在收到接收端的两个Acknowledgement消息间最多可以发送的字节数&lt;/li&gt;\n&lt;li&gt;wireshark抓包&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592627273256.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;set-peer-bandwidth\&#34;&gt;Set Peer Bandwidth&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 6&lt;/li&gt;\n&lt;li&gt;含义: 发送本消息更新对端的输出带宽&lt;/li&gt;\n&lt;li&gt;Chunk Data:\n&lt;ul&gt;\n&lt;li&gt;aws: Acknowledgement Windows Size (4byte)&lt;/li&gt;\n&lt;li&gt;Limit type: 0-硬限制  1-软限制  2-动态限制&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;wireshark抓包&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592627673621.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;数据消息\&#34;&gt;数据消息&lt;/h2&gt;\n&lt;h3 id=\&#34;audio-message\&#34;&gt;Audio Message&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 8&lt;/li&gt;\n&lt;li&gt;含义: 音频数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;video-message\&#34;&gt;Video Message&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 9&lt;/li&gt;\n&lt;li&gt;含义: 视频数据&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;metadata-message\&#34;&gt;Metadata Message&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;message type id&lt;/strong&gt; = 18&lt;/li&gt;\n&lt;li&gt;含义: 音视频编码、视频宽高等元数据信息&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;命令消息command-message\&#34;&gt;命令消息(Command Message)&lt;/h2&gt;\n&lt;p&gt;协议规定&lt;strong&gt;message type id&lt;/strong&gt;= 17 或 20 表示命令消息。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;命令消息由3部分组成：命令的名字(如: connect)、TransactionID表示命令的标识、Object表示相关参数。使用AMF编码。&lt;/li&gt;\n&lt;li&gt;接收端收到命令消息后，返回如下3种消息之一:\n&lt;ul&gt;\n&lt;li&gt;&lt;strong&gt;_result&lt;/strong&gt;消息: 表示接受命令，对端可以继续往下执行流程&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;_error&lt;/strong&gt;消息: 表示拒绝该命令要执行的操作&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;method name&lt;/strong&gt;消息: 方法名，例如: verifyClient或contactExternalServer。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;netconnection-commands连接层的命令\&#34;&gt;NetConnection Commands(连接层的命令)&lt;/h3&gt;\n&lt;h4 id=\&#34;connect\&#34;&gt;connect&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 用于客户端向服务器发起连接请求&lt;/li&gt;\n&lt;li&gt;Chunk Data字段:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 如: &amp;quot;connect&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为1&lt;/li&gt;\n&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;\n&lt;li&gt;Optional User Arguments: 自定义的额外参数(Object)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;wireshark抓包&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592725806865.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;call\&#34;&gt;Call&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 用于在对端执行某函数，即RPC&lt;/li&gt;\n&lt;li&gt;Chunk Data字段:\n&lt;ul&gt;\n&lt;li&gt;Procedure Name: 要调用的远程方法(String)&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number)。如果需对端反馈响应，则该值设置为非0，否则设置为0&lt;/li&gt;\n&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;\n&lt;li&gt;Optional User Arguments: 自定义的额外参数(Object)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;如果发送Call命令端的Transaction ID非0，则接收命令端需作出响应，响应的字段如下:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String)&lt;/li&gt;\n&lt;li&gt;Transaction ID: 接收到的消息的Transaction ID&lt;/li&gt;\n&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;\n&lt;li&gt;Response: 命令已成功执行(Object)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;createstream\&#34;&gt;createStream&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 创建传递具体消息的stream通道，从而可以在这路流中传递具体信息&lt;/li&gt;\n&lt;li&gt;Chunk Data字段:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 如: &amp;quot;createStream&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number)&lt;/li&gt;\n&lt;li&gt;Command Object: 键值对集合表示的命令参数(Object)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;wireshark抓包&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592728480012.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;netstream-commands流连接上的命令\&#34;&gt;NetStream Commands(流连接上的命令)&lt;/h3&gt;\n&lt;p&gt;NetStream建立在NetConnection之上。一个TCP连接上只能创建一个NetConnection，但一个NetConnection之上可以创建多个NetStream来建立不同的流通道传输数据。&lt;/p&gt;\n&lt;p&gt;服务端收到NetStream Commands后，会通过onStatus的命令来响应客户端，描述当前NetStream状态。&lt;br&gt;\nonStatus命令的字段结构如下:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;onStatus&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;InfoObject: 状态信息(Object)，至少包含3个属性\n&lt;ul&gt;\n&lt;li&gt;level: String类型，可能值: &amp;quot;warning&amp;quot;、&amp;quot;status&amp;quot;、&amp;quot;error&amp;quot;&lt;/li&gt;\n&lt;li&gt;code: String类型，代表具体的状态, 比如: &amp;quot;NetStream.Play.Start&amp;quot;表示开始播流&lt;/li&gt;\n&lt;li&gt;description:  String类型，状态的文字描述&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;wireshark抓包示例&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592729790350.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;play\&#34;&gt;play&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 客户端请求服务器接收数据(如果传输的信息时视频的话，则请求开始播流)&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;play&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;Stream Name: 流名字(String)&lt;/li&gt;\n&lt;li&gt;Start: 开始位置(Number, 可选参数), 表示从何时开始播流，以秒为单位\n&lt;ul&gt;\n&lt;li&gt;-2: 表示播放直播流，如果直播流不存在，则播放录播文件，如果录播文件也没有，则等待流开播 (默认值)&lt;/li&gt;\n&lt;li&gt;-1: 表示只播放直播流，忽略录播文件&lt;/li&gt;\n&lt;li&gt;\n&lt;blockquote&gt;\n&lt;p&gt;=0: 表示从该流的该时间点开始播放&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;Duration：时长(Number, 可选参数)，以秒为单位\n&lt;ul&gt;\n&lt;li&gt;-1: 表示直播或录播停止后才能回退播放（默认值）&lt;/li&gt;\n&lt;li&gt;0: 表示从当前帧开始播放&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;reset: Boolean类型，可选参数\n&lt;ul&gt;\n&lt;li&gt;true: 表示清除之前的流，重新开始一路播放&lt;/li&gt;\n&lt;li&gt;false: 表示保留原来的流，向本地的播放列表中再添加一条播放流&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;play2\&#34;&gt;play2&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 和play不同的是, 该命令可以将当前正在播放的流切换到同样数据但不同码率的流上，服务器会维护多种码率的文件来供客户端使用play2命令来切换&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;play2&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为2&lt;/li&gt;\n&lt;li&gt;Start Time:&lt;/li&gt;\n&lt;li&gt;oldStreamName:&lt;/li&gt;\n&lt;li&gt;Stream Name:&lt;/li&gt;\n&lt;li&gt;Duration:&lt;/li&gt;\n&lt;li&gt;Transition:&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;deletestream\&#34;&gt;deleteStream&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 当NetStream对象销毁的时候发送删除流命令&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下：\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;deleteStream&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;Stream ID: Number类型，要销毁的流的ID&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;服务端不返回任何响应&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;receiveaudio\&#34;&gt;receiveAudio&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 告知服务端是否要发送音频&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下：\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;receiveAudio&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;Bool Flag: Boolean类型, 表示是否接收音频流&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;服务端不返回任何响应&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;receivevideo\&#34;&gt;receiveVideo&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 告知服务端是否要发送视频&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下：\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;receiveAudio&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;Bool Flag: Boolean类型, 表示是否接收视频流&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;服务端不返回任何响应&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;publish\&#34;&gt;publish&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 客户端向服务器发起请求推流到服务器&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下：\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;publish&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;Publishing Name: 流名字(String)&lt;/li&gt;\n&lt;li&gt;Publishing Type：推流类型(String)\n&lt;ul&gt;\n&lt;li&gt;&amp;quot;live&amp;quot;: 表示推流文件无需在服务器端存储&lt;/li&gt;\n&lt;li&gt;&amp;quot;record&amp;quot;: 将推流数据保存在服务器端覆盖写&lt;/li&gt;\n&lt;li&gt;&amp;quot;append&amp;quot;: 将推流数据保存在服务器端，追加写&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;wireshark抓包示例&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1592732391519.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;seek\&#34;&gt;seek&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 定位到视频或音频的某个位置，以毫秒为单位&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;seek&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;milliSeconds: Number类型，表示定位到该文件的xx毫秒处&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h4 id=\&#34;pause\&#34;&gt;pause&lt;/h4&gt;\n&lt;ul&gt;\n&lt;li&gt;含义: 客户端告知服务端停止或恢复播放&lt;/li&gt;\n&lt;li&gt;Chunk Data字段如下:\n&lt;ul&gt;\n&lt;li&gt;Command Name: 命令名字(String), 为&amp;quot;pause&amp;quot;&lt;/li&gt;\n&lt;li&gt;Transaction ID: 事务ID(Number), 固定值为0&lt;/li&gt;\n&lt;li&gt;Command Object: Null类型&lt;/li&gt;\n&lt;li&gt;Pause/Unpause Flag: Boolean类型。true表示暂停，false表示恢复&lt;/li&gt;\n&lt;li&gt;milliSeconds: Number类型，表示暂停或者恢复的时间，以毫秒为单位&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;rtmp-xie-yi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;RTMP是直播业务使用的重要协议，整理以备查。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;RTMP协议整理&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;直播&#34;,&#34;slug&#34;:&#34;zhi-bo&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/zhi-bo/&#34;},{&#34;name&#34;:&#34;网络协议&#34;,&#34;slug&#34;:&#34;Q1k2X6rnU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/Q1k2X6rnU/&#34;}],&#34;date&#34;:&#34;2020-06-11 23:01:05&#34;,&#34;dateFormat&#34;:&#34;2020-06-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/rtmp-xie-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;13 min read&#34;,&#34;time&#34;:752000,&#34;words&#34;:3139,&#34;minutes&#34;:13},&#34;description&#34;:&#34;RTMP是直播业务使用的重要协议，整理以备查。\n\n简介\nRTMP HandShake\nRTMP握手成功后，保证了两端支持RTMP协议，然后才能进行RTMP协议层面的消息交互。\n\nRTMP Chunk\nChunk Format\n\nBasic ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%AE%80%E4%BB%8B\&#34;&gt;简介&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rtmp-handshake\&#34;&gt;RTMP HandShake&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#rtmp-chunk\&#34;&gt;RTMP Chunk&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#chunk-format\&#34;&gt;Chunk Format&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#basic-header\&#34;&gt;Basic Header&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93basic-header%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA1%E5%AD%97%E8%8A%82%E6%97%B6\&#34;&gt;当Basic Header的长度为1字节时&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93basic-header%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA2%E5%AD%97%E8%8A%82%E6%97%B6\&#34;&gt;当Basic Header的长度为2字节时&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93basic-header%E7%9A%84%E9%95%BF%E5%BA%A6%E4%B8%BA3%E5%AD%97%E8%8A%82%E6%97%B6\&#34;&gt;当Basic Header的长度为3字节时&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#wireshark%E6%8A%93%E5%8C%85\&#34;&gt;wireshark抓包&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BC%AA%E4%BB%A3%E7%A0%81\&#34;&gt;伪代码&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#message-header\&#34;&gt;Message Header&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93fmt-0%E6%97%B6-%E6%80%BB%E9%95%BF%E5%BA%A6%E4%B8%BA11%E5%AD%97%E8%8A%82\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 0时, 总长度为11字节&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93fmt-1%E6%97%B6%E6%80%BB%E9%95%BF%E5%BA%A6%E4%B8%BA7%E5%AD%97%E8%8A%82\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 1时，总长度为7字节&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93fmt-2%E6%97%B6%E6%80%BB%E9%95%BF%E5%BA%A6%E4%B8%BA3%E5%AD%97%E8%8A%82\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 2时，总长度为3字节&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BD%93fmt-3%E6%97%B6%E6%80%BB%E9%95%BF%E5%BA%A6%E4%B8%BA0%E5%AD%97%E8%8A%82\&#34;&gt;当&lt;strong&gt;fmt&lt;/strong&gt; = 3时，总长度为0字节&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#extended-timestamp\&#34;&gt;Extended Timestamp&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#chunk-data\&#34;&gt;Chunk Data&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%8F%E8%AE%AE%E6%8E%A7%E5%88%B6%E6%B6%88%E6%81%AFprotocol-control-message\&#34;&gt;协议控制消息(Protocol Control Message)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#set-chunk-size\&#34;&gt;Set Chunk Size&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#abort-message\&#34;&gt;Abort Message&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#acknowledgement\&#34;&gt;Acknowledgement&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#user-control-message\&#34;&gt;User Control Message&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#window-acknowledgement-size\&#34;&gt;Window Acknowledgement Size&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#set-peer-bandwidth\&#34;&gt;Set Peer Bandwidth&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E6%B6%88%E6%81%AF\&#34;&gt;数据消息&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#audio-message\&#34;&gt;Audio Message&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#video-message\&#34;&gt;Video Message&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#metadata-message\&#34;&gt;Metadata Message&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%91%BD%E4%BB%A4%E6%B6%88%E6%81%AFcommand-message\&#34;&gt;命令消息(Command Message)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#netconnection-commands%E8%BF%9E%E6%8E%A5%E5%B1%82%E7%9A%84%E5%91%BD%E4%BB%A4\&#34;&gt;NetConnection Commands(连接层的命令)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#connect\&#34;&gt;connect&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#call\&#34;&gt;Call&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#createstream\&#34;&gt;createStream&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#netstream-commands%E6%B5%81%E8%BF%9E%E6%8E%A5%E4%B8%8A%E7%9A%84%E5%91%BD%E4%BB%A4\&#34;&gt;NetStream Commands(流连接上的命令)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#play\&#34;&gt;play&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#play2\&#34;&gt;play2&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#deletestream\&#34;&gt;deleteStream&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#receiveaudio\&#34;&gt;receiveAudio&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#receivevideo\&#34;&gt;receiveVideo&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#publish\&#34;&gt;publish&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#seek\&#34;&gt;seek&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#pause\&#34;&gt;pause&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Linux系统下，Nginx会默认使用epoll作为事件驱动机制，使用epoll是Nginx性能高的一个重要原因。&lt;br&gt;\n本文对epoll工作机制稍作整理。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;事件驱动\&#34;&gt;事件驱动&lt;/h2&gt;\n&lt;p&gt;事件驱动又称作IO多路复用，epoll是Linux内核实现一种IO多路复用机制&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;IO： 在Linux系统下，一切皆文件。文件可读/可写即称作IO，比如：普通文件、socket套接字、进程之间通信的管道pipe，都是可以IO的对象。Linux系统统一用文件描述符fd表示。&lt;/li&gt;\n&lt;li&gt;事件：\n&lt;ul&gt;\n&lt;li&gt;可读事件：当fd关联的内核读缓冲区可读时，则触发可读事件 （可写：内核缓冲区非空）&lt;/li&gt;\n&lt;li&gt;可写事件：当fd关联的内科写缓冲区可写时，则触发可写事件   (可读：内核缓冲区不满)&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;事件通知方式\n&lt;ul&gt;\n&lt;li&gt;主动通知：仅当有fd有事件发生时，内核主动通知上层应用有事件发生的fd集合&lt;/li&gt;\n&lt;li&gt;被动通知：上层应用向内核轮询检查fd集合中的fd是否有事件发生&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;epoll-api介绍\&#34;&gt;epoll API介绍&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1589288969778.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;epoll_create\&#34;&gt;epoll_create&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;原型：int epoll_create(int size)\n&lt;ul&gt;\n&lt;li&gt;功能：创建一个epoll实例，内核会返回一个表示epoll实例的fd&lt;/li&gt;\n&lt;li&gt;入参\n&lt;ul&gt;\n&lt;li&gt;size: 原本表示所要监视fd的最多个数。现在Linux版中无意义，只要传值大于0的整数即可&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;返回值: epoll实例的fd&lt;/li&gt;\n&lt;li&gt;说明：调用该API，内核会产生一个epoll实例数据结构，然后返回一个文件描述符&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;epoll_ctl\&#34;&gt;epoll_ctl&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;原型: int epoll_ctl(int epfd， int op， int fd， struct epoll_event *event)\n&lt;ul&gt;\n&lt;li&gt;功能：添加/删除/修改要监听的事件&lt;/li&gt;\n&lt;li&gt;入参\n&lt;ul&gt;\n&lt;li&gt;epfd: 即epoll_create创建的epoll实例描述符&lt;/li&gt;\n&lt;li&gt;op: 添加、删除或修改\n&lt;ul&gt;\n&lt;li&gt;EPOLL_CTL_ADD: 添加一个需要监视的fd&lt;/li&gt;\n&lt;li&gt;EPOLL_CTL_DEL: 删除一个fd&lt;/li&gt;\n&lt;li&gt;EPOLL_CTL_MOD: 修改一个fd&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;fd: IO对象描述符&lt;/li&gt;\n&lt;li&gt;event结构体&lt;pre&gt;&lt;code&gt;struct epoll_event {\n    __uint32_t events;\n    epoll_data_t data;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;events字段：感兴趣的事件描述，可多选\n&lt;ul&gt;\n&lt;li&gt;EPOLLIN：fd处于可读状态&lt;/li&gt;\n&lt;li&gt;EPOLLOUT：fd处于可写状态&lt;/li&gt;\n&lt;li&gt;EPOLLET：通知模式为边缘触发模式，相对于水平触发模式而言&lt;/li&gt;\n&lt;li&gt;EPOLLONESHOT：第一次进行通知，之后不再检测&lt;/li&gt;\n&lt;li&gt;EPOLLHUP： 本端产生一个挂断事件，默认检测事件&lt;/li&gt;\n&lt;li&gt;EPOLLDHUP：对端产生一个挂断事件&lt;/li&gt;\n&lt;li&gt;EPOLLPRI：由带外数据触发&lt;/li&gt;\n&lt;li&gt;EPOLLERR：产生错误时触发，默认检测事件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;data字段：是一个union结构&lt;pre&gt;&lt;code&gt;typedef union epoll_data {\n    void *ptr;\n    int fd;\n    __uint32_t u32;\n    __uint64_t u64;\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;如果不需要额外的信息，只需简单的赋值: &lt;code&gt;epoll_data.fd = fd&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;如果需要额外信息，则可以使用&lt;code&gt;void *ptr&lt;/code&gt;, 这样epoll_wait返回时可以使用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;返回值: 如果返回-1表示调用失败&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;epoll_wait\&#34;&gt;epoll_wait&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;原型：int epoll_wait(int epfd， struct epoll_event *events， int maxevents， int timeout)\n&lt;ul&gt;\n&lt;li&gt;功能：阻塞等待已注册的事件发生，返回事件的数目，并将触发的事件写入events数组中&lt;/li&gt;\n&lt;li&gt;入参：\n&lt;ul&gt;\n&lt;li&gt;epfd: 即epoll_create创建的epoll实例描述符&lt;/li&gt;\n&lt;li&gt;events：用来记录被触发的事件数组，其大小应该和maxevents一致&lt;/li&gt;\n&lt;li&gt;maxevents: 返回的events的最大个数&lt;/li&gt;\n&lt;li&gt;timeout: 阻塞超时(以ms为单位)\n&lt;ul&gt;\n&lt;li&gt;如果传参-1， 则调用一直阻塞，直到有事件发生或捕获其他信号&lt;/li&gt;\n&lt;li&gt;如果传参0，则非阻塞检测是否有事件发生，无论有事件还是没事件，调用立即返回&lt;/li&gt;\n&lt;li&gt;如果传参大于0， 则最多等待timeout时间返回，如果等待期间有事件发生则立即返回&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;水平触发和边缘触发\&#34;&gt;水平触发和边缘触发&lt;/h2&gt;\n&lt;h3 id=\&#34;水平触发\&#34;&gt;水平触发&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;只要缓冲区有数据，则返回可读事件&lt;/li&gt;\n&lt;li&gt;只要缓冲区还不满，则返回可写事件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;边缘触发\&#34;&gt;边缘触发&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;可读事件&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当缓冲区数据为空变为非空时，则返回可读事件&lt;/li&gt;\n&lt;li&gt;当缓冲区接收到新数据时，即缓冲区待读数据变多时，返回可读事件&lt;/li&gt;\n&lt;li&gt;当缓冲区有数据可读，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLIN事件时，返回可读事件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;可写事件&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;当缓冲区由不可写变为可写时，则返回可写事件&lt;/li&gt;\n&lt;li&gt;当有旧数据被发送走，即缓冲区中的内容变少的时候，返回可写事件&lt;/li&gt;\n&lt;li&gt;当缓冲区有空间可写，且应用进程对相应的描述符进行EPOLL_CTL_MOD 修改EPOLLOUT事件时，返回可写事件&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;代码示例\&#34;&gt;代码示例&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;\n#include &amp;lt;unistd.h&amp;gt;\n#include &amp;lt;sys/epoll.h&amp;gt;\n#include &amp;lt;string.h&amp;gt;\n\n#define MAX_EVENTS 5\n#define READ_SIZE 10\n\nint main() {\n    int running = 1, event_count, i;\n    size_t bytes_read;\n    char read_buffer[READ_SIZE + 1];\n    struct epoll_event event, events[MAX_EVENTS];\n\n    int epoll_fd = epoll_create1(0);\n    if (epoll_fd == -1) {\n        fprintf(stderr, &amp;quot;Failed to create epoll fd\\n&amp;quot;);\n        return 1;\n    }\n\n    event.events = EPOLLIN;\n    event.data.fd = 0;\n\n    if (epoll_ctl(epoll_fd, EPOLL_CTL_ADD, 0, &amp;amp;event) == -1) {\n        fprintf(stderr, &amp;quot;Failed to add fd to epoll\\n&amp;quot;);\n        return 1;\n    }\n\n    while (running) {\n        printf(&amp;quot;\\nPolling for input...\\n&amp;quot;);\n        event_count = epoll_wait(epoll_fd, events, MAX_EVENTS, 30000);\n        printf(&amp;quot;%d ready events\\n&amp;quot;, event_count);\n        for (i = 0; i &amp;lt; event_count; i++) {\n            printf(&amp;quot;Reading fd &#39;%d&#39; -- &amp;quot;, events[i].data.fd);\n            bytes_read = read(events[i].data.fd, read_buffer, READ_SIZE);\n            printf(&amp;quot;%zd bytes read.\\n&amp;quot;, bytes_read);\n            read_buffer[bytes_read] = &#39;\\0&#39;;\n            printf(&amp;quot;Read &#39;%s&#39;\\n&amp;quot;, read_buffer);\n\n            if (!strncmp(read_buffer, &amp;quot;stop\\n&amp;quot;, 5)) {\n                running = 0;\n            }\n        }\n    }\n\n    if (close(epoll_fd)) {\n        fprintf(stderr, &amp;quot;Failed to close epoll fd\\n&amp;quot;);\n        return 1;\n    }\n\n    return 0;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;epoll-shi-jian-qu-dong&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Linux系统下，Nginx会默认使用epoll作为事件驱动机制，使用epoll是Nginx性能高的一个重要原因。&lt;br&gt;\n本文对epoll工作机制稍作整理。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;epoll事件驱动&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Linux&#34;,&#34;slug&#34;:&#34;xFfSPpftD&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/xFfSPpftD/&#34;}],&#34;date&#34;:&#34;2020-05-12 20:57:22&#34;,&#34;dateFormat&#34;:&#34;2020-05-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/epoll-shi-jian-qu-dong/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;6 min read&#34;,&#34;time&#34;:307000,&#34;words&#34;:1271,&#34;minutes&#34;:6},&#34;description&#34;:&#34;Linux系统下，Nginx会默认使用epoll作为事件驱动机制，使用epoll是Nginx性能高的一个重要原因。\n本文对epoll工作机制稍作整理。\n\n事件驱动\n事件驱动又称作IO多路复用，epoll是Linux内核实现一种IO多路复用机...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8\&#34;&gt;事件驱动&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#epoll-api%E4%BB%8B%E7%BB%8D\&#34;&gt;epoll API介绍&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#epoll_create\&#34;&gt;epoll_create&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#epoll_ctl\&#34;&gt;epoll_ctl&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#epoll_wait\&#34;&gt;epoll_wait&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91%E5%92%8C%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91\&#34;&gt;水平触发和边缘触发&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B0%B4%E5%B9%B3%E8%A7%A6%E5%8F%91\&#34;&gt;水平触发&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%BE%B9%E7%BC%98%E8%A7%A6%E5%8F%91\&#34;&gt;边缘触发&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B\&#34;&gt;代码示例&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;http框架初始化流程图\&#34;&gt;http框架初始化流程图&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1589099904999.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;结合流程简图和代码描述总体流程\&#34;&gt;结合流程简图和代码描述总体流程&lt;/h2&gt;\n&lt;p&gt;当配置文件nginx.conf配置了http{...}并被解析到时，http框架通过执行ngx_http_block函数开始初始化：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;static char *\nngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                        *rv;\n    ngx_uint_t                   mi, m, s;\n    ngx_conf_t                   pcf;\n    ngx_http_module_t           *module;\n    ngx_http_conf_ctx_t         *ctx;\n    ngx_http_core_loc_conf_t    *clcf;\n    ngx_http_core_srv_conf_t   **cscfp;\n    ngx_http_core_main_conf_t   *cmcf;\n\n    if (*(ngx_http_conf_ctx_t **) conf) {\n        return &amp;quot;is duplicate&amp;quot;;\n    }\n\n    /* the main http context */\n\n    ctx = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *(ngx_http_conf_ctx_t **) conf = ctx;\n\n    /*初始化所有HTTP模块的ctx_index序号*/\n    ngx_http_max_module = ngx_count_modules(cf-&amp;gt;cycle, NGX_HTTP_MODULE);\n\n    /*分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组main_conf、srv_conf、loc_conf*/\n    ctx-&amp;gt;main_conf = ngx_pcalloc(cf-&amp;gt;pool,\n                                 sizeof(void *) * ngx_http_max_module);\n    if (ctx-&amp;gt;main_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx-&amp;gt;srv_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);\n    if (ctx-&amp;gt;srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx-&amp;gt;loc_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);\n    if (ctx-&amp;gt;loc_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    /*\n     * 处理http{}块内的main级别配置时，对每个HTTP模块，都会调用create_(main|srv|loc)_conf等3个方法\n     */\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue; //跳过非http模块\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;\n\n        if (module-&amp;gt;create_main_conf) {\n            ctx-&amp;gt;main_conf[mi] = module-&amp;gt;create_main_conf(cf); //main级别\n            if (ctx-&amp;gt;main_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&amp;gt;create_srv_conf) {\n            ctx-&amp;gt;srv_conf[mi] = module-&amp;gt;create_srv_conf(cf); //server级别\n            if (ctx-&amp;gt;srv_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&amp;gt;create_loc_conf) {\n            ctx-&amp;gt;loc_conf[mi] = module-&amp;gt;create_loc_conf(cf); //location级别\n            if (ctx-&amp;gt;loc_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    pcf = *cf;\n    cf-&amp;gt;ctx = ctx;\n\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue;\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n\n        if (module-&amp;gt;preconfiguration) {\n            if (module-&amp;gt;preconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    /* 解析http{} main配置 */\n    cf-&amp;gt;module_type = NGX_HTTP_MODULE;\n    cf-&amp;gt;cmd_type = NGX_HTTP_MAIN_CONF;\n    rv = ngx_conf_parse(cf, NULL); //解析内部配置\n\n    if (rv != NGX_CONF_OK) {\n        goto failed;\n    }\n\n    cmcf = ctx-&amp;gt;main_conf[ngx_http_core_module.ctx_index];\n    cscfp = cmcf-&amp;gt;servers.elts;\n\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue;\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;\n\n        //调用所有HTTP模块的init_main_conf方法，保存main级别配置\n        if (module-&amp;gt;init_main_conf) {\n            rv = module-&amp;gt;init_main_conf(cf, ctx-&amp;gt;main_conf[mi]);\n            if (rv != NGX_CONF_OK) {\n                goto failed;\n            }\n        }\n\n        //合并ngx_modules[m]模块main、srv、loc配置\n        rv = ngx_http_merge_servers(cf, cmcf, module, mi);\n        if (rv != NGX_CONF_OK) {\n            goto failed;\n        }\n    }\n\n    /* 构造location组成的静态二叉平衡查找树 */\n    for (s = 0; s &amp;lt; cmcf-&amp;gt;servers.nelts; s++) {\n\n        clcf = cscfp[s]-&amp;gt;ctx-&amp;gt;loc_conf[ngx_http_core_module.ctx_index];\n\n        //将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序\n        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        //根据已经排序过的的双向链表，构建静态的二叉查找树\n        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    /* 初始化可添加处理方法的HTTP阶段的动态数组 */\n    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /* 调用所有HTTP模块的postconfiguration方法，使之可以介入HTTP请求处理阶段 */\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue;\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n\n        if (module-&amp;gt;postconfiguration) {\n            if (module-&amp;gt;postconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_variables_init_vars(cf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /*\n     * http{}&#39;s cf-&amp;gt;ctx was needed while the configuration merging\n     * and in postconfiguration process\n     */\n\n    *cf = pcf;\n\n    //根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组\n    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    //构造监听端口与server间的关联关系，设置新连接事件的回调方法\n    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&amp;gt;ports) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n\nfailed:\n\n    *cf = pcf;\n\n    return rv;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;初始化所有http模块的ctx_index序号\&#34;&gt;初始化所有HTTP模块的ctx_index序号&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;ctx_index表示模块在同类型模块中的索引，比如ngx_http_core_module是HTTP模块（NGX_HTTP_MODULE）的首个模块，那么该模块的ctx_index为0。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;分配解析http块下main级别配置项时存放http模块结构体指针的3个数组\&#34;&gt;分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;分配main_conf数组用于保存各个HTTP模块在main级别可能创建的xx_main_conf_t结构体&lt;/li&gt;\n&lt;li&gt;分配srv_conf数组用于保存各个HTTP模块在main级别可能创建的xx_srv_conf_t结构体&lt;/li&gt;\n&lt;li&gt;分配loc_conf数组用于保存各个HTTP模块在main级别可能创建的xx_loc_conf_t结构体&lt;/li&gt;\n&lt;li&gt;另外，必须同时创建3个数组。因为对于HTTP模块来说，某个指令有可能同时出现在main、srv、loc级别。实际应用配置项时，具体以那个级别的配置项为准，需要合并处理。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;依次调用所有http模块的create_mainsrvloc_conf共3个方法\&#34;&gt;依次调用所有HTTP模块的create_(main|srv|loc)_conf共3个方法&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的这3个回调方法，如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用create_main_conf，分配每个HTTP模块main级别的xx_main_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;li&gt;调用create_srv_conf，分配每个HTTP模块main级别的xx_srv_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;li&gt;调用create_loc_conf，分配每个HTTP模块main级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用所有http模块的preconfiguration方法\&#34;&gt;调用所有HTTP模块的preconfiguration方法&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;preconfiguration&lt;/code&gt;回调方法，如果实现，则:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用preconfiguration方法, 一般用于添加变量&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;解析http块下的所有main级别配置项\&#34;&gt;解析http{}块下的所有main级别配置项&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;交由conf模块解析http{}块下的配置\n&lt;ul&gt;\n&lt;li&gt;特别的，如果内部碰到server{}块时，则会分配srv_conf、loc_conf数组分别用于保存各个HTTP模块在server级别可能创建的xx_srv_conf_t、xx_loc_conf_t结构体。然后调用create_srv_conf、create_loc_conf分配每个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体内存，并对字段赋初始值\n&lt;ul&gt;\n&lt;li&gt;特别的，如果内部碰到location{}块时，则会分配loc_conf数组分别用于保存各个HTTP模块在location级别可能创建的xx_loc_conf_t结构体。然后调用create_loc_conf分配每个HTTP模块在location级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;li&gt;location{}下的配置解析完，则各个HTTP模块在location级别的xxx_loc_conf_t结构体赋值完成&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;server{}下的配置解析完，则各个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体赋值完成&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用所有http模块的init_main_conf方法\&#34;&gt;调用所有HTTP模块的init_main_conf方法&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的init_main_conf回调方法, 如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;配置解析完成后，调用init_main_conf方法，最终确定并保存各个HTTP模块在main级别的xx_main_conf_t配置结构体&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;合并main-srv-loc级别下server-location相关的配置项\&#34;&gt;合并main、srv、loc级别下server、location相关的配置项&lt;/h3&gt;\n&lt;p&gt;对每一server{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_srv_conf和merge_loc_conf回调方法, 如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用merge_srv_conf和merge_loc_conf方法，最终确定并保存各个HTTP模块在server级别的xx_(srv|loc)_conf_t配置结构体&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;对于每一个location{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_loc_conf回调方法, 如果实现, 则:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用merge_loc_conf方法，最终确定并保存各个HTTP模块在location级别的xx_loc_conf_t配置结构体&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构造location组成的静态二叉平衡查找树\&#34;&gt;构造location组成的静态二叉平衡查找树&lt;/h3&gt;\n&lt;p&gt;对于每一个server而言，&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序&lt;/li&gt;\n&lt;li&gt;根据已经排序过的的双向链表，构建静态的二叉查找树。这样处理请求时可以加速找到location&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;初始化可添加处理方法的http阶段的动态数组\&#34;&gt;初始化可添加处理方法的HTTP阶段的动态数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;http请求处理的11个阶段，分配数组，用于后续添加模块自定义的handler方法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用所有http模块的postconfiguration方法使之可以介入http阶段\&#34;&gt;调用所有HTTP模块的postconfiguration方法使之可以介入HTTP阶段&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;postconfiguration&lt;/code&gt;方法，如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用postconfiguration，将handler方法添加到上一步常见的某个阶段(哪个阶段由模块自行决定，但只有7个阶段可以介入)的数组中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;根据各个http模块介入的处理方法构造出phase_engine_handlers数组\&#34;&gt;根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;根据前两步构造的的动态数组，调用&lt;code&gt;ngx_http_init_phase_handlers&lt;/code&gt;函数构造出phase_engine_handlers数组&lt;/li&gt;\n&lt;li&gt;特别的，有四个阶段不允许介入或者介入无效，分别是：&lt;code&gt;NGX_HTTP_FIND_CONFIG_PHASE&lt;/code&gt;、&lt;br&gt;\n&lt;code&gt;NGX_HTTP_POST_REWRITE_PHASE&lt;/code&gt;、&lt;code&gt;NGX_HTTP_POST_ACCESS_PHASE&lt;/code&gt;、&lt;br&gt;\n&lt;code&gt;NGX_HTTP_PRECONTENT_PHASE&lt;/code&gt;(旧的Nginx的try_files阶段)&lt;/li&gt;\n&lt;li&gt;特别的，&lt;code&gt;NGX_HTTP_CONTENT_PHASE&lt;/code&gt;阶段，除了常规的postconfiguration介入方式(这种方式影响所有的location)。另外可以直接以ngx_command_t指定location的handler方式介入，只对location有该指令的location生效&lt;/li&gt;\n&lt;li&gt;特别的,  记录http日志（最后一个阶段log）特殊处理，并不会出现在phase_engine_handlers数组中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构造server虚拟主机构成的支持通配符的散列表\&#34;&gt;构造server虚拟主机构成的支持通配符的散列表&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;ngx_http_server_names&lt;/code&gt;将server虚拟主机和对应的ngx_http_core_srv_conf_t结构体指针哈希化关联起来，这样处理请求时可以快速匹配server&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构造监听端口与server间的关联关系并设置新连接事件的回调方法\&#34;&gt;构造监听端口与server间的关联关系，并设置新连接事件的回调方法&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;将监听端口&lt;code&gt;ngx_http_conf_port_t&lt;/code&gt;和addr地址&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;关联&lt;/li&gt;\n&lt;li&gt;进一步，将&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;和server虚拟主机关联。该结构体有3个哈希表结构字段，&lt;br&gt;\n分别用于索引完全匹配的sever_name、通配符前置、通配符后置的server虚拟主机结构体&lt;code&gt;ngx_http_core_srv_conf_t&lt;/code&gt;结构体指针&lt;/li&gt;\n&lt;li&gt;设置新连接事件的回调方法: &lt;code&gt;ngx_http_init_connection&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;http请求的11个阶段\&#34;&gt;http请求的11个阶段&lt;/h2&gt;\n&lt;h3 id=\&#34;构造phase_engine_handlers数组\&#34;&gt;构造phase_engine_handlers数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;ngx_http_init_phase_handlers函数在http初始化时调用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;//根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组\nstatic ngx_int_t\nngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)\n{\n    ngx_int_t                   j;\n    ngx_uint_t                  i, n;\n    ngx_uint_t                  find_config_index, use_rewrite, use_access;\n    ngx_http_handler_pt        *h;\n    ngx_http_phase_handler_t   *ph;\n    ngx_http_phase_handler_pt   checker;\n\n    cmcf-&amp;gt;phase_engine.server_rewrite_index = (ngx_uint_t) -1;\n    cmcf-&amp;gt;phase_engine.location_rewrite_index = (ngx_uint_t) -1;\n    find_config_index = 0;\n    use_rewrite = cmcf-&amp;gt;phases[NGX_HTTP_REWRITE_PHASE].handlers.nelts ? 1 : 0;\n    use_access = cmcf-&amp;gt;phases[NGX_HTTP_ACCESS_PHASE].handlers.nelts ? 1 : 0;\n\n    n = 1                  /* find config phase */\n        + use_rewrite      /* post rewrite phase */\n        + use_access;      /* post access phase */\n\n    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意:不包含NGX_HTTP_LOG_PHASE阶段,该阶段另行特殊处理\n        n += cmcf-&amp;gt;phases[i].handlers.nelts; //累加计算总的HTTP阶段处理方法个数\n    }\n\n    ph = ngx_pcalloc(cf-&amp;gt;pool,\n                     n * sizeof(ngx_http_phase_handler_t) + sizeof(void *));\n    if (ph == NULL) {\n        return NGX_ERROR;\n    }\n\n    cmcf-&amp;gt;phase_engine.handlers = ph;\n    n = 0;\n\n    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意: 不包含NGX_HTTP_LOG_PHASE阶段\n        h = cmcf-&amp;gt;phases[i].handlers.elts;\n\n        switch (i) {\n\n        case NGX_HTTP_SERVER_REWRITE_PHASE:\n            if (cmcf-&amp;gt;phase_engine.server_rewrite_index == (ngx_uint_t) -1) {\n                cmcf-&amp;gt;phase_engine.server_rewrite_index = n;\n            }\n            checker = ngx_http_core_rewrite_phase;\n\n            break;\n\n        case NGX_HTTP_FIND_CONFIG_PHASE:\n            find_config_index = n;\n\n            ph-&amp;gt;checker = ngx_http_core_find_config_phase;\n            n++;\n            ph++;\n\n            continue;\n\n        case NGX_HTTP_REWRITE_PHASE:\n            if (cmcf-&amp;gt;phase_engine.location_rewrite_index == (ngx_uint_t) -1) {\n                cmcf-&amp;gt;phase_engine.location_rewrite_index = n;\n            }\n            checker = ngx_http_core_rewrite_phase;\n\n            break;\n\n        case NGX_HTTP_POST_REWRITE_PHASE:\n            if (use_rewrite) {\n                ph-&amp;gt;checker = ngx_http_core_post_rewrite_phase;\n                ph-&amp;gt;next = find_config_index;\n                n++;\n                ph++;\n            }\n\n            continue;\n\n        case NGX_HTTP_ACCESS_PHASE:\n            checker = ngx_http_core_access_phase;\n            n++;\n            break;\n\n        case NGX_HTTP_POST_ACCESS_PHASE:\n            if (use_access) {\n                ph-&amp;gt;checker = ngx_http_core_post_access_phase;\n                ph-&amp;gt;next = n;\n                ph++;\n            }\n\n            continue;\n\n        case NGX_HTTP_CONTENT_PHASE:\n            checker = ngx_http_core_content_phase;\n            break;\n\n        default: //NGX_HTTP_POST_READ_PHASE、NGX_HTTP_PREACCESS_PHASE、NGX_HTTP_PRECONTENT_PHASE\n            checker = ngx_http_core_generic_phase;\n        }\n\n        n += cmcf-&amp;gt;phases[i].handlers.nelts; //跳过本阶段的所有handler, 也即下一阶段的首个handler\n\n        //注意:每个HTTP处理阶段中最后加入到handlers[]中的会首先添加到cmcf-&amp;gt;phase_engine.handlers\n        for (j = cmcf-&amp;gt;phases[i].handlers.nelts - 1; j &amp;gt;= 0; j--) {\n            ph-&amp;gt;checker = checker;\n            ph-&amp;gt;handler = h[j];\n            ph-&amp;gt;next = n; //下一阶段的首个handler序号\n            ph++;\n        }\n    }\n\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;checker方法\&#34;&gt;checker方法&lt;/h3&gt;\n&lt;h4 id=\&#34;ngx_http_core_generic_phase\&#34;&gt;ngx_http_core_generic_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_(POST_READ | PREACCESS | PRECONTENT)_PHASE等阶段的checker方法\n */\nngx_int_t\nngx_http_core_generic_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t  rc;\n\n    /*\n     * generic phase checker,\n     * used by the post read and pre-access phases\n     */\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;generic phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    //调用HTTP模块添加的handler处理方法(由各个HTTP模块的postconfiguration钩子函数添加)\n    rc = ph-&amp;gt;handler(r);\n\n    if (rc == NGX_OK) {\n        r-&amp;gt;phase_handler = ph-&amp;gt;next; //rc为NGX_OK时，进入下一阶段就行处理, 当前阶段即使有其他处理方法也会跳过\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_DECLINED) {\n        r-&amp;gt;phase_handler++; //下一个处理方法，可能仍是当前阶段，也有可能是下一个阶段的首个处理方法\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_AGAIN || rc == NGX_DONE) {\n        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块\n    }\n\n    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */\n\n    ngx_http_finalize_request(r, rc); //返回错误NGX_ERROR或者NGX_HTTP_开头的返回码，则结束请求\n\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_rewrite_phase\&#34;&gt;ngx_http_core_rewrite_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_(SERVER_REWRITE | REWRITE)_PHASE等阶段的checker方法\n */\nngx_int_t\nngx_http_core_rewrite_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t  rc;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    rc = ph-&amp;gt;handler(r); //执行挂载的handler方法\n\n    if (rc == NGX_DECLINED) {\n        r-&amp;gt;phase_handler++; //当前处理方法执行完毕，执行下一个处理方法\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_DONE) {\n        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块\n    }\n\n    /* NGX_OK, NGX_AGAIN, NGX_ERROR, NGX_HTTP_...  */\n\n    ngx_http_finalize_request(r, rc); //结束请求\n\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_find_config_phase\&#34;&gt;ngx_http_core_find_config_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 根据请求的URI寻找匹配的location表达式，不允许用户模块介入。即使介入也无效，因为入参ph未使用\n */\nngx_int_t\nngx_http_core_find_config_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    u_char                    *p;\n    size_t                     len;\n    ngx_int_t                  rc;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    r-&amp;gt;content_handler = NULL;\n    r-&amp;gt;uri_changed = 0;\n\n    rc = ngx_http_core_find_location(r);\n\n    if (rc == NGX_ERROR) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (!r-&amp;gt;internal &amp;amp;&amp;amp; clcf-&amp;gt;internal) {\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);\n        return NGX_OK;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;using configuration \\&amp;quot;%s%V\\&amp;quot;&amp;quot;,\n                   (clcf-&amp;gt;noname ? &amp;quot;*&amp;quot; : (clcf-&amp;gt;exact_match ? &amp;quot;=&amp;quot; : &amp;quot;&amp;quot;)),\n                   &amp;amp;clcf-&amp;gt;name);\n\n    ngx_http_update_location_config(r);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;http cl:%O max:%O&amp;quot;,\n                   r-&amp;gt;headers_in.content_length_n, clcf-&amp;gt;client_max_body_size);\n\n    if (r-&amp;gt;headers_in.content_length_n != -1\n        &amp;amp;&amp;amp; !r-&amp;gt;discard_body\n        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size\n        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size &amp;lt; r-&amp;gt;headers_in.content_length_n)\n    {\n        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                      &amp;quot;client intended to send too large body: %O bytes&amp;quot;,\n                      r-&amp;gt;headers_in.content_length_n);\n\n        r-&amp;gt;expect_tested = 1;\n        (void) ngx_http_discard_request_body(r);\n        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);\n        return NGX_OK;\n    }\n\n    if (rc == NGX_DONE) {\n        ngx_http_clear_location(r);\n\n        r-&amp;gt;headers_out.location = ngx_list_push(&amp;amp;r-&amp;gt;headers_out.headers);\n        if (r-&amp;gt;headers_out.location == NULL) {\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        r-&amp;gt;headers_out.location-&amp;gt;hash = 1;\n        ngx_str_set(&amp;amp;r-&amp;gt;headers_out.location-&amp;gt;key, &amp;quot;Location&amp;quot;);\n\n        if (r-&amp;gt;args.len == 0) {\n            r-&amp;gt;headers_out.location-&amp;gt;value = clcf-&amp;gt;name;\n\n        } else {\n            len = clcf-&amp;gt;name.len + 1 + r-&amp;gt;args.len;\n            p = ngx_pnalloc(r-&amp;gt;pool, len);\n\n            if (p == NULL) {\n                ngx_http_clear_location(r);\n                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return NGX_OK;\n            }\n\n            r-&amp;gt;headers_out.location-&amp;gt;value.len = len;\n            r-&amp;gt;headers_out.location-&amp;gt;value.data = p;\n\n            p = ngx_cpymem(p, clcf-&amp;gt;name.data, clcf-&amp;gt;name.len);\n            *p++ = &#39;?&#39;;\n            ngx_memcpy(p, r-&amp;gt;args.data, r-&amp;gt;args.len);\n        }\n\n        ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);\n        return NGX_OK;\n    }\n\n    r-&amp;gt;phase_handler++; //下一阶段\n    return NGX_AGAIN;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_post_rewrite_phase\&#34;&gt;ngx_http_core_post_rewrite_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_POST_REWRITE_PHASE阶段的checker方法\n */\nngx_int_t\nngx_http_core_post_rewrite_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    ngx_http_core_srv_conf_t  *cscf;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;post rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    if (!r-&amp;gt;uri_changed) {\n        r-&amp;gt;phase_handler++;\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;uri changes: %d&amp;quot;, r-&amp;gt;uri_changes);\n\n    /*\n     * gcc before 3.3 compiles the broken code for\n     *     if (r-&amp;gt;uri_changes-- == 0)\n     * if the r-&amp;gt;uri_changes is defined as\n     *     unsigned  uri_changes:4\n     */\n\n    r-&amp;gt;uri_changes--;\n\n    if (r-&amp;gt;uri_changes == 0) { //url改写次数超限，结束请求\n        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                      &amp;quot;rewrite or internal redirection cycle &amp;quot;\n                      &amp;quot;while processing \\&amp;quot;%V\\&amp;quot;&amp;quot;, &amp;amp;r-&amp;gt;uri);\n\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    r-&amp;gt;phase_handler = ph-&amp;gt;next;\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n    r-&amp;gt;loc_conf = cscf-&amp;gt;ctx-&amp;gt;loc_conf;\n\n    return NGX_AGAIN;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_access_phase\&#34;&gt;ngx_http_core_access_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_ACCESS_PHASE阶段的checker方法\n */\nngx_int_t\nngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t                  rc;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    if (r != r-&amp;gt;main) { //子请求\n        r-&amp;gt;phase_handler = ph-&amp;gt;next; //跳到下一个阶段\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    rc = ph-&amp;gt;handler(r); //执行模块挂载的handler方法\n\n    if (rc == NGX_DECLINED) {\n        r-&amp;gt;phase_handler++; //下一个处理方法\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_AGAIN || rc == NGX_DONE) {\n        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf-&amp;gt;satisfy == NGX_HTTP_SATISFY_ALL) {\n\n        if (rc == NGX_OK) {\n            r-&amp;gt;phase_handler++; //satisfy all, 则执行下一个handler方法\n            return NGX_AGAIN;\n        }\n\n    } else { //satisfy any\n        if (rc == NGX_OK) {\n            r-&amp;gt;access_code = 0;\n\n            if (r-&amp;gt;headers_out.www_authenticate) {\n                r-&amp;gt;headers_out.www_authenticate-&amp;gt;hash = 0;\n            }\n\n            r-&amp;gt;phase_handler = ph-&amp;gt;next; //satisfy any, 则跳到下一个阶段\n            return NGX_AGAIN;\n        }\n\n        if (rc == NGX_HTTP_FORBIDDEN || rc == NGX_HTTP_UNAUTHORIZED) {\n            if (r-&amp;gt;access_code != NGX_HTTP_UNAUTHORIZED) {\n                r-&amp;gt;access_code = rc;\n            }\n\n            r-&amp;gt;phase_handler++; //下一个handler方法\n            return NGX_AGAIN;\n        }\n    }\n\n    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */\n\n    ngx_http_finalize_request(r, rc); //结束请求\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_post_access_phase\&#34;&gt;ngx_http_core_post_access_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_POST_ACCESS_PHASE阶段的checker方法, 入参ph未使用，即不允许介入\n */\nngx_int_t\nngx_http_core_post_access_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t  access_code;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;post access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    access_code = r-&amp;gt;access_code;\n\n    if (access_code) { //access_code非0，表明没有访问权限\n        if (access_code == NGX_HTTP_FORBIDDEN) {\n            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                          &amp;quot;access forbidden by rule&amp;quot;);\n        }\n\n        r-&amp;gt;access_code = 0;\n        ngx_http_finalize_request(r, access_code);\n        return NGX_OK;\n    }\n\n    r-&amp;gt;phase_handler++;\n    return NGX_AGAIN;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_content_phase\&#34;&gt;ngx_http_core_content_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_CONTENT_PHASE阶段的checker方法\n */\nngx_int_t\nngx_http_core_content_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    size_t     root;\n    ngx_int_t  rc;\n    ngx_str_t  path;\n\n    if (r-&amp;gt;content_handler) { //介入的特殊方式: 某location特有的handler方法, 不影响其他location\n        r-&amp;gt;write_event_handler = ngx_http_request_empty_handler;\n        ngx_http_finalize_request(r, r-&amp;gt;content_handler(r));\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;content phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    rc = ph-&amp;gt;handler(r); //执行postconfiguration钩子函数添加的handler方法\n\n    if (rc != NGX_DECLINED) {\n        ngx_http_finalize_request(r, rc);\n        return NGX_OK;\n    }\n\n    /* rc == NGX_DECLINED */\n\n    ph++;\n\n    if (ph-&amp;gt;checker) {\n        r-&amp;gt;phase_handler++; //下一个handler方法\n        return NGX_AGAIN;\n    }\n\n    /* no content handler was found */\n\n    if (r-&amp;gt;uri.data[r-&amp;gt;uri.len - 1] == &#39;/&#39;) {\n\n        if (ngx_http_map_uri_to_path(r, &amp;amp;path, &amp;amp;root, 0) != NULL) {\n            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                          &amp;quot;directory index of \\&amp;quot;%s\\&amp;quot; is forbidden&amp;quot;, path.data);\n        }\n\n        ngx_http_finalize_request(r, NGX_HTTP_FORBIDDEN);\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0, &amp;quot;no handler found&amp;quot;);\n\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND); //404\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;处理请求经过10个阶段\&#34;&gt;处理请求经过10个阶段&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 10个阶段处理HTTP请求\n */\nvoid\nngx_http_core_run_phases(ngx_http_request_t *r)\n{\n    ngx_int_t                   rc;\n    ngx_http_phase_handler_t   *ph;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    ph = cmcf-&amp;gt;phase_engine.handlers;\n\n    while (ph[r-&amp;gt;phase_handler].checker) {\n\n        rc = ph[r-&amp;gt;phase_handler].checker(r, &amp;amp;ph[r-&amp;gt;phase_handler]);\n\n        if (rc == NGX_OK) {\n            return;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;记录http日志阶段特殊处理\&#34;&gt;记录http日志阶段特殊处理&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 记录访问日志。log阶段的handler链并不是在ngx_http_core_run_phases函数中执行, 它只需在请求处理逻辑结束后才执行一次\n */\nstatic void\nngx_http_log_request(ngx_http_request_t *r)\n{\n    ngx_uint_t                  i, n;\n    ngx_http_handler_pt        *log_handler;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    log_handler = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.elts;\n    n = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.nelts;\n\n    for (i = 0; i &amp;lt; n; i++) {\n        log_handler[i](r);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-yuan-ma-fen-xi-zhi-http-kuang-jia&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx源码分析之--http框架&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Nginx&#34;,&#34;slug&#34;:&#34;ZUZBgmRmp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/ZUZBgmRmp/&#34;},{&#34;name&#34;:&#34;源码分析&#34;,&#34;slug&#34;:&#34;1FH1KPhrG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/1FH1KPhrG/&#34;}],&#34;date&#34;:&#34;2020-05-10 11:33:32&#34;,&#34;dateFormat&#34;:&#34;2020-05-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/nginx-yuan-ma-fen-xi-zhi-http-kuang-jia/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;20 min read&#34;,&#34;time&#34;:1156000,&#34;words&#34;:4089,&#34;minutes&#34;:20},&#34;description&#34;:&#34;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？\n\nhttp框架初始化流程图\n\n结合流程简图和代码描述总体流程\n当配置文件nginx.conf配置了http...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#http%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE\&#34;&gt;http框架初始化流程图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E5%90%88%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE%E5%92%8C%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B\&#34;&gt;结合流程简图和代码描述总体流程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84ctx_index%E5%BA%8F%E5%8F%B7\&#34;&gt;初始化所有HTTP模块的ctx_index序号&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%85%8D%E8%A7%A3%E6%9E%90http%E5%9D%97%E4%B8%8Bmain%E7%BA%A7%E5%88%AB%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%97%B6%E5%AD%98%E6%94%BEhttp%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%843%E4%B8%AA%E6%95%B0%E7%BB%84\&#34;&gt;分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BE%9D%E6%AC%A1%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84create_mainsrvloc_conf%E5%85%B13%E4%B8%AA%E6%96%B9%E6%B3%95\&#34;&gt;依次调用所有HTTP模块的create_(main|srv|loc)_conf共3个方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84preconfiguration%E6%96%B9%E6%B3%95\&#34;&gt;调用所有HTTP模块的preconfiguration方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E6%9E%90http%E5%9D%97%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89main%E7%BA%A7%E5%88%AB%E9%85%8D%E7%BD%AE%E9%A1%B9\&#34;&gt;解析http{}块下的所有main级别配置项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84init_main_conf%E6%96%B9%E6%B3%95\&#34;&gt;调用所有HTTP模块的init_main_conf方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%88%E5%B9%B6main-srv-loc%E7%BA%A7%E5%88%AB%E4%B8%8Bserver-location%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9\&#34;&gt;合并main、srv、loc级别下server、location相关的配置项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0location%E7%BB%84%E6%88%90%E7%9A%84%E9%9D%99%E6%80%81%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91\&#34;&gt;构造location组成的静态二叉平衡查找树&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AF%E6%B7%BB%E5%8A%A0%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84http%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84\&#34;&gt;初始化可添加处理方法的HTTP阶段的动态数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84postconfiguration%E6%96%B9%E6%B3%95%E4%BD%BF%E4%B9%8B%E5%8F%AF%E4%BB%A5%E4%BB%8B%E5%85%A5http%E9%98%B6%E6%AE%B5\&#34;&gt;调用所有HTTP模块的postconfiguration方法使之可以介入HTTP阶段&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B9%E6%8D%AE%E5%90%84%E4%B8%AAhttp%E6%A8%A1%E5%9D%97%E4%BB%8B%E5%85%A5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%87%BAphase_engine_handlers%E6%95%B0%E7%BB%84\&#34;&gt;根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0server%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E6%9E%84%E6%88%90%E7%9A%84%E6%94%AF%E6%8C%81%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8\&#34;&gt;构造server虚拟主机构成的支持通配符的散列表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E4%B8%8Eserver%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95\&#34;&gt;构造监听端口与server间的关联关系，并设置新连接事件的回调方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#http%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5\&#34;&gt;http请求的11个阶段&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0phase_engine_handlers%E6%95%B0%E7%BB%84\&#34;&gt;构造phase_engine_handlers数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#checker%E6%96%B9%E6%B3%95\&#34;&gt;checker方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_generic_phase\&#34;&gt;ngx_http_core_generic_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_rewrite_phase\&#34;&gt;ngx_http_core_rewrite_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_find_config_phase\&#34;&gt;ngx_http_core_find_config_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_post_rewrite_phase\&#34;&gt;ngx_http_core_post_rewrite_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_access_phase\&#34;&gt;ngx_http_core_access_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_post_access_phase\&#34;&gt;ngx_http_core_post_access_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_content_phase\&#34;&gt;ngx_http_core_content_phase&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%BB%8F%E8%BF%8710%E4%B8%AA%E9%98%B6%E6%AE%B5\&#34;&gt;处理请求经过10个阶段&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%B0%E5%BD%95http%E6%97%A5%E5%BF%97%E9%98%B6%E6%AE%B5%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86\&#34;&gt;记录http日志阶段特殊处理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;zsh替换bash，可以让命令行操作少敲很多字符👍&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;安装zsh\&#34;&gt;安装zsh&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;yum install zsh -y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装oh-my-zsh\&#34;&gt;安装oh-my-zsh&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装zsh-autosuggestions插件\&#34;&gt;安装zsh-autosuggestions插件&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;修改~zshrc文件\&#34;&gt;修改~/.zshrc文件&lt;/h2&gt;\n&lt;p&gt;找到plugins变量，增加zsh-autosuggestions，如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;plugins=(zsh-autosuggestions)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;zsh-ti-dai-bash&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;zsh替换bash，可以让命令行操作少敲很多字符👍&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;zsh替代bash&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;效率工具&#34;,&#34;slug&#34;:&#34;xiao-lu-gong-ju&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/xiao-lu-gong-ju/&#34;}],&#34;date&#34;:&#34;2020-05-01 21:26:09&#34;,&#34;dateFormat&#34;:&#34;2020-05-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/zsh-ti-dai-bash/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:26000,&#34;words&#34;:87,&#34;minutes&#34;:1},&#34;description&#34;:&#34;zsh替换bash，可以让命令行操作少敲很多字符👍\n\n安装zsh\nyum install zsh -y\n\n安装oh-my-zsh\nsh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzs...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85zsh\&#34;&gt;安装zsh&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85oh-my-zsh\&#34;&gt;安装oh-my-zsh&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85zsh-autosuggestions%E6%8F%92%E4%BB%B6\&#34;&gt;安装zsh-autosuggestions插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9~zshrc%E6%96%87%E4%BB%B6\&#34;&gt;修改~/.zshrc文件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;本文是对ATS的安装、配置、日志等相关基础知识的整理。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;安装-以trafficserver-805版本为例\&#34;&gt;安装 （以trafficserver-8.0.5版本为例）&lt;/h2&gt;\n&lt;h3 id=\&#34;下载源代码并解压\&#34;&gt;下载源代码并解压&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget\nwget https://mirror.bit.edu.cn/apache/trafficserver/trafficserver-8.0.5.tar.bz2\ntar xf trafficserver-8.0.5.tar.bz2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;准备c17编译环境\&#34;&gt;准备c++17编译环境&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install centos-release-scl\nyum -y install yum-utils\nyum-config-manager --enable rhel-server-rhscl-7-rpms\nyum -y install devtoolset-7\n\nscl enable devtoolset-7 zsh\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装tcl-dev-package\&#34;&gt;安装TCL dev package&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install tcl-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装openssl-devel\&#34;&gt;安装openssl-devel&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install openssl-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装lua-devel\&#34;&gt;安装lua-devel&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install lua-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装ncurses-devel\&#34;&gt;安装ncurses-devel&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install ncurses-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;生成makefile\&#34;&gt;生成Makefile&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;./configure --prefix=/opt/ats\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;构建-测试-安装\&#34;&gt;构建、测试、安装&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;make\nmake test\nmake install\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;汇总安装步骤\&#34;&gt;汇总安装步骤&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget tcl-devel openssl-devel lua-devel  ncurses-devel \nyum -y install centos-release-scl yum-utils\nyum-config-manager --enable rhel-server-rhscl-7-rpms\nyum -y install devtoolset-7\nscl enable devtoolset-7 zsh\n\n./configure --prefix=/opt/ats\nmake\nmake test\nmake install\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;配置\&#34;&gt;配置&lt;/h2&gt;\n&lt;h3 id=\&#34;核心配置文件recordsconfig\&#34;&gt;核心配置文件records.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;li&gt;特别的，可以配置启用UI方便查看ATS运行时关键信息、检索和删除缓存等&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;反向代理回源映射配置文件remapconfig\&#34;&gt;反向代理回源映射配置文件remap.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;缓存相关配置文件cacheconfig\&#34;&gt;缓存相关配置文件cache.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;存储配置storageconfig\&#34;&gt;存储配置storage.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;日志\&#34;&gt;日志&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;在records.config中配置日志路径、分割方式等&lt;/li&gt;\n&lt;li&gt;squid风格的日志，使用traffic_logcat查看&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;插件\&#34;&gt;插件&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/portl4t/ts-lua\&#34;&gt;lua插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://docs.trafficserver.apache.org/en/8.0.x/admin-guide/plugins/index.en.html\&#34;&gt;官方插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://docs.trafficserver.apache.org/en/8.0.x/developer-guide/plugins/index.en.html\&#34;&gt;插件开发指南&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;ats-ru-men&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;本文是对ATS的安装、配置、日志等相关基础知识的整理。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;ATS入门&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Cache&#34;,&#34;slug&#34;:&#34;cache&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/cache/&#34;},{&#34;name&#34;:&#34;CDN&#34;,&#34;slug&#34;:&#34;cdn&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/cdn/&#34;}],&#34;date&#34;:&#34;2020-04-12 12:00:50&#34;,&#34;dateFormat&#34;:&#34;2020-04-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/ats-ru-men/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:98000,&#34;words&#34;:348,&#34;minutes&#34;:2},&#34;description&#34;:&#34;本文是对ATS的安装、配置、日志等相关基础知识的整理。\n\n安装 （以trafficserver-8.0.5版本为例）\n下载源代码并解压\nyum -y install bzip2 wget\nwget https://mirror.bit.ed...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85-%E4%BB%A5trafficserver-805%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BE%8B\&#34;&gt;安装 （以trafficserver-8.0.5版本为例）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%A7%A3%E5%8E%8B\&#34;&gt;下载源代码并解压&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%86%E5%A4%87c17%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83\&#34;&gt;准备c++17编译环境&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85tcl-dev-package\&#34;&gt;安装TCL dev package&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85openssl-devel\&#34;&gt;安装openssl-devel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85lua-devel\&#34;&gt;安装lua-devel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85ncurses-devel\&#34;&gt;安装ncurses-devel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E6%88%90makefile\&#34;&gt;生成Makefile&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E5%BB%BA-%E6%B5%8B%E8%AF%95-%E5%AE%89%E8%A3%85\&#34;&gt;构建、测试、安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B1%87%E6%80%BB%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4\&#34;&gt;汇总安装步骤&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6recordsconfig\&#34;&gt;核心配置文件records.config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%9B%9E%E6%BA%90%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6remapconfig\&#34;&gt;反向代理回源映射配置文件remap.config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6cacheconfig\&#34;&gt;缓存相关配置文件cache.config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AEstorageconfig\&#34;&gt;存储配置storage.config&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A5%E5%BF%97\&#34;&gt;日志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6\&#34;&gt;插件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Nginx作为高性能的web服务器，它是如何管理内存的呢？&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;内存池的优点\&#34;&gt;内存池的优点&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;pool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;&lt;/li&gt;\n&lt;li&gt;内存统一分配和回收，避免内存泄漏；&lt;/li&gt;\n&lt;li&gt;整块分配，避免内存过于碎片化;&lt;/li&gt;\n&lt;li&gt;内存对齐处理，减少CPU读取内存次数，提高寻址效率；&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;内存池相关的数据结构\&#34;&gt;内存池相关的数据结构&lt;/h2&gt;\n&lt;h3 id=\&#34;结构体示意图\&#34;&gt;结构体示意图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1587183416580.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;数据结构定义\&#34;&gt;数据结构定义&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;typedef struct ngx_pool_s            ngx_pool_t;\ntypedef struct ngx_pool_large_s  ngx_pool_large_t;\n\nstruct ngx_pool_s { //内存池头部结构\n    ngx_pool_data_t       d;        //内存池的数据区，即真正分配内存的区域\n    size_t                max;      //每次可分配最大内存，用于判定是走大内存分配还是小内存分配逻辑\n    ngx_pool_t           *current;  //指向当前内存池小块内存可用的首个节点\n    ngx_chain_t          *chain;    //缓冲区链表\n    ngx_pool_large_t     *large;    //内存块大于max内存块的链表\n    ngx_pool_cleanup_t   *cleanup;  //销毁内存池回调函数\n    ngx_log_t            *log;      //错误日志指针\n};\n\ntypedef struct {\n    u_char               *last;     //当前内存块已使用到此处，下一次使用从此处开始\n    u_char               *end;      //内存块结束位置\n    ngx_pool_t           *next;     //内存池有很多内存块，通过next指针组成链表\n    ngx_uint_t            failed;   //内存块分配失败次数\n} ngx_pool_data_t; //小内存块(链表)\n\n//大内存块(链表)\nstruct ngx_pool_large_s {\n    ngx_pool_large_t     *next;  //下一数据块地址\n    void                 *alloc; //当前数据块地址\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;内存池主要函数\&#34;&gt;内存池主要函数&lt;/h2&gt;\n&lt;h3 id=\&#34;新建内存池\&#34;&gt;新建内存池&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 新建一个内存池\n */\nngx_pool_t *\nngx_create_pool(size_t size, ngx_log_t *log)\n{\n    ngx_pool_t  *p;\n\n    //调用系统内存分配函数，分配一块堆内存，且做对齐处理\n    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);\n    if (p == NULL) {\n        return NULL;\n    }\n\n    p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t);\n    p-&amp;gt;d.end = (u_char *) p + size;\n    p-&amp;gt;d.next = NULL;\n    p-&amp;gt;d.failed = 0;\n\n    size = size - sizeof(ngx_pool_t);\n    //max最大为pagesize-1(比如:x86时为4095), 即：无论小块内存空间是否足够，超过pagesize-1大小的内存均走large块分配\n    p-&amp;gt;max = (size &amp;lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;\n\n    p-&amp;gt;current = p;\n    p-&amp;gt;chain = NULL;\n    p-&amp;gt;large = NULL;\n    p-&amp;gt;cleanup = NULL;\n    p-&amp;gt;log = log;\n\n    return p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;从内存池申请内存\&#34;&gt;从内存池申请内存&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;先对齐再分配内存&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 从内存池中申请一块内存\n * （1）如果申请的内存小于定义的max，则从内存池中分配内存，需先对齐再分配\n * （2）否则分配大块内存挂载到large指针上\n */\nvoid *\nngx_palloc(ngx_pool_t *pool, size_t size)\n{\n#if !(NGX_DEBUG_PALLOC)\n    if (size &amp;lt;= pool-&amp;gt;max) {\n        return ngx_palloc_small(pool, size, 1); //小块内存(先对齐)\n    }\n#endif\n\n    return ngx_palloc_large(pool, size);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;先对齐再分配内存, 并填充0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 从内存池中申请内存，并填充0\n */\nvoid *\nngx_pcalloc(ngx_pool_t *pool, size_t size)\n{\n    void *p;\n\n    p = ngx_palloc(pool, size);\n    if (p) {\n        ngx_memzero(p, size);\n    }\n\n    return p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;不用对齐分配内存&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 从内存池中申请一块内存 （小块内存无需先对齐）\n */\nvoid *\nngx_pnalloc(ngx_pool_t *pool, size_t size)\n{\n#if !(NGX_DEBUG_PALLOC)\n    if (size &amp;lt;= pool-&amp;gt;max) {\n        return ngx_palloc_small(pool, size, 0); //小块内存（无需先对齐）\n    }\n#endif\n\n    return ngx_palloc_large(pool, size);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;从内存池申请内存小块内存\&#34;&gt;从内存池申请内存小块内存&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 分配小块内存\n * 1. 循环遍历内存块ngx_pool_data_t链表\n * 2. 如果当前内存块剩余大小满足申请的内存大小，则移动相应指针，返回分配的内存指针\n * 3. 否则，移动到下一个内存块\n * 4. 如果所有内存块都没能满足申请的内存大小，则重新申请一块内存块挂载到链表上，并返回分配的内存地址\n */\nstatic ngx_inline void *\nngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)\n{\n    u_char      *m;\n    ngx_pool_t  *p;\n\n    p = pool-&amp;gt;current;\n\n    do {\n        m = p-&amp;gt;d.last; //最后使用位置\n\n        if (align) {\n            m = ngx_align_ptr(m, NGX_ALIGNMENT); //先内存对齐, 减少CPU读取内存次数\n        }\n\n        if ((size_t) (p-&amp;gt;d.end - m) &amp;gt;= size) { //当前内存块剩余空间足够\n            p-&amp;gt;d.last = m + size; //最后使用位置更新，剩余空间变小\n\n            return m;\n        }\n\n        p = p-&amp;gt;d.next;\n\n    } while (p);\n\n    //现有小块内存均无法分配，则新建内存块后再分配\n    return ngx_palloc_block(pool, size);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;新建小内存块再分配\&#34;&gt;新建小内存块再分配&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 再次申请小块内存，并挂载到小块内存链表上，并返回当次申请的内存指针\n*/\nstatic void *\nngx_palloc_block(ngx_pool_t *pool, size_t size)\n{\n    u_char      *m;\n    size_t       psize;\n    ngx_pool_t  *p, *new;\n\n    psize = (size_t) (pool-&amp;gt;d.end - (u_char *) pool);\n\n    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&amp;gt;log);\n    if (m == NULL) {\n        return NULL;\n    }\n\n    new = (ngx_pool_t *) m;\n\n    new-&amp;gt;d.end = m + psize;\n    new-&amp;gt;d.next = NULL;\n    new-&amp;gt;d.failed = 0;\n\n    m += sizeof(ngx_pool_data_t);\n    m = ngx_align_ptr(m, NGX_ALIGNMENT);\n    new-&amp;gt;d.last = m + size;\n\n    for (p = pool-&amp;gt;current; p-&amp;gt;d.next; p = p-&amp;gt;d.next) {\n        //调整各个内存块分配失败次数，如果失败次数大于4，则此块内存节点不再使用\n        if (p-&amp;gt;d.failed++ &amp;gt; 4) {\n            pool-&amp;gt;current = p-&amp;gt;d.next;\n        }\n    }\n\n    p-&amp;gt;d.next = new;\n\n    return m;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;分配大内存\&#34;&gt;分配大内存&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 分配大内存块\n */\nstatic void *\nngx_palloc_large(ngx_pool_t *pool, size_t size)\n{\n    void              *p;\n    ngx_uint_t         n;\n    ngx_pool_large_t  *large;\n\n    p = ngx_alloc(size, pool-&amp;gt;log); //向系统申请size大小堆内存\n    if (p == NULL) {\n        return NULL;\n    }\n\n    n = 0;\n\n    //查找一个空的large区，如果有，则将分配的空间p交由它管理（最多3次）\n    for (large = pool-&amp;gt;large; large; large = large-&amp;gt;next) {\n        if (large-&amp;gt;alloc == NULL) { //ngx_pfree函数会产生空的large区\n            large-&amp;gt;alloc = p;\n            return p;\n        }\n\n        if (n++ &amp;gt; 3) { //超过一定次数，放弃查找空的large区\n            break;\n        }\n    }\n\n    //创建一个新的large节点\n    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);\n    if (large == NULL) {\n        ngx_free(p);\n        return NULL;\n    }\n\n    //新分配的空间p交由新建的large节点管理，并且插入到large链表头部\n    large-&amp;gt;alloc = p;\n    large-&amp;gt;next = pool-&amp;gt;large;\n    pool-&amp;gt;large = large;\n\n    return p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;销毁内存池\&#34;&gt;销毁内存池&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 销毁内存池\n */\nvoid\nngx_destroy_pool(ngx_pool_t *pool)\n{\n    ngx_pool_t          *p, *n;\n    ngx_pool_large_t    *l;\n    ngx_pool_cleanup_t  *c;\n\n    for (c = pool-&amp;gt;cleanup; c; c = c-&amp;gt;next) {\n        if (c-&amp;gt;handler) {\n            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,\n                           &amp;quot;run cleanup: %p&amp;quot;, c);\n            c-&amp;gt;handler(c-&amp;gt;data);\n        }\n    }\n\n#if (NGX_DEBUG)\n\n    /*\n     * we could allocate the pool-&amp;gt;log from this pool\n     * so we cannot use this log while free()ing the pool\n     */\n\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {\n        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0, &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);\n    }\n\n    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {\n        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,\n                       &amp;quot;free: %p, unused: %uz&amp;quot;, p, p-&amp;gt;d.end - p-&amp;gt;d.last);\n\n        if (n == NULL) {\n            break;\n        }\n    }\n\n#endif\n\n    //释放大内存块（链表）\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {\n        if (l-&amp;gt;alloc) {\n            ngx_free(l-&amp;gt;alloc);\n        }\n    }\n\n    //释放小内存块 (链表)\n    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {\n        ngx_free(p);\n\n        if (n == NULL) {\n            break;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;重置内存池\&#34;&gt;重置内存池&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 重置内存池\n * 1. 释放大块内存\n * 2. 重置可开始分配位置指针、分配失败次数为0、可用小内存块current指针指向首个内存块\n */\nvoid\nngx_reset_pool(ngx_pool_t *pool)\n{\n    ngx_pool_t        *p;\n    ngx_pool_large_t  *l;\n\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) { //遍历大块内存链表，释放内存\n        if (l-&amp;gt;alloc) {\n            ngx_free(l-&amp;gt;alloc);\n        }\n    }\n\n    for (p = pool; p; p = p-&amp;gt;d.next) {\n        p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //恢复至初始为位置\n        p-&amp;gt;d.failed = 0; //分配失败次数重置为0\n    }\n\n    pool-&amp;gt;current = pool; //current指向首个内存块\n    pool-&amp;gt;chain = NULL;\n    pool-&amp;gt;large = NULL;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;回收大块内存链表上的某个节点内存\&#34;&gt;回收大块内存链表上的某个节点内存&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 回收大块内存链表上的某个节点内存\n */\nngx_int_t\nngx_pfree(ngx_pool_t *pool, void *p)\n{\n    ngx_pool_large_t  *l;\n\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {\n        if (p == l-&amp;gt;alloc) {\n            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,\n                           &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);\n            ngx_free(l-&amp;gt;alloc);\n            l-&amp;gt;alloc = NULL;\n\n            return NGX_OK;\n        }\n    }\n\n    return NGX_DECLINED;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-yuan-ma-xue-xi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Nginx作为高性能的web服务器，它是如何管理内存的呢？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx源码分析之--内存池&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Nginx&#34;,&#34;slug&#34;:&#34;ZUZBgmRmp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/ZUZBgmRmp/&#34;},{&#34;name&#34;:&#34;源码分析&#34;,&#34;slug&#34;:&#34;1FH1KPhrG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/1FH1KPhrG/&#34;}],&#34;date&#34;:&#34;2020-04-11 22:09:35&#34;,&#34;dateFormat&#34;:&#34;2020-04-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:482000,&#34;words&#34;:1761,&#34;minutes&#34;:9},&#34;description&#34;:&#34;Nginx作为高性能的web服务器，它是如何管理内存的呢？\n\n内存池的优点\n\npool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;\n内存统一分配和回收，避免内存泄漏；\n整块分配，避免内存过于碎片化;\n内存对齐处...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9\&#34;&gt;内存池的优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\&#34;&gt;内存池相关的数据结构&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%84%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE\&#34;&gt;结构体示意图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89\&#34;&gt;数据结构定义&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0\&#34;&gt;内存池主要函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%BB%BA%E5%86%85%E5%AD%98%E6%B1%A0\&#34;&gt;新建内存池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98\&#34;&gt;从内存池申请内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%B0%8F%E5%9D%97%E5%86%85%E5%AD%98\&#34;&gt;从内存池申请内存小块内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%BB%BA%E5%B0%8F%E5%86%85%E5%AD%98%E5%9D%97%E5%86%8D%E5%88%86%E9%85%8D\&#34;&gt;新建小内存块再分配&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%85%8D%E5%A4%A7%E5%86%85%E5%AD%98\&#34;&gt;分配大内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%80%E6%AF%81%E5%86%85%E5%AD%98%E6%B1%A0\&#34;&gt;销毁内存池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E7%BD%AE%E5%86%85%E5%AD%98%E6%B1%A0\&#34;&gt;重置内存池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9E%E6%94%B6%E5%A4%A7%E5%9D%97%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8%E4%B8%8A%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98\&#34;&gt;回收大块内存链表上的某个节点内存&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;安装依赖\&#34;&gt;安装依赖&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;yum install libunwind-devel graphviz-devel ghostscript automake libtool -y&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;编译gpreftools\&#34;&gt;编译gpreftools&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;源代码：https://github.com/gperftools/gperftools/archive/gperftools-2.7.tar.gz&lt;/li&gt;\n&lt;li&gt;编译安装\n&lt;ul&gt;\n&lt;li&gt;./autogen.sh&lt;/li&gt;\n&lt;li&gt;./configure&lt;/li&gt;\n&lt;li&gt;make &amp;amp;&amp;amp; make install&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;导出LD_LIBRARY_PATH\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;export LD_LIBRARY_PATH=&amp;quot;$LD_LIBRARY_PATH:/usr/local/lib&amp;quot;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;nginx使用tcmalloc和启用google_perftools_module模块\&#34;&gt;nginx使用tcmalloc和启用google_perftools_module模块&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;--with-ld-opt=-ltcmalloc --with-google_perftools_module&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;gperftools-fen-xi-nginx&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;gperftools分析Nginx&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Nginx&#34;,&#34;slug&#34;:&#34;ZUZBgmRmp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/ZUZBgmRmp/&#34;}],&#34;date&#34;:&#34;2020-02-09 19:00:55&#34;,&#34;dateFormat&#34;:&#34;2020-02-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/gperftools-fen-xi-nginx/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:21000,&#34;words&#34;:68,&#34;minutes&#34;:1},&#34;description&#34;:&#34;安装依赖\n\nyum install libunwind-devel graphviz-devel ghostscript automake libtool -y\n\n编译gpreftools\n\n源代码：https://github.com/g...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\&#34;&gt;安装依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E8%AF%91gpreftools\&#34;&gt;编译gpreftools&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nginx%E4%BD%BF%E7%94%A8tcmalloc%E5%92%8C%E5%90%AF%E7%94%A8google_perftools_module%E6%A8%A1%E5%9D%97\&#34;&gt;nginx使用tcmalloc和启用google_perftools_module模块&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;好记性不如烂笔头，本文是tcp协议部分基础知识的整理。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;tcp建连-断连\&#34;&gt;tcp建连、断连&lt;/h2&gt;\n&lt;h3 id=\&#34;示意图\&#34;&gt;示意图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1586241639078.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;为什么需要三次握手\&#34;&gt;为什么需要三次握手？&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;防止失效的连接请求到达服务器。&lt;/li&gt;\n&lt;li&gt;具体描述：如果client发送的连接请求SYN包在网络中滞留了较长时间，server最终仍会收到并发回连接确认SYN+ACK。而client等待一个超时时间后，认为刚才滞留的连接请求包丢失了，则会重新发送SYN包发起连接请求。如果不进行第三次握手，那么server收到滞留的SYN包就打开的连接是无效的；如果有第三次握手，那么client会忽略server对滞留的SYN包的响应SYN+ACK，不回复ACK包，server收不到第三次握手ACK包就不会新建连接。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;tcp面向连接什么含义\&#34;&gt;tcp面向连接什么含义？&lt;/h3&gt;\n&lt;p&gt;为了在client和server间维护连接，需建立一定的数据结构来维护双方的交互状态，用这样的数据结构来保证面向连接的特性。&lt;/p&gt;\n&lt;h3 id=\&#34;为什么需要四次挥手\&#34;&gt;为什么需要四次挥手？&lt;/h3&gt;\n&lt;p&gt;一端发送FIN包请求释放连接，对端收到这个FIN报文后进入了&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态。这个状态下，仍然可以向对方发送未发送完毕的数据，数据发送完毕后也要向对端发送FIN报文释放连接，忘了发FIN包(调用close())会导致bug。也就是说，TCP是全双工传输，两端都必须发送FIN包，才能完全断开连接。&lt;/p&gt;\n&lt;h3 id=\&#34;time_wait状态\&#34;&gt;TIME_WAIT状态&lt;/h3&gt;\n&lt;p&gt;主动发送FIN包的一端，在收到对端的FIN报文后进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，这个状态一般要保持一个较长的时间2MSL。原因如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;确保最后一个应答FIN的报文ACK能够到达。因为如果对端没有收到ACK应答，则会重发FIN包。&lt;/li&gt;\n&lt;li&gt;让当前连接在网络中可能的所有报文达到生存期上限后消失，使得下一个新的连接不会收到旧的连接的数据。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;三次握手内核实现原理示意图\&#34;&gt;三次握手内核实现原理示意图&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1586239797212.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;队列长度配置\&#34;&gt;队列长度配置&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;SYN队列长度配置: &lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态连接的最大个数&lt;/code&gt;;&lt;/li&gt;\n&lt;li&gt;ACCEPT队列长度：\n&lt;ul&gt;\n&lt;li&gt;系统全局： &lt;code&gt;net.core.somaxconn = 262144 #系统全局ACCPET队列最大长度的配置&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;应用层: socket API listen传参控制&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;syn攻击\&#34;&gt;SYN攻击&lt;/h3&gt;\n&lt;p&gt;攻击者迅速伪造不同IP地址的SYN报文，快速占满SYN队列，使得正常的SYN包无法加入队列。&lt;/p&gt;\n&lt;h4 id=\&#34;应对syn攻击的参数\&#34;&gt;应对SYN攻击的参数&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;net.core.netdev_max_backlog = 262144 #接收自网卡、但是未被内核协议栈处理的IP报文队列长度&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_abort_on_overflow = 1 #设置为1时表示: 队列满则响应RST包，丢弃连接&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;tcp_syncookies\&#34;&gt;tcp_syncookies&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1 #启用tcp cookie, 使得SYN队列满仍能建立连接&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;控制tcp三次握手的参数\&#34;&gt;控制TCP三次握手的参数&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;SYN_SENT状态&lt;br&gt;\n&lt;code&gt;net.ip4.tcp_syn_retries = 6 #主动建立连接，发送SYN的重试次数&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.ip_local_port_range = 32768 60999 #建立连接时的本地端口可选范围&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;SYN_RCVD状态&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_synack_retries = 3 #被动建立连接时，发送SYN/ACK的重试次数&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;tfotcp-fast-open\&#34;&gt;TFO(TCP Fast Open)&lt;/h2&gt;\n&lt;p&gt;配置: &lt;code&gt;net.ipv4.tcp_fastopen&lt;/code&gt;。（&lt;strong&gt;注意&lt;/strong&gt;：内核版本要求在Linux 3.7以上）&lt;br&gt;\n可选值：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;0: 关闭(默认)&lt;/li&gt;\n&lt;li&gt;1: 作为客户端时可以使用TFO&lt;/li&gt;\n&lt;li&gt;2: 作为服务端时可以使用TFO&lt;/li&gt;\n&lt;li&gt;3: 都可以使用TFO，无论是作为服务端还是客户端&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;示意图-2\&#34;&gt;示意图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1586580242109.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;tcp-xie-yi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;好记性不如烂笔头，本文是tcp协议部分基础知识的整理。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;TCP协议基础&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;网络协议&#34;,&#34;slug&#34;:&#34;Q1k2X6rnU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/Q1k2X6rnU/&#34;}],&#34;date&#34;:&#34;2020-02-02 20:41:15&#34;,&#34;dateFormat&#34;:&#34;2020-02-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/tcp-xie-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:197000,&#34;words&#34;:889,&#34;minutes&#34;:4},&#34;description&#34;:&#34;好记性不如烂笔头，本文是tcp协议部分基础知识的整理。\n\ntcp建连、断连\n示意图\n\n为什么需要三次握手？\n\n防止失效的连接请求到达服务器。\n具体描述：如果client发送的连接请求SYN包在网络中滞留了较长时间，server最终仍会收到并...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp%E5%BB%BA%E8%BF%9E-%E6%96%AD%E8%BF%9E\&#34;&gt;tcp建连、断连&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E6%84%8F%E5%9B%BE\&#34;&gt;示意图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\&#34;&gt;为什么需要三次握手？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89\&#34;&gt;tcp面向连接什么含义？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;为什么需要四次挥手？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#time_wait%E7%8A%B6%E6%80%81\&#34;&gt;TIME_WAIT状态&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE\&#34;&gt;三次握手内核实现原理示意图&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%E9%85%8D%E7%BD%AE\&#34;&gt;队列长度配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#syn%E6%94%BB%E5%87%BB\&#34;&gt;SYN攻击&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BA%94%E5%AF%B9syn%E6%94%BB%E5%87%BB%E7%9A%84%E5%8F%82%E6%95%B0\&#34;&gt;应对SYN攻击的参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp_syncookies\&#34;&gt;tcp_syncookies&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A7%E5%88%B6tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8F%82%E6%95%B0\&#34;&gt;控制TCP三次握手的参数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tfotcp-fast-open\&#34;&gt;TFO(TCP Fast Open)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E6%84%8F%E5%9B%BE-2\&#34;&gt;示意图&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;web冲浪，DNS是必不可少的协议。本文主要介绍DNS的工作机制，对DNS的某些信息(比如历史)不做介绍。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;dns是什么\&#34;&gt;DNS是什么？&lt;/h2&gt;\n&lt;p&gt;DNS是互联网世界的地址薄，类似于电话本，主要提供将域名映射到IP地址的功能。&lt;/p&gt;\n&lt;h2 id=\&#34;dns的树状层次结构\&#34;&gt;DNS的树状层次结构&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;第一层: 根DNS服务器，负责返回顶级DNS(TLD)服务器的IP地址。目前全世界有13台服务节点。&lt;/li&gt;\n&lt;li&gt;第二层: TLD服务器，负责返回权威DNS服务器的IP地址。&lt;/li&gt;\n&lt;li&gt;第三层: 权威DNS服务器，负责返回相应主机或域名的IP地址。&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1586003718190.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dns的解析流程\&#34;&gt;DNS的解析流程&lt;/h2&gt;\n&lt;p&gt;在未命中缓存的情况下，DNS完成域名的解析需要经过如下步骤:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;用户在浏览器中输入“example.com”, 查询由本地DNS服务(&lt;strong&gt;递归服务器&lt;/strong&gt;)解析器接收。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;查询&lt;strong&gt;根DNS域名服务器&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;根DNS服务器&lt;/strong&gt;使用&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;(例如.com或.net)的地址响应给&lt;strong&gt;递归服务器&lt;/strong&gt;。如：“example.com”，则返回.com TLD的IP地址。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向.com&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;发出请求。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;响应&lt;strong&gt;权威DNS服务器&lt;/strong&gt;的IP地址。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向&lt;strong&gt;权威DNS服务器&lt;/strong&gt;翻出请求。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;权威DNS服务器&lt;/strong&gt;响应example.com的IP地址给&lt;strong&gt;递归服务器&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归DNS服务器&lt;/strong&gt;将example.com的IP地址响应给浏览器。（&lt;em&gt;DNS解析完成&lt;/em&gt;）&lt;/li&gt;\n&lt;li&gt;浏览器向example.com的IP地址发出HTTP请求...&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1586005095657.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;dns缓存\&#34;&gt;DNS缓存&lt;/h2&gt;\n&lt;p&gt;在未命中缓存的情形下，DNS解析的流程是复杂且耗时的。DNS数据可以被缓存在多个位置，每个位置可以在一段时间内(记录生存时间TTL)缓存DNS数据记录:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;浏览器DNS缓存&lt;/li&gt;\n&lt;li&gt;操作系统级DNS缓存&lt;/li&gt;\n&lt;li&gt;递归DNS服务器级别缓存。&lt;em&gt;如果域名缓存未命中，但是命中了该域名的NS记录，则跳过请求根和TLD服务器；如果没有NS记录，但是命中了TLD的记录，则跳过请求根服务器；如果没有命中TLD的记录，则要完整走完迭代访问根DNS服务器到权威服务器这一全流程了。&lt;/em&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dns记录类型\&#34;&gt;DNS记录类型&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;常见类型：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;A记录: 域名映射的IPv4地址。&lt;/li&gt;\n&lt;li&gt;CNAME记录：域名别名映射，将域名指向另外一个域名。&lt;/li&gt;\n&lt;li&gt;NS记录：域名映射的权威服务器记录。&lt;/li&gt;\n&lt;li&gt;AAAA记录：域名映射的IPv6地址。&lt;/li&gt;\n&lt;li&gt;MX记录：域名映射的邮箱服务器地址。&lt;/li&gt;\n&lt;li&gt;TXT记录：允许管理员在记录中存储文本。&lt;/li&gt;\n&lt;li&gt;SOA记录：存储有关域的管理员信息。&lt;/li&gt;\n&lt;li&gt;SRV记录：指定特定服务的端口。&lt;/li&gt;\n&lt;li&gt;PTR记录：在反向查询中提供域名。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;dns协议报文格式\&#34;&gt;DNS协议报文格式&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;https://jocent.me/2017/06/18/dns-protocol-principle.html&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;胶水记录glue-record\&#34;&gt;胶水记录(Glue record)&lt;/h2&gt;\n&lt;p&gt;当给&lt;strong&gt;域名A&lt;/strong&gt;配置NS记录时，如果NS记录为&lt;strong&gt;域名A&lt;/strong&gt;的子域名，则必须配置NS记录的A记录。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;通常需要在域名提供商哪里申请两个域名，而不建议采用胶水记录方式。&lt;/li&gt;\n&lt;li&gt;参考链接：https://www.jianshu.com/p/7d69ec2976c7&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dns优秀的go开源项目\&#34;&gt;DNS优秀的go开源项目&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;https://github.com/miekg/dns&lt;/li&gt;\n&lt;li&gt;https://github.com/EmilHernvall/dnsguide&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;demo&lt;/strong&gt;:  https://github.com/xly0713/xdns 😜&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;dns&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;web冲浪，DNS是必不可少的协议。本文主要介绍DNS的工作机制，对DNS的某些信息(比如历史)不做介绍。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;DNS协议基础&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;网络协议&#34;,&#34;slug&#34;:&#34;Q1k2X6rnU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/Q1k2X6rnU/&#34;},{&#34;name&#34;:&#34;GSLB&#34;,&#34;slug&#34;:&#34;pRwAbJURI&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/pRwAbJURI/&#34;}],&#34;date&#34;:&#34;2020-01-30 20:31:48&#34;,&#34;dateFormat&#34;:&#34;2020-01-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/dns/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:183000,&#34;words&#34;:821,&#34;minutes&#34;:4},&#34;description&#34;:&#34;web冲浪，DNS是必不可少的协议。本文主要介绍DNS的工作机制，对DNS的某些信息(比如历史)不做介绍。\n\nDNS是什么？\nDNS是互联网世界的地址薄，类似于电话本，主要提供将域名映射到IP地址的功能。\nDNS的树状层次结构\n\n第一层: ...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E6%98%AF%E4%BB%80%E4%B9%88\&#34;&gt;DNS是什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E7%9A%84%E6%A0%91%E7%8A%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\&#34;&gt;DNS的树状层次结构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B\&#34;&gt;DNS的解析流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E7%BC%93%E5%AD%98\&#34;&gt;DNS缓存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B\&#34;&gt;DNS记录类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F\&#34;&gt;DNS协议报文格式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%83%B6%E6%B0%B4%E8%AE%B0%E5%BD%95glue-record\&#34;&gt;胶水记录(Glue record)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E4%BC%98%E7%A7%80%E7%9A%84go%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE\&#34;&gt;DNS优秀的go开源项目&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;本站主要用来记录一些技术，帮助自己整理零碎的知识，希望对他人有所帮助。欢迎&lt;a href=\&#34;/atom.xml\&#34;&gt;RSS&lt;/a&gt;订阅本站。&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;博主是一名后台研发攻城狮，关注云计算相关领域，目前专注于CDN技术和直播技术。&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;邮件: xly880713@gmail.com&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:21000,&#34;words&#34;:105,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n本站主要用来记录一些技术，帮助自己整理零碎的知识，希望对他人有所帮助。欢迎RSS订阅本站。\n👨‍💻 博主是谁\n博主是一名后台研发攻城狮，关注云计算相关领域，目前专注于CDN技术...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<script src="/media/js/mouse/love.js"></script>

<!-- <script src="/media/js/mouse/peace.js"></script> -->
</html>