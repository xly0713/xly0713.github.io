<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<meta name="keywords" content="Nginx 网络协议 源码分析 DNS 云计算">
<meta name="description" content="">
<meta name="theme-color" content="#000">
<title>gperftools分析Nginx | yz的小站</title>
<link rel="shortcut icon" href="/favicon.ico?v=1589122138768">
<link rel="stylesheet" href="/styles/main.css">
<link rel="stylesheet" href="/media/css/gemini.css">

<link rel="stylesheet" href="/media/fonts/font-awesome.css">
<link
  href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Rosario:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext"
  rel="stylesheet" type="text/css">

<link href="/media/hljs/styles/github.css"
  rel="stylesheet">

<script src="/media/hljs/highlight.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.0/velocity.ui.min.js"></script>

<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>


<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-163205066-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() { dataLayer.push(arguments); }
  gtag('js', new Date());

  gtag('config', 'UA-163205066-1');
</script>


<script>
  var _hmt = _hmt || [];
  (function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?1be048b8c5c87a450b605c349e64ca47";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
  })();
</script>

  <meta name="description" content="gperftools分析Nginx" />
  <meta name="keywords" content="Nginx" />
</head>

<body>
  <div class="head-top-line"></div>
  <div class="header-box">
    
<div class=" gemini">
  <header class="header  ">
    <div class="blog-header box-shadow-wrapper bg-color " id="header">
      <div class="nav-toggle" id="nav_toggle">
        <div class="toggle-box">
          <div class="line line-top"></div>
          <div class="line line-center"></div>
          <div class="line line-bottom"></div>
        </div>
      </div>
      <div class="site-meta">       
        <div class="site-title">
          
            <a href="/" class="brand">
              <span>yz的小站</span>
            </a>  
          
        </div>
        
          <p class="subtitle">Keep Learning, Keep Sharing.</p>
        
      </div>
      <nav class="site-nav" id="site_nav">
        <ul id="nav_ul">
          
            
            
            <li class="nav-item ">
              
              
                <a href="/" target="_self">
                  <i class="fa fa-home"></i> 首页
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/archives/" target="_self">
                  <i class="fa fa-archive"></i> 归档
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/tags/" target="_self">
                  <i class="fa fa-tags"></i> 标签
                </a>
              
            </li>
          
            
            
            <li class="nav-item ">
              
              
                <a href="/post/about/" target="_self">
                  <i class="fa fa-user"></i> 关于
                </a>
              
            </li>
          
          
        </ul>
      </nav>
    </div>
  </header>
</div>

<script type="text/javascript"> 
 
  let showNav = true;

  let navToggle = document.querySelector('#nav_toggle'),
  siteNav = document.querySelector('#site_nav');
  
  function navClick() {
    let sideBar = document.querySelector('.sidebar');
    let navUl = document.querySelector('#nav_ul');
    navToggle.classList.toggle('nav-toggle-active');
    siteNav.classList.toggle('nav-menu-active');
    if (siteNav.classList.contains('nav-menu-active')) {
      siteNav.style = "height: " + (navUl.children.length * 42) +"px !important";
    } else {
      siteNav.style = "";
    }
  }

  navToggle.addEventListener('click',navClick);  
</script>
  </div>
  <div class="main-continer">
    
    <div
      class="section-layout gemini ">
      <div class="section-layout-wrapper">
        

<div class="sidebar">
  
    <div class="sidebar-box box-shadow-wrapper bg-color right-motion" id="sidebar">
      
        <div class="post-list-sidebar">
          <div class="sidebar-title">
            <span id="tocSideBar" class="sidebar-title-item sidebar-title-active">文章目录</span>
            <span id="metaSideBar" class="sidebar-title-item">站点概览</span>
          </div>
        </div>
      
      <div class="sidebar-body gemini" id="sidebar_body">
        
          
            <div class="post-side-meta" id="post_side_meta">
              
<div class="sidebar-wrapper box-shadow-wrapper bg-color">
  <div class="sidebar-item">
    <img class="site-author-image right-motion" src="/images/avatar.png"/>
    <p class="site-author-name">yz的小站</p>
    <p class="site-description right-motion">Day day up!</p>
  </div>
  <div class="sidebar-item side-item-stat right-motion">
    <div class="sidebar-item-box">
      <a href="/archives/">
        
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name">文章</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name">分类</span>
      </a>
    </div>
    <div class="sidebar-item-box">
      <a href="/tags/">
        <span class="site-item-stat-count">7</span>
        <span class="site-item-stat-name">标签</span>
      </a>
    </div>
  </div>
  
    
      <div class="sidebar-item">
        <span class="site-item-rss">
            <i class="fa fa-rss"></i>
            <a href="https://xly0713.github.io/atom.xml" target="_blank">RSS</a>
        </span>
      </div>
    
  
  
    <div class="sidebar-item sidebar-item-social">
      <div class="social-item">
        
          
            <a href="https://github.com/xly0713">
              <i class="fa fa-github-alt" title="Github"></i>
            </a>
          
        
        
      </div>
    </div>
  

  


</div>
            </div>
            <div class="post-toc sidebar-body-active" id="post_toc" style="opacity: 1;">
              <div class="toc-box right-motion">
  <div class="toc-wrapper auto-number no_compress"
    id="toc_wrapper">
    <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96">安装依赖</a></li>
<li><a href="#%E7%BC%96%E8%AF%91gpreftools">编译gpreftools</a></li>
<li><a href="#nginx%E4%BD%BF%E7%94%A8tcmalloc%E5%92%8C%E5%90%AF%E7%94%A8google_perftools_module%E6%A8%A1%E5%9D%97">nginx使用tcmalloc和启用google_perftools_module模块</a></li>
</ul>
</li>
</ul>

  </div>
</div>

<script>

  let lastTop = 0, lList = [], hList = [], postBody, lastIndex = -1;
  let active = 'active-show', activeClass = 'active-current';
  let tocWrapper = document.querySelector('#toc_wrapper');
  let tocContent = tocWrapper.children[0];
  let autoNumber = tocWrapper && tocWrapper.classList.contains('auto-number');

  function addTocNumber(elem, deep) {
    if (!elem) {
      return;
    }
    let prop = elem.__proto__;

    if (prop === HTMLUListElement.prototype) {
      for (let i = 0; i < elem.children.length; i++) {
        addTocNumber(elem.children[i], deep + (i + 1) + '.');
      }
    } else if (prop === HTMLLIElement.prototype) {
      // 保存li元素
      if (elem.children[0].__proto__ === HTMLAnchorElement.prototype) {
        lList.push(elem);
      }
      for (let i = 0; i < elem.children.length; i++) {
        let cur = elem.children[i];
        if (cur.__proto__ === HTMLAnchorElement.prototype) {
          if (autoNumber) {
            cur.text = deep + ' ' + cur.text;
          }
        } else if (cur.__proto__ === HTMLUListElement.prototype) {
          addTocNumber(cur, deep);
        }
      }
    }
  }

  function removeParentActiveClass() {
    let parents = tocContent.querySelectorAll('.' + active)
    parents.forEach(function (elem) {
      elem.classList.remove(active);
    });
  }

  function addActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.add(activeClass);
    }
  }

  function removeActiveClass(index) {
    if (index >= 0 && index < hList.length) {
      lList[index].classList.remove(activeClass);
    }
  }

  function addActiveLiElemment(elem, parent) {
    if (!elem || elem === parent) {
      return;
    } else {
      if (elem.__proto__ === HTMLLIElement.prototype) {
        elem.classList.add(active);
      }
      addActiveLiElemment(elem.parentElement, parent);
    }
  }

  function showToc() {
    if (tocWrapper) {
      postBody = document.querySelector('#post_body');
      for (let i = 0; i < postBody.children.length; i++) {
        if (postBody.children[i].__proto__ === HTMLHeadingElement.prototype) {
          hList.push(postBody.children[i]);
        }
      }
      if (tocWrapper.classList.contains('compress')) {
        tocContent.classList.add('closed');
      } else if (tocWrapper.classList.contains('no_compress')) {
        tocContent.classList.add('expanded');
      } else {
        if (hList.length > 10) {
          active = 'active-hidden'
          tocContent.classList.add('closed');
        } else {
          tocContent.classList.add('expanded');
        }
      }
    }
  }

  (function () {
    // 处理不是从#一级标题开始目录
    if (tocContent.children.length === 1 && tocContent.children[0].__proto__ === HTMLLIElement.prototype) {
      let con = tocContent.children[0].children[0];
      tocContent.innerHTML = con.innerHTML;
    }
    let markdownItTOC = document.querySelector('.markdownIt-TOC');
    let innerHeight = window.innerHeight;
    markdownItTOC.style = `max-height: ${innerHeight - 80 > 0 ? innerHeight - 80 : innerHeight}px`
    addTocNumber(tocContent, '');
  })();

  document.addEventListener('scroll', function (e) {
    if (lList.length <= 0) {
      return;
    }
    let scrollTop = document.scrollingElement.scrollTop + 10;
    let dir;

    if (lastTop - scrollTop > 0) {
      dir = 'up';
    } else {
      dir = 'down';
    }

    lastTop = scrollTop;
    if (scrollTop <= 0) {
      if (lastIndex >= 0 && lastIndex < hList.length) {
        lList[lastIndex].classList.remove(activeClass);
      }
      return;
    }

    let current = 0, hasFind = false;
    for (let i = 0; i < hList.length; i++) {
      if (hList[i].offsetTop > scrollTop) {
        current = i;
        hasFind = true;
        break;
      }
    }
    if (!hasFind && scrollTop > lList[lList.length - 1].offsetTop) {
      current = hList.length - 1;
    } else {
      current--;
    }
    if (dir === 'down') {
      if (current > lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex)
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    } else {
      if (current < lastIndex) {
        addActiveClass(current);
        removeActiveClass(lastIndex);
        lastIndex = current;
        removeParentActiveClass();
        lList[current] && addActiveLiElemment(lList[current].parentElement, tocContent);
      }
    }
  });


  window.addEventListener('load', function () {
    showToc();
    document.querySelector('#sidebar').style = 'display: block;';
    tocWrapper.classList.add('toc-active');
    setTimeout(function () {
      if ("createEvent" in document) {
        let evt = document.createEvent("HTMLEvents");
        evt.initEvent("scroll", false, true);
        document.dispatchEvent(evt);
      }
      else {
        document.fireEvent("scroll");
      }
    }, 500)
  })

</script>
            </div>
          
        
      </div>
    </div>
  
</div>
<script>
  const SIDEBAR_TITLE_ACTIVE = 'sidebar-title-active';
  const SIDEBAR_BODY_ACTIVE = 'sidebar-body-active';
  const SLIDE_UP_IN = 'slide-up-in';

  let sidebar = document.querySelector('#sidebar'),
  tocSideBar = document.querySelector('#tocSideBar'),
  metaSideBar = document.querySelector('#metaSideBar'),
  postToc = document.querySelector('#post_toc'),
  postSiteMeta = document.querySelector('#post_side_meta'),
  sidebarTitle = document.querySelector('.sidebar-title'),
  sidebarBody = document.querySelector('#sidebar_body');

  tocSideBar && tocSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  metaSideBar && metaSideBar.addEventListener('click', (e) => {
    toggleSidebar(e);
  });

  function toggleSidebar(e) {
    let currentTitle = document.querySelector("."+SIDEBAR_TITLE_ACTIVE);
    if (currentTitle == e.srcElement) {
      return ;
    }
    let current, showElement, hideElement;
    if (e.srcElement == metaSideBar) {
      showElement = postSiteMeta;
      hideElement = postToc;
    } else if (e.srcElement == tocSideBar){
      showElement = postToc;
      hideElement = postSiteMeta;
    }
    currentTitle.classList.remove(SIDEBAR_TITLE_ACTIVE);
    e.srcElement.classList.add(SIDEBAR_TITLE_ACTIVE);

    window.Velocity(hideElement, 'stop');
    window.Velocity(hideElement, 'transition.slideUpOut', {
      display: 'none',
      duration: 200,
      complete: function () {
        window.Velocity(showElement, 'transition.slideDownIn', {
          duration: 200
        });
      }
    })
    hideElement.classList.remove(SIDEBAR_BODY_ACTIVE);
    showElement.classList.add(SIDEBAR_BODY_ACTIVE);
  }

  postToc && postToc.addEventListener('transitionend', function() {
    this.classList.remove(SLIDE_UP_IN);
  });

  if (sidebarBody) {
    if (sidebarBody.classList.contains('pisces') || sidebarBody.classList.contains('gemini')) {
      let hasFix = false;
      let scrollEl = document.querySelector('.main-continer');
      let limitTop = document.querySelector('#nav_ul').children.length * 42 + 162;
      window.addEventListener('scroll', function(e) {
        if (document.scrollingElement.scrollTop >= limitTop) {
          if (!hasFix) {
            sidebar.classList.add('sidebar-fixed');
            hasFix = true;
          }
        } else {
          if (hasFix) {
            sidebar.classList.remove('sidebar-fixed');
            hasFix = false;
          }
        }
      });
    }
  }
  
</script>
        <div class="section-box box-shadow-wrapper">
          <div class="section bg-color post post-page">
            <header class="post-header">
  <h1 class="post-title">
    <a class="post-title-link" href="https://xly0713.github.io/post/gperftools-fen-xi-nginx/">
      gperftools分析Nginx
    </a>
  </h1>
  <div class="post-meta">
    
    <span class="meta-item pc-show">
      <i class="fa fa-calendar-o"></i>
      <span>发布于</span>
      <span>2020-02-09</span>
      <span class="post-meta-divider pc-show">|</span>
    </span>
    
    <span class="meta-item">
      <i class="fa fa-folder-o"></i>
      <span class="pc-show">分类于</span>
      
      
      <a href="https://xly0713.github.io/tag/ZUZBgmRmp/">
        <span>Nginx</span>
      </a>
      
      
    </span>
    <span class="post-meta-divider">|</span>
    
    <span class="meta-item">
      <i class="fa fa-clock-o"></i>
      <span>1分钟</span>
    </span>
    <span class="meta-item">
      <span class="post-meta-divider">|</span>
      <i class="fa fa-file-word-o"></i>
      <span>68<span class="pc-show">字数</span></span>
    </span>
    
  </div>
</header>
            <div class="post-body next-md-body" id="post_body">
              <h2 id="安装依赖">安装依赖</h2>
<ul>
<li><code>yum install libunwind-devel graphviz-devel ghostscript automake libtool -y</code></li>
</ul>
<h2 id="编译gpreftools">编译gpreftools</h2>
<ol>
<li>源代码：https://github.com/gperftools/gperftools/archive/gperftools-2.7.tar.gz</li>
<li>编译安装
<ul>
<li>./autogen.sh</li>
<li>./configure</li>
<li>make &amp;&amp; make install</li>
</ul>
</li>
<li>导出LD_LIBRARY_PATH
<ul>
<li><code>export LD_LIBRARY_PATH=&quot;$LD_LIBRARY_PATH:/usr/local/lib&quot;</code></li>
</ul>
</li>
</ol>
<h2 id="nginx使用tcmalloc和启用google_perftools_module模块">nginx使用tcmalloc和启用google_perftools_module模块</h2>
<ul>
<li><code>--with-ld-opt=-ltcmalloc --with-google_perftools_module</code></li>
</ul>

            </div>
            <div class="post-footer">
  <ul class="post-copyright">
    <li class="post-copyright-author">
      <strong>本文作者：</strong>
      yz的小站
    </li>
    <li class="post-copyright-link">
      <strong>本文链接：</strong>
      <a href="https://xly0713.github.io/post/gperftools-fen-xi-nginx/" title="gperftools分析Nginx">https://xly0713.github.io/post/gperftools-fen-xi-nginx/</a>
    </li>
    <li class="post-copyright-license">
      <strong>版权声明： </strong>
      本博客所有文章除特别声明外，均采用<a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i> BY-NC-SA</a> 许可协议。转载请注明出处！
    </li>
  </ul>
  <div class="tags">
    
      <a href="https://xly0713.github.io/tag/ZUZBgmRmp/"># Nginx</a>
    
  </div>
  <div class="nav">
    <div class="nav-prev">
      
        <i class="fa fa-chevron-left"></i>
        <a class="nav-pc-next" title="Nginx源码分析之--内存池" href="https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/">Nginx源码分析之--内存池</a class="nav-pc-next">
        <a class="nav-mobile-prev" title="Nginx源码分析之--内存池" href="https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/">上一篇</a>
      
    </div>
    <div class="nav-next">
      
        <a class="nav-pc-next" title="TCP协议基础" href="https://xly0713.github.io/post/tcp-xie-yi/">TCP协议基础</a>
        <a class="nav-mobile-next" title="TCP协议基础" href="https://xly0713.github.io/post/tcp-xie-yi/">下一篇</a>
        <i class="fa fa-chevron-right"></i>
      
    </div>
  </div>
</div>
            
  
    
      <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>
  var gitalk = new Gitalk({
    clientID: '52d02c95d4f1500d9f75',
    clientSecret: '878436bbe0814eb17153aae1f385fe271ceff250',
    repo: 'xly0713.github.io',
    owner: 'xly0713',
    admin: ['xly0713'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })
  gitalk.render('gitalk-container')
</script>
    
    
  

          </div>
        </div>
      </div>
    </div>
    <div class="footer-box">
  <footer class="footer">
    <div class="copyright">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | © 2019-2020 Theme By <a href="https://github.com/hsxyhao/gridea-theme-next" target="_blank">HsxyHao</a>
    </div>
    <div class="poweredby">
      
    </div>
  </footer>
  
  
  <div class="gemini back-to-top" id="back_to_top">
    <i class="fa fa-arrow-up"></i>
    
    <span class="scrollpercent">
      <span id="back_to_top_text">0</span>%
    </span>
    
  </div>
  
  
    

<link rel="stylesheet" href="/media/live2d/histoire/css/live2d.css" />
<div class="box-scale">
  <div id="landlord" style="left: 5px;bottom: px;" data-key="">
    <div class="message" style="opacity:0"></div>
    <canvas id="live2d" width="500" height="560" class="live2d"></canvas>
    <div class="live_talk_input_body">
      <div class="live_talk_input_name_body">
        <input name="name" type="text" class="live_talk_name white_input" id="AIuserName" autocomplete="off" placeholder="你的名字" />
      </div>
      <div class="live_talk_input_text_body">
        <input name="talk" type="text" class="live_talk_talk white_input" id="AIuserText" autocomplete="off" placeholder="要和我聊什么呀？"/>
        <button type="button" class="live_talk_send_btn" id="talk_send">发送</button>
      </div>
    </div>
    <input name="live_talk" id="live_talk" value="1" type="hidden" />
    <div class="live_ico_box">
      <div class="live_ico_item type_info" id="showInfoBtn"></div>
      <div class="live_ico_item type_talk" id="showTalkBtn"></div>
      
      <div class="live_ico_item type_youdu" id="youduButton"></div>
      <div class="live_ico_item type_quit" id="hideButton"></div>
      <input name="live_statu_val" id="live_statu_val" value="0" type="hidden" />
      <audio src="" style="display:none;" id="live2d_bgm" data-bgm="0" preload="none"></audio>
      <input id="duType" value="douqilai" type="hidden">
      
    </div>
  </div>
</div>
<div id="open_live2d">召唤伊斯特瓦尔</div>
<script src="https://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>
<script>
var message_Path = '/media/live2d/histoire/';
let landlord = document.querySelector('#landlord');
var apiKey = landlord.dataset.key;
</script>
<script type="text/javascript" src="/media/live2d/histoire/js/live2d.js"></script>
<script type="text/javascript" src="/media/live2d/histoire/js/message.js"></script>
  
  
</div>
<script>

  let sideBarOpen = 'sidebar-open';
  let body = document.body;
  let back2Top = document.querySelector('#back_to_top'),
  back2TopText = document.querySelector('#back_to_top_text'),
  drawerBox = document.querySelector('#drawer_box'),
  rightSideBar = document.querySelector('.sidebar'),
  viewport = document.querySelector('body');

  function scrollAnimation(currentY, targetY) {
   
    let needScrollTop = targetY - currentY
    let _currentY = currentY
    setTimeout(() => {
      const dist = Math.ceil(needScrollTop / 10)
      _currentY += dist
      window.scrollTo(_currentY, currentY)
      if (needScrollTop > 10 || needScrollTop < -10) {
        scrollAnimation(_currentY, targetY)
      } else {
        window.scrollTo(_currentY, targetY)
      }
    }, 1)
  }

  back2Top.addEventListener("click", function(e) {
    scrollAnimation(document.scrollingElement.scrollTop, 0);
    e.stopPropagation();
    return false;
  });
  
  window.addEventListener('scroll', function(e) {
    let percent = document.scrollingElement.scrollTop / (document.scrollingElement.scrollHeight - document.scrollingElement.clientHeight) * 100;
    if (percent > 1 && !back2Top.classList.contains('back-top-active')) {
      back2Top.classList.add('back-top-active');
    }
    if (percent == 0) {
      back2Top.classList.remove('back-top-active');
    }
    if (back2TopText) {
      back2TopText.textContent = Math.floor(percent);
    }
  });

  
  let hasCacu = false;
  window.onresize = function() {
    if (window.width > 991) {
      calcuHeight();
    } else {
      hasCacu = false;
    }
  }

  function calcuHeight() {
    // 动态调整站点概览高度
    if (!hasCacu && back2Top.classList.contains('pisces') || back2Top.classList.contains('gemini')) {
      let sideBar = document.querySelector('.sidebar');
      let navUl = document.querySelector('#site_nav');
      sideBar.style = 'margin-top:' + (navUl.offsetHeight + navUl.offsetTop + 15) + 'px;';
      hasCacu = true;
    }
  }
  calcuHeight();
  
  let open = false, MOTION_TIME = 300, RIGHT_MOVE_DIS = '320px';

  if (drawerBox) {
    let rightMotions = document.querySelectorAll('.right-motion');
    let right = drawerBox.classList.contains('right');

    let transitionDir = right ? "transition.slideRightIn" : "transition.slideLeftIn";

    let openProp, closeProp;
    if (right) {
      openProp = {
        paddingRight: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingRight: '0px'
      };
    } else {
      openProp = {
        paddingLeft: RIGHT_MOVE_DIS 
      };
      closeProp = {
        paddingLeft: '0px'
      };
    }

    drawerBox.onclick = function() {
      open = !open;
      window.Velocity(rightSideBar, 'stop');
      window.Velocity(viewport, 'stop');
      window.Velocity(rightMotions, 'stop');
      if (open) {
        window.Velocity(rightSideBar, {
          width: RIGHT_MOVE_DIS
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, transitionDir,{ });
          }
        })
        window.Velocity(viewport, openProp,{
          duration: MOTION_TIME
        });
      } else {
        window.Velocity(rightSideBar, {
          width: '0px'
        }, {
          duration: MOTION_TIME,
          begin: function() {
            window.Velocity(rightMotions, {
              opacity: 0
            });
          }
        })
        window.Velocity(viewport, closeProp ,{
          duration: MOTION_TIME
        });
      }
      for (let i = 0; i < drawerBox.children.length; i++) {
        drawerBox.children[i].classList.toggle('muse-line');
      }
      drawerBox.classList.toggle(sideBarOpen);
    }
  }

  // 链接跳转
  let newWindow = 'false'
  if (newWindow === 'true') {
    let links = document.querySelectorAll('.post-body a')
    links.forEach(item => {
      if (!item.classList.contains('btn')) {
        item.setAttribute("target","_blank");
      }
    })
  }
  // 代码高亮
  hljs.initHighlightingOnLoad();

</script>
    <div class="light-box" id="light_box"></div>
<script>
  let imgs = document.querySelectorAll('.post-body img');
  let lightBox = document.querySelector('#light_box');
  lightBox.addEventListener('mousedown', (e) => {
    e.preventDefault()
  })
  lightBox.addEventListener('mousewheel', (e) => {
    e.preventDefault()
  })
  let width = window.innerWidth * 0.8;
  lightBox.onclick = () => {
    let img = lightBox.querySelector('img');
    lightBox.style = '';
    img && img.remove();
  }
  imgs.forEach(item => {
    item.onclick = function (e) {
      let lightImg = document.createElement('img');
      lightImg.src = this.src;
      lightBox.style = `height: 100%; opacity: 1; background-color: rgba(0, 0, 0, 0.5);cursor: zoom-out;`;
      lightImg.style = `width: ${width}px; border: 1px solid #fff; border-radius: 2px;`;
      lightImg.onclick = function () {
        lightBox.style = '';
        this.remove();
      }
      lightBox.append(lightImg);
    }
  })
</script>
  </div>
</body>
<input hidden id="copy" />
<script>
  //拿来主义(真香)^_^，Clipboard 实现摘自掘金 https://juejin.im/post/5aefeb6e6fb9a07aa43c20af
  window.Clipboard = (function (window, document, navigator) {
    var textArea,
      copy;

    // 判断是不是ios端
    function isOS() {
      return navigator.userAgent.match(/ipad|iphone/i);
    }
    //创建文本元素
    function createTextArea(text) {
      textArea = document.createElement('textArea');
      textArea.value = text;
      textArea.style.width = 0;
      textArea.style.height = 0;
      textArea.clientHeight = 0;
      textArea.clientWidth = 0;
      document.body.appendChild(textArea);
    }
    //选择内容
    function selectText() {
      var range,
        selection;

      if (isOS()) {
        range = document.createRange();
        range.selectNodeContents(textArea);
        selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        textArea.setSelectionRange(0, 999999);
      } else {
        textArea.select();
      }
    }

    //复制到剪贴板
    function copyToClipboard() {
      try {
        document.execCommand("Copy")
      } catch (err) {
        alert("复制错误！请手动复制！")
      }
      document.body.removeChild(textArea);
    }

    copy = function (text) {
      createTextArea(text);
      selectText();
      copyToClipboard();
    };

    return {
      copy: copy
    };
  })(window, document, navigator);

  function copyCode(e) {
    if (e.srcElement.tagName === 'SPAN' && e.srcElement.classList.contains('copy-code')) {
      let code = e.currentTarget.querySelector('code');
      var text = code.innerText;
      if (e.srcElement.textContent === '复制成功') {
        console.log('复制操作频率过高');
        return;
      }
      e.srcElement.textContent = '复制成功';
      (function (elem) {
        setTimeout(() => {
          if (elem.textContent === '复制成功') {
            elem.textContent = '复制代码'
          }
        }, 1000);
      })(e.srcElement)
      Clipboard.copy(text);
    }
  }

  let pres = document.querySelectorAll('pre');
  pres.forEach(pre => {
    let code = pre.querySelector('code');
    let copyElem = document.createElement('span');
    copyElem.classList.add('copy-code');
    copyElem.textContent = '复制代码';
    pre.appendChild(copyElem);
    pre.onclick = copyCode
  })
</script>
<script src="/media/js/motion.js"></script>

<script src="https://cdn.jsdelivr.net/gh/cferdinandi/smooth-scroll/dist/smooth-scroll.polyfills.min.js"></script>
<script>
  var scroll = new SmoothScroll('a[href*="#"]', {
    speed: 500
  });
</script>

<!-- <div class="search-mask" id="search_mask">
  <div class="search-box">
    <div class="search-title">
      <i class="fa fa-search"></i>
      <div class="input-box">
        <input type="text" placeholder="搜索">
      </div>
      <i class="fa fa-times-circle"></i>
    </div>
    <div class="result">
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/nginx-yuan-ma-fen-xi-zhi-http-kuang-jia/"" data-c="
          &lt;p&gt;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;http框架初始化流程图&#34;&gt;http框架初始化流程图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1589099904999.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h2 id=&#34;结合流程简图和代码描述总体流程&#34;&gt;结合流程简图和代码描述总体流程&lt;/h2&gt;
&lt;p&gt;当配置文件nginx.conf配置了http{...}并被解析到时，http框架通过执行ngx_http_block函数开始初始化：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;static char *
ngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    char                        *rv;
    ngx_uint_t                   mi, m, s;
    ngx_conf_t                   pcf;
    ngx_http_module_t           *module;
    ngx_http_conf_ctx_t         *ctx;
    ngx_http_core_loc_conf_t    *clcf;
    ngx_http_core_srv_conf_t   **cscfp;
    ngx_http_core_main_conf_t   *cmcf;

    if (*(ngx_http_conf_ctx_t **) conf) {
        return &amp;quot;is duplicate&amp;quot;;
    }

    /* the main http context */

    ctx = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_conf_ctx_t));
    if (ctx == NULL) {
        return NGX_CONF_ERROR;
    }

    *(ngx_http_conf_ctx_t **) conf = ctx;

    /*初始化所有HTTP模块的ctx_index序号*/
    ngx_http_max_module = ngx_count_modules(cf-&amp;gt;cycle, NGX_HTTP_MODULE);

    /*分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组main_conf、srv_conf、loc_conf*/
    ctx-&amp;gt;main_conf = ngx_pcalloc(cf-&amp;gt;pool,
                                 sizeof(void *) * ngx_http_max_module);
    if (ctx-&amp;gt;main_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    ctx-&amp;gt;srv_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);
    if (ctx-&amp;gt;srv_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    ctx-&amp;gt;loc_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);
    if (ctx-&amp;gt;loc_conf == NULL) {
        return NGX_CONF_ERROR;
    }

    /*
     * 处理http{}块内的main级别配置时，对每个HTTP模块，都会调用create_(main|srv|loc)_conf等3个方法
     */
    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue; //跳过非http模块
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;
        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;

        if (module-&amp;gt;create_main_conf) {
            ctx-&amp;gt;main_conf[mi] = module-&amp;gt;create_main_conf(cf); //main级别
            if (ctx-&amp;gt;main_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        if (module-&amp;gt;create_srv_conf) {
            ctx-&amp;gt;srv_conf[mi] = module-&amp;gt;create_srv_conf(cf); //server级别
            if (ctx-&amp;gt;srv_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }

        if (module-&amp;gt;create_loc_conf) {
            ctx-&amp;gt;loc_conf[mi] = module-&amp;gt;create_loc_conf(cf); //location级别
            if (ctx-&amp;gt;loc_conf[mi] == NULL) {
                return NGX_CONF_ERROR;
            }
        }
    }

    pcf = *cf;
    cf-&amp;gt;ctx = ctx;

    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;preconfiguration) {
            if (module-&amp;gt;preconfiguration(cf) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    /* 解析http{} main配置 */
    cf-&amp;gt;module_type = NGX_HTTP_MODULE;
    cf-&amp;gt;cmd_type = NGX_HTTP_MAIN_CONF;
    rv = ngx_conf_parse(cf, NULL); //解析内部配置

    if (rv != NGX_CONF_OK) {
        goto failed;
    }

    cmcf = ctx-&amp;gt;main_conf[ngx_http_core_module.ctx_index];
    cscfp = cmcf-&amp;gt;servers.elts;

    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;
        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;

        //调用所有HTTP模块的init_main_conf方法，保存main级别配置
        if (module-&amp;gt;init_main_conf) {
            rv = module-&amp;gt;init_main_conf(cf, ctx-&amp;gt;main_conf[mi]);
            if (rv != NGX_CONF_OK) {
                goto failed;
            }
        }

        //合并ngx_modules[m]模块main、srv、loc配置
        rv = ngx_http_merge_servers(cf, cmcf, module, mi);
        if (rv != NGX_CONF_OK) {
            goto failed;
        }
    }

    /* 构造location组成的静态二叉平衡查找树 */
    for (s = 0; s &amp;lt; cmcf-&amp;gt;servers.nelts; s++) {

        clcf = cscfp[s]-&amp;gt;ctx-&amp;gt;loc_conf[ngx_http_core_module.ctx_index];

        //将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序
        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) {
            return NGX_CONF_ERROR;
        }

        //根据已经排序过的的双向链表，构建静态的二叉查找树
        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) {
            return NGX_CONF_ERROR;
        }
    }

    /* 初始化可添加处理方法的HTTP阶段的动态数组 */
    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    /* 调用所有HTTP模块的postconfiguration方法，使之可以介入HTTP请求处理阶段 */
    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {
        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {
            continue;
        }

        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;

        if (module-&amp;gt;postconfiguration) {
            if (module-&amp;gt;postconfiguration(cf) != NGX_OK) {
                return NGX_CONF_ERROR;
            }
        }
    }

    if (ngx_http_variables_init_vars(cf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    /*
     * http{}&#39;s cf-&amp;gt;ctx was needed while the configuration merging
     * and in postconfiguration process
     */

    *cf = pcf;

    //根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组
    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) {
        return NGX_CONF_ERROR;
    }


    //构造监听端口与server间的关联关系，设置新连接事件的回调方法
    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&amp;gt;ports) != NGX_OK) {
        return NGX_CONF_ERROR;
    }

    return NGX_CONF_OK;

failed:

    *cf = pcf;

    return rv;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;初始化所有http模块的ctx_index序号&#34;&gt;初始化所有HTTP模块的ctx_index序号&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ctx_index表示模块在同类型模块中的索引，比如ngx_http_core_module是HTTP模块（NGX_HTTP_MODULE）的首个模块，那么该模块的ctx_index为0。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分配解析http块下main级别配置项时存放http模块结构体指针的3个数组&#34;&gt;分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分配main_conf数组用于保存各个HTTP模块在main级别可能创建的xx_main_conf_t结构体&lt;/li&gt;
&lt;li&gt;分配srv_conf数组用于保存各个HTTP模块在main级别可能创建的xx_srv_conf_t结构体&lt;/li&gt;
&lt;li&gt;分配loc_conf数组用于保存各个HTTP模块在main级别可能创建的xx_loc_conf_t结构体&lt;/li&gt;
&lt;li&gt;另外，必须同时创建3个数组。因为对于HTTP模块来说，某个指令有可能同时出现在main、srv、loc级别。实际应用配置项时，具体以那个级别的配置项为准，需要合并处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;依次调用所有http模块的create_mainsrvloc_conf共3个方法&#34;&gt;依次调用所有HTTP模块的create_(main|srv|loc)_conf共3个方法&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的这3个回调方法，如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用create_main_conf，分配每个HTTP模块main级别的xx_main_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;li&gt;调用create_srv_conf，分配每个HTTP模块main级别的xx_srv_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;li&gt;调用create_loc_conf，分配每个HTTP模块main级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用所有http模块的preconfiguration方法&#34;&gt;调用所有HTTP模块的preconfiguration方法&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;preconfiguration&lt;/code&gt;回调方法，如果实现，则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用preconfiguration方法, 一般用于添加变量&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解析http块下的所有main级别配置项&#34;&gt;解析http{}块下的所有main级别配置项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;交由conf模块解析http{}块下的配置
&lt;ul&gt;
&lt;li&gt;特别的，如果内部碰到server{}块时，则会分配srv_conf、loc_conf数组分别用于保存各个HTTP模块在server级别可能创建的xx_srv_conf_t、xx_loc_conf_t结构体。然后调用create_srv_conf、create_loc_conf分配每个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体内存，并对字段赋初始值
&lt;ul&gt;
&lt;li&gt;特别的，如果内部碰到location{}块时，则会分配loc_conf数组分别用于保存各个HTTP模块在location级别可能创建的xx_loc_conf_t结构体。然后调用create_loc_conf分配每个HTTP模块在location级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;
&lt;li&gt;location{}下的配置解析完，则各个HTTP模块在location级别的xxx_loc_conf_t结构体赋值完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;server{}下的配置解析完，则各个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体赋值完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用所有http模块的init_main_conf方法&#34;&gt;调用所有HTTP模块的init_main_conf方法&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的init_main_conf回调方法, 如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;配置解析完成后，调用init_main_conf方法，最终确定并保存各个HTTP模块在main级别的xx_main_conf_t配置结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;合并main-srv-loc级别下server-location相关的配置项&#34;&gt;合并main、srv、loc级别下server、location相关的配置项&lt;/h3&gt;
&lt;p&gt;对每一server{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_srv_conf和merge_loc_conf回调方法, 如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用merge_srv_conf和merge_loc_conf方法，最终确定并保存各个HTTP模块在server级别的xx_(srv|loc)_conf_t配置结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于每一个location{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_loc_conf回调方法, 如果实现, 则:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用merge_loc_conf方法，最终确定并保存各个HTTP模块在location级别的xx_loc_conf_t配置结构体&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造location组成的静态二叉平衡查找树&#34;&gt;构造location组成的静态二叉平衡查找树&lt;/h3&gt;
&lt;p&gt;对于每一个server而言，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序&lt;/li&gt;
&lt;li&gt;根据已经排序过的的双向链表，构建静态的二叉查找树。这样处理请求时可以加速找到location&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;初始化可添加处理方法的http阶段的动态数组&#34;&gt;初始化可添加处理方法的HTTP阶段的动态数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;http请求处理的11个阶段，分配数组，用于后续添加模块自定义的handler方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;调用所有http模块的postconfiguration方法使之可以介入http阶段&#34;&gt;调用所有HTTP模块的postconfiguration方法使之可以介入HTTP阶段&lt;/h3&gt;
&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;postconfiguration&lt;/code&gt;方法，如果实现，则：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调用postconfiguration，将handler方法添加到上一步常见的某个阶段(哪个阶段由模块自行决定，但只有7个阶段可以介入)的数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;根据各个http模块介入的处理方法构造出phase_engine_handlers数组&#34;&gt;根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根据前两步构造的的动态数组，调用&lt;code&gt;ngx_http_init_phase_handlers&lt;/code&gt;函数构造出phase_engine_handlers数组&lt;/li&gt;
&lt;li&gt;特别的，有四个阶段不允许介入或者介入无效，分别是：&lt;code&gt;NGX_HTTP_FIND_CONFIG_PHASE&lt;/code&gt;、&lt;br&gt;
&lt;code&gt;NGX_HTTP_POST_REWRITE_PHASE&lt;/code&gt;、&lt;code&gt;NGX_HTTP_POST_ACCESS_PHASE&lt;/code&gt;、&lt;br&gt;
&lt;code&gt;NGX_HTTP_PRECONTENT_PHASE&lt;/code&gt;(旧的Nginx的try_files阶段)&lt;/li&gt;
&lt;li&gt;特别的，&lt;code&gt;NGX_HTTP_CONTENT_PHASE&lt;/code&gt;阶段，除了常规的postconfiguration介入方式(这种方式影响所有的location)。另外可以直接以ngx_command_t指定location的handler方式介入，只对location有该指令的location生效&lt;/li&gt;
&lt;li&gt;特别的,  记录http日志（最后一个阶段log）特殊处理，并不会出现在phase_engine_handlers数组中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造server虚拟主机构成的支持通配符的散列表&#34;&gt;构造server虚拟主机构成的支持通配符的散列表&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ngx_http_server_names&lt;/code&gt;将server虚拟主机和对应的ngx_http_core_srv_conf_t结构体指针哈希化关联起来，这样处理请求时可以快速匹配server&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;构造监听端口与server间的关联关系并设置新连接事件的回调方法&#34;&gt;构造监听端口与server间的关联关系，并设置新连接事件的回调方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;将监听端口&lt;code&gt;ngx_http_conf_port_t&lt;/code&gt;和addr地址&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;关联&lt;/li&gt;
&lt;li&gt;进一步，将&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;和server虚拟主机关联。该结构体有3个哈希表结构字段，&lt;br&gt;
分别用于索引完全匹配的sever_name、通配符前置、通配符后置的server虚拟主机结构体&lt;code&gt;ngx_http_core_srv_conf_t&lt;/code&gt;结构体指针&lt;/li&gt;
&lt;li&gt;设置新连接事件的回调方法: &lt;code&gt;ngx_http_init_connection&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;http请求的11个阶段&#34;&gt;http请求的11个阶段&lt;/h2&gt;
&lt;h3 id=&#34;构造phase_engine_handlers数组&#34;&gt;构造phase_engine_handlers数组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;ngx_http_init_phase_handlers函数在http初始化时调用&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;//根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组
static ngx_int_t
ngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)
{
    ngx_int_t                   j;
    ngx_uint_t                  i, n;
    ngx_uint_t                  find_config_index, use_rewrite, use_access;
    ngx_http_handler_pt        *h;
    ngx_http_phase_handler_t   *ph;
    ngx_http_phase_handler_pt   checker;

    cmcf-&amp;gt;phase_engine.server_rewrite_index = (ngx_uint_t) -1;
    cmcf-&amp;gt;phase_engine.location_rewrite_index = (ngx_uint_t) -1;
    find_config_index = 0;
    use_rewrite = cmcf-&amp;gt;phases[NGX_HTTP_REWRITE_PHASE].handlers.nelts ? 1 : 0;
    use_access = cmcf-&amp;gt;phases[NGX_HTTP_ACCESS_PHASE].handlers.nelts ? 1 : 0;

    n = 1                  /* find config phase */
        + use_rewrite      /* post rewrite phase */
        + use_access;      /* post access phase */

    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意:不包含NGX_HTTP_LOG_PHASE阶段,该阶段另行特殊处理
        n += cmcf-&amp;gt;phases[i].handlers.nelts; //累加计算总的HTTP阶段处理方法个数
    }

    ph = ngx_pcalloc(cf-&amp;gt;pool,
                     n * sizeof(ngx_http_phase_handler_t) + sizeof(void *));
    if (ph == NULL) {
        return NGX_ERROR;
    }

    cmcf-&amp;gt;phase_engine.handlers = ph;
    n = 0;

    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意: 不包含NGX_HTTP_LOG_PHASE阶段
        h = cmcf-&amp;gt;phases[i].handlers.elts;

        switch (i) {

        case NGX_HTTP_SERVER_REWRITE_PHASE:
            if (cmcf-&amp;gt;phase_engine.server_rewrite_index == (ngx_uint_t) -1) {
                cmcf-&amp;gt;phase_engine.server_rewrite_index = n;
            }
            checker = ngx_http_core_rewrite_phase;

            break;

        case NGX_HTTP_FIND_CONFIG_PHASE:
            find_config_index = n;

            ph-&amp;gt;checker = ngx_http_core_find_config_phase;
            n++;
            ph++;

            continue;

        case NGX_HTTP_REWRITE_PHASE:
            if (cmcf-&amp;gt;phase_engine.location_rewrite_index == (ngx_uint_t) -1) {
                cmcf-&amp;gt;phase_engine.location_rewrite_index = n;
            }
            checker = ngx_http_core_rewrite_phase;

            break;

        case NGX_HTTP_POST_REWRITE_PHASE:
            if (use_rewrite) {
                ph-&amp;gt;checker = ngx_http_core_post_rewrite_phase;
                ph-&amp;gt;next = find_config_index;
                n++;
                ph++;
            }

            continue;

        case NGX_HTTP_ACCESS_PHASE:
            checker = ngx_http_core_access_phase;
            n++;
            break;

        case NGX_HTTP_POST_ACCESS_PHASE:
            if (use_access) {
                ph-&amp;gt;checker = ngx_http_core_post_access_phase;
                ph-&amp;gt;next = n;
                ph++;
            }

            continue;

        case NGX_HTTP_CONTENT_PHASE:
            checker = ngx_http_core_content_phase;
            break;

        default: //NGX_HTTP_POST_READ_PHASE、NGX_HTTP_PREACCESS_PHASE、NGX_HTTP_PRECONTENT_PHASE
            checker = ngx_http_core_generic_phase;
        }

        n += cmcf-&amp;gt;phases[i].handlers.nelts; //跳过本阶段的所有handler, 也即下一阶段的首个handler

        //注意:每个HTTP处理阶段中最后加入到handlers[]中的会首先添加到cmcf-&amp;gt;phase_engine.handlers
        for (j = cmcf-&amp;gt;phases[i].handlers.nelts - 1; j &amp;gt;= 0; j--) {
            ph-&amp;gt;checker = checker;
            ph-&amp;gt;handler = h[j];
            ph-&amp;gt;next = n; //下一阶段的首个handler序号
            ph++;
        }
    }

    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;checker方法&#34;&gt;checker方法&lt;/h3&gt;
&lt;h4 id=&#34;ngx_http_core_generic_phase&#34;&gt;ngx_http_core_generic_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_(POST_READ | PREACCESS | PRECONTENT)_PHASE等阶段的checker方法
 */
ngx_int_t
ngx_http_core_generic_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    /*
     * generic phase checker,
     * used by the post read and pre-access phases
     */

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;generic phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    //调用HTTP模块添加的handler处理方法(由各个HTTP模块的postconfiguration钩子函数添加)
    rc = ph-&amp;gt;handler(r);

    if (rc == NGX_OK) {
        r-&amp;gt;phase_handler = ph-&amp;gt;next; //rc为NGX_OK时，进入下一阶段就行处理, 当前阶段即使有其他处理方法也会跳过
        return NGX_AGAIN;
    }

    if (rc == NGX_DECLINED) {
        r-&amp;gt;phase_handler++; //下一个处理方法，可能仍是当前阶段，也有可能是下一个阶段的首个处理方法
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块
    }

    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc); //返回错误NGX_ERROR或者NGX_HTTP_开头的返回码，则结束请求

    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_rewrite_phase&#34;&gt;ngx_http_core_rewrite_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_(SERVER_REWRITE | REWRITE)_PHASE等阶段的checker方法
 */
ngx_int_t
ngx_http_core_rewrite_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t  rc;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    rc = ph-&amp;gt;handler(r); //执行挂载的handler方法

    if (rc == NGX_DECLINED) {
        r-&amp;gt;phase_handler++; //当前处理方法执行完毕，执行下一个处理方法
        return NGX_AGAIN;
    }

    if (rc == NGX_DONE) {
        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块
    }

    /* NGX_OK, NGX_AGAIN, NGX_ERROR, NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc); //结束请求

    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_find_config_phase&#34;&gt;ngx_http_core_find_config_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 根据请求的URI寻找匹配的location表达式，不允许用户模块介入。即使介入也无效，因为入参ph未使用
 */
ngx_int_t
ngx_http_core_find_config_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    u_char                    *p;
    size_t                     len;
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    r-&amp;gt;content_handler = NULL;
    r-&amp;gt;uri_changed = 0;

    rc = ngx_http_core_find_location(r);

    if (rc == NGX_ERROR) {
        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (!r-&amp;gt;internal &amp;amp;&amp;amp; clcf-&amp;gt;internal) {
        ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);
        return NGX_OK;
    }

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;using configuration \&amp;quot;%s%V\&amp;quot;&amp;quot;,
                   (clcf-&amp;gt;noname ? &amp;quot;*&amp;quot; : (clcf-&amp;gt;exact_match ? &amp;quot;=&amp;quot; : &amp;quot;&amp;quot;)),
                   &amp;amp;clcf-&amp;gt;name);

    ngx_http_update_location_config(r);

    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;http cl:%O max:%O&amp;quot;,
                   r-&amp;gt;headers_in.content_length_n, clcf-&amp;gt;client_max_body_size);

    if (r-&amp;gt;headers_in.content_length_n != -1
        &amp;amp;&amp;amp; !r-&amp;gt;discard_body
        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size
        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size &amp;lt; r-&amp;gt;headers_in.content_length_n)
    {
        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                      &amp;quot;client intended to send too large body: %O bytes&amp;quot;,
                      r-&amp;gt;headers_in.content_length_n);

        r-&amp;gt;expect_tested = 1;
        (void) ngx_http_discard_request_body(r);
        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);
        return NGX_OK;
    }

    if (rc == NGX_DONE) {
        ngx_http_clear_location(r);

        r-&amp;gt;headers_out.location = ngx_list_push(&amp;amp;r-&amp;gt;headers_out.headers);
        if (r-&amp;gt;headers_out.location == NULL) {
            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
            return NGX_OK;
        }

        r-&amp;gt;headers_out.location-&amp;gt;hash = 1;
        ngx_str_set(&amp;amp;r-&amp;gt;headers_out.location-&amp;gt;key, &amp;quot;Location&amp;quot;);

        if (r-&amp;gt;args.len == 0) {
            r-&amp;gt;headers_out.location-&amp;gt;value = clcf-&amp;gt;name;

        } else {
            len = clcf-&amp;gt;name.len + 1 + r-&amp;gt;args.len;
            p = ngx_pnalloc(r-&amp;gt;pool, len);

            if (p == NULL) {
                ngx_http_clear_location(r);
                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
                return NGX_OK;
            }

            r-&amp;gt;headers_out.location-&amp;gt;value.len = len;
            r-&amp;gt;headers_out.location-&amp;gt;value.data = p;

            p = ngx_cpymem(p, clcf-&amp;gt;name.data, clcf-&amp;gt;name.len);
            *p++ = &#39;?&#39;;
            ngx_memcpy(p, r-&amp;gt;args.data, r-&amp;gt;args.len);
        }

        ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);
        return NGX_OK;
    }

    r-&amp;gt;phase_handler++; //下一阶段
    return NGX_AGAIN;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_post_rewrite_phase&#34;&gt;ngx_http_core_post_rewrite_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_POST_REWRITE_PHASE阶段的checker方法
 */
ngx_int_t
ngx_http_core_post_rewrite_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_http_core_srv_conf_t  *cscf;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;post rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    if (!r-&amp;gt;uri_changed) {
        r-&amp;gt;phase_handler++;
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;uri changes: %d&amp;quot;, r-&amp;gt;uri_changes);

    /*
     * gcc before 3.3 compiles the broken code for
     *     if (r-&amp;gt;uri_changes-- == 0)
     * if the r-&amp;gt;uri_changes is defined as
     *     unsigned  uri_changes:4
     */

    r-&amp;gt;uri_changes--;

    if (r-&amp;gt;uri_changes == 0) { //url改写次数超限，结束请求
        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                      &amp;quot;rewrite or internal redirection cycle &amp;quot;
                      &amp;quot;while processing \&amp;quot;%V\&amp;quot;&amp;quot;, &amp;amp;r-&amp;gt;uri);

        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);
        return NGX_OK;
    }

    r-&amp;gt;phase_handler = ph-&amp;gt;next;

    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);
    r-&amp;gt;loc_conf = cscf-&amp;gt;ctx-&amp;gt;loc_conf;

    return NGX_AGAIN;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_access_phase&#34;&gt;ngx_http_core_access_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_ACCESS_PHASE阶段的checker方法
 */
ngx_int_t
ngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)
{
    ngx_int_t                  rc;
    ngx_http_core_loc_conf_t  *clcf;

    if (r != r-&amp;gt;main) { //子请求
        r-&amp;gt;phase_handler = ph-&amp;gt;next; //跳到下一个阶段
        return NGX_AGAIN;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    rc = ph-&amp;gt;handler(r); //执行模块挂载的handler方法

    if (rc == NGX_DECLINED) {
        r-&amp;gt;phase_handler++; //下一个处理方法
        return NGX_AGAIN;
    }

    if (rc == NGX_AGAIN || rc == NGX_DONE) {
        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块
    }

    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);

    if (clcf-&amp;gt;satisfy == NGX_HTTP_SATISFY_ALL) {

        if (rc == NGX_OK) {
            r-&amp;gt;phase_handler++; //satisfy all, 则执行下一个handler方法
            return NGX_AGAIN;
        }

    } else { //satisfy any
        if (rc == NGX_OK) {
            r-&amp;gt;access_code = 0;

            if (r-&amp;gt;headers_out.www_authenticate) {
                r-&amp;gt;headers_out.www_authenticate-&amp;gt;hash = 0;
            }

            r-&amp;gt;phase_handler = ph-&amp;gt;next; //satisfy any, 则跳到下一个阶段
            return NGX_AGAIN;
        }

        if (rc == NGX_HTTP_FORBIDDEN || rc == NGX_HTTP_UNAUTHORIZED) {
            if (r-&amp;gt;access_code != NGX_HTTP_UNAUTHORIZED) {
                r-&amp;gt;access_code = rc;
            }

            r-&amp;gt;phase_handler++; //下一个handler方法
            return NGX_AGAIN;
        }
    }

    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */

    ngx_http_finalize_request(r, rc); //结束请求
    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_post_access_phase&#34;&gt;ngx_http_core_post_access_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_POST_ACCESS_PHASE阶段的checker方法, 入参ph未使用，即不允许介入
 */
ngx_int_t
ngx_http_core_post_access_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    ngx_int_t  access_code;

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;post access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    access_code = r-&amp;gt;access_code;

    if (access_code) { //access_code非0，表明没有访问权限
        if (access_code == NGX_HTTP_FORBIDDEN) {
            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                          &amp;quot;access forbidden by rule&amp;quot;);
        }

        r-&amp;gt;access_code = 0;
        ngx_http_finalize_request(r, access_code);
        return NGX_OK;
    }

    r-&amp;gt;phase_handler++;
    return NGX_AGAIN;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;ngx_http_core_content_phase&#34;&gt;ngx_http_core_content_phase&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;/*
 * NGX_HTTP_CONTENT_PHASE阶段的checker方法
 */
ngx_int_t
ngx_http_core_content_phase(ngx_http_request_t *r,
    ngx_http_phase_handler_t *ph)
{
    size_t     root;
    ngx_int_t  rc;
    ngx_str_t  path;

    if (r-&amp;gt;content_handler) { //介入的特殊方式: 某location特有的handler方法, 不影响其他location
        r-&amp;gt;write_event_handler = ngx_http_request_empty_handler;
        ngx_http_finalize_request(r, r-&amp;gt;content_handler(r));
        return NGX_OK;
    }

    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,
                   &amp;quot;content phase: %ui&amp;quot;, r-&amp;gt;phase_handler);

    rc = ph-&amp;gt;handler(r); //执行postconfiguration钩子函数添加的handler方法

    if (rc != NGX_DECLINED) {
        ngx_http_finalize_request(r, rc);
        return NGX_OK;
    }

    /* rc == NGX_DECLINED */

    ph++;

    if (ph-&amp;gt;checker) {
        r-&amp;gt;phase_handler++; //下一个handler方法
        return NGX_AGAIN;
    }

    /* no content handler was found */

    if (r-&amp;gt;uri.data[r-&amp;gt;uri.len - 1] == &#39;/&#39;) {

        if (ngx_http_map_uri_to_path(r, &amp;amp;path, &amp;amp;root, 0) != NULL) {
            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,
                          &amp;quot;directory index of \&amp;quot;%s\&amp;quot; is forbidden&amp;quot;, path.data);
        }

        ngx_http_finalize_request(r, NGX_HTTP_FORBIDDEN);
        return NGX_OK;
    }

    ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0, &amp;quot;no handler found&amp;quot;);

    ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND); //404
    return NGX_OK;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;处理请求经过10个阶段&#34;&gt;处理请求经过10个阶段&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 10个阶段处理HTTP请求
 */
void
ngx_http_core_run_phases(ngx_http_request_t *r)
{
    ngx_int_t                   rc;
    ngx_http_phase_handler_t   *ph;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    ph = cmcf-&amp;gt;phase_engine.handlers;

    while (ph[r-&amp;gt;phase_handler].checker) {

        rc = ph[r-&amp;gt;phase_handler].checker(r, &amp;amp;ph[r-&amp;gt;phase_handler]);

        if (rc == NGX_OK) {
            return;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;记录http日志阶段特殊处理&#34;&gt;记录http日志阶段特殊处理&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 记录访问日志。log阶段的handler链并不是在ngx_http_core_run_phases函数中执行, 它只需在请求处理逻辑结束后才执行一次
 */
static void
ngx_http_log_request(ngx_http_request_t *r)
{
    ngx_uint_t                  i, n;
    ngx_http_handler_pt        *log_handler;
    ngx_http_core_main_conf_t  *cmcf;

    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);

    log_handler = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.elts;
    n = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.nelts;

    for (i = 0; i &amp;lt; n; i++) {
        log_handler[i](r);
    }
}
&lt;/code&gt;&lt;/pre&gt;
">Nginx源码分析之--http框架</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/zsh-ti-dai-bash/"" data-c="
          &lt;p&gt;zsh替换bash，可以让命令行操作更高效。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装zsh&#34;&gt;安装zsh&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;yum install zsh -y
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装oh-my-zsh&#34;&gt;安装oh-my-zsh&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;安装zsh-autosuggestions插件&#34;&gt;安装zsh-autosuggestions插件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;修改~zshrc文件&#34;&gt;修改~/.zshrc文件&lt;/h2&gt;
&lt;p&gt;找到plugins变量，增加zsh-autosuggestions，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;plugins=(zsh-autosuggestions)
&lt;/code&gt;&lt;/pre&gt;
">zsh替代bash</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/ats-ru-men/"" data-c="
          &lt;p&gt;本文是对ATS的安装、配置、日志等相关基础知识的整理。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;安装-以trafficserver-805版本为例&#34;&gt;安装 （以trafficserver-8.0.5版本为例）&lt;/h2&gt;
&lt;h3 id=&#34;下载源代码并解压&#34;&gt;下载源代码并解压&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget
wget https://mirror.bit.edu.cn/apache/trafficserver/trafficserver-8.0.5.tar.bz2
tar xf trafficserver-8.0.5.tar.bz2
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;准备c17编译环境&#34;&gt;准备c++17编译环境&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install centos-release-scl
yum -y install yum-utils
yum-config-manager --enable rhel-server-rhscl-7-rpms
yum -y install devtoolset-7

scl enable devtoolset-7 zsh
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装tcl-dev-package&#34;&gt;安装TCL dev package&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install tcl-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装openssl-devel&#34;&gt;安装openssl-devel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install openssl-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装lua-devel&#34;&gt;安装lua-devel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install lua-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;安装ncurses-devel&#34;&gt;安装ncurses-devel&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install ncurses-devel
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;生成makefile&#34;&gt;生成Makefile&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;./configure --prefix=/opt/ats
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;构建-测试-安装&#34;&gt;构建、测试、安装&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;汇总安装步骤&#34;&gt;汇总安装步骤&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget tcl-devel openssl-devel lua-devel  ncurses-devel 
yum -y install centos-release-scl yum-utils
yum-config-manager --enable rhel-server-rhscl-7-rpms
yum -y install devtoolset-7
scl enable devtoolset-7 zsh

./configure --prefix=/opt/ats
make
make test
make install
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;配置&#34;&gt;配置&lt;/h2&gt;
&lt;h3 id=&#34;核心配置文件recordsconfig&#34;&gt;核心配置文件records.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;li&gt;特别的，可以配置启用UI方便查看ATS运行时关键信息、检索和删除缓存等&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;反向代理回源映射配置文件remapconfig&#34;&gt;反向代理回源映射配置文件remap.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缓存相关配置文件cacheconfig&#34;&gt;缓存相关配置文件cache.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;存储配置storageconfig&#34;&gt;存储配置storage.config&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;暂略，待补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志&#34;&gt;日志&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在records.config中配置日志路径、分割方式等&lt;/li&gt;
&lt;li&gt;squid风格的日志，使用traffic_logcat查看&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;插件&#34;&gt;插件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/portl4t/ts-lua&#34;&gt;lua插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.trafficserver.apache.org/en/8.0.x/admin-guide/plugins/index.en.html&#34;&gt;官方插件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.trafficserver.apache.org/en/8.0.x/developer-guide/plugins/index.en.html&#34;&gt;插件开发指南&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
">ATS入门</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/"" data-c="
          &lt;p&gt;Nginx作为高性能的web服务器，它是如何管理内存的呢？&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;内存池的优点&#34;&gt;内存池的优点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;pool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;&lt;/li&gt;
&lt;li&gt;内存统一分配和回收，避免内存泄漏；&lt;/li&gt;
&lt;li&gt;整块分配，避免内存过于碎片化;&lt;/li&gt;
&lt;li&gt;内存对齐处理，减少CPU读取内存次数，提高寻址效率；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;内存池相关的数据结构&#34;&gt;内存池相关的数据结构&lt;/h2&gt;
&lt;h3 id=&#34;结构体示意图&#34;&gt;结构体示意图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1587183416580.jpg&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;数据结构定义&#34;&gt;数据结构定义&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;typedef struct ngx_pool_s            ngx_pool_t;
typedef struct ngx_pool_large_s  ngx_pool_large_t;

struct ngx_pool_s { //内存池头部结构
    ngx_pool_data_t       d;        //内存池的数据区，即真正分配内存的区域
    size_t                max;      //每次可分配最大内存，用于判定是走大内存分配还是小内存分配逻辑
    ngx_pool_t           *current;  //指向当前内存池小块内存可用的首个节点
    ngx_chain_t          *chain;    //缓冲区链表
    ngx_pool_large_t     *large;    //内存块大于max内存块的链表
    ngx_pool_cleanup_t   *cleanup;  //销毁内存池回调函数
    ngx_log_t            *log;      //错误日志指针
};

typedef struct {
    u_char               *last;     //当前内存块已使用到此处，下一次使用从此处开始
    u_char               *end;      //内存块结束位置
    ngx_pool_t           *next;     //内存池有很多内存块，通过next指针组成链表
    ngx_uint_t            failed;   //内存块分配失败次数
} ngx_pool_data_t; //小内存块(链表)

//大内存块(链表)
struct ngx_pool_large_s {
    ngx_pool_large_t     *next;  //下一数据块地址
    void                 *alloc; //当前数据块地址
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&#34;内存池主要函数&#34;&gt;内存池主要函数&lt;/h2&gt;
&lt;h3 id=&#34;新建内存池&#34;&gt;新建内存池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 新建一个内存池
 */
ngx_pool_t *
ngx_create_pool(size_t size, ngx_log_t *log)
{
    ngx_pool_t  *p;

    //调用系统内存分配函数，分配一块堆内存，且做对齐处理
    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);
    if (p == NULL) {
        return NULL;
    }

    p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t);
    p-&amp;gt;d.end = (u_char *) p + size;
    p-&amp;gt;d.next = NULL;
    p-&amp;gt;d.failed = 0;

    size = size - sizeof(ngx_pool_t);
    //max最大为pagesize-1(比如:x86时为4095), 即：无论小块内存空间是否足够，超过pagesize-1大小的内存均走large块分配
    p-&amp;gt;max = (size &amp;lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;

    p-&amp;gt;current = p;
    p-&amp;gt;chain = NULL;
    p-&amp;gt;large = NULL;
    p-&amp;gt;cleanup = NULL;
    p-&amp;gt;log = log;

    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从内存池申请内存&#34;&gt;从内存池申请内存&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;先对齐再分配内存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 从内存池中申请一块内存
 * （1）如果申请的内存小于定义的max，则从内存池中分配内存，需先对齐再分配
 * （2）否则分配大块内存挂载到large指针上
 */
void *
ngx_palloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size &amp;lt;= pool-&amp;gt;max) {
        return ngx_palloc_small(pool, size, 1); //小块内存(先对齐)
    }
#endif

    return ngx_palloc_large(pool, size);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;先对齐再分配内存, 并填充0&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 从内存池中申请内存，并填充0
 */
void *
ngx_pcalloc(ngx_pool_t *pool, size_t size)
{
    void *p;

    p = ngx_palloc(pool, size);
    if (p) {
        ngx_memzero(p, size);
    }

    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;不用对齐分配内存&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 从内存池中申请一块内存 （小块内存无需先对齐）
 */
void *
ngx_pnalloc(ngx_pool_t *pool, size_t size)
{
#if !(NGX_DEBUG_PALLOC)
    if (size &amp;lt;= pool-&amp;gt;max) {
        return ngx_palloc_small(pool, size, 0); //小块内存（无需先对齐）
    }
#endif

    return ngx_palloc_large(pool, size);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;从内存池申请内存小块内存&#34;&gt;从内存池申请内存小块内存&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 分配小块内存
 * 1. 循环遍历内存块ngx_pool_data_t链表
 * 2. 如果当前内存块剩余大小满足申请的内存大小，则移动相应指针，返回分配的内存指针
 * 3. 否则，移动到下一个内存块
 * 4. 如果所有内存块都没能满足申请的内存大小，则重新申请一块内存块挂载到链表上，并返回分配的内存地址
 */
static ngx_inline void *
ngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)
{
    u_char      *m;
    ngx_pool_t  *p;

    p = pool-&amp;gt;current;

    do {
        m = p-&amp;gt;d.last; //最后使用位置

        if (align) {
            m = ngx_align_ptr(m, NGX_ALIGNMENT); //先内存对齐, 减少CPU读取内存次数
        }

        if ((size_t) (p-&amp;gt;d.end - m) &amp;gt;= size) { //当前内存块剩余空间足够
            p-&amp;gt;d.last = m + size; //最后使用位置更新，剩余空间变小

            return m;
        }

        p = p-&amp;gt;d.next;

    } while (p);

    //现有小块内存均无法分配，则新建内存块后再分配
    return ngx_palloc_block(pool, size);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;新建小内存块再分配&#34;&gt;新建小内存块再分配&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 再次申请小块内存，并挂载到小块内存链表上，并返回当次申请的内存指针
*/
static void *
ngx_palloc_block(ngx_pool_t *pool, size_t size)
{
    u_char      *m;
    size_t       psize;
    ngx_pool_t  *p, *new;

    psize = (size_t) (pool-&amp;gt;d.end - (u_char *) pool);

    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&amp;gt;log);
    if (m == NULL) {
        return NULL;
    }

    new = (ngx_pool_t *) m;

    new-&amp;gt;d.end = m + psize;
    new-&amp;gt;d.next = NULL;
    new-&amp;gt;d.failed = 0;

    m += sizeof(ngx_pool_data_t);
    m = ngx_align_ptr(m, NGX_ALIGNMENT);
    new-&amp;gt;d.last = m + size;

    for (p = pool-&amp;gt;current; p-&amp;gt;d.next; p = p-&amp;gt;d.next) {
        //调整各个内存块分配失败次数，如果失败次数大于4，则此块内存节点不再使用
        if (p-&amp;gt;d.failed++ &amp;gt; 4) {
            pool-&amp;gt;current = p-&amp;gt;d.next;
        }
    }

    p-&amp;gt;d.next = new;

    return m;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;分配大内存&#34;&gt;分配大内存&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 分配大内存块
 */
static void *
ngx_palloc_large(ngx_pool_t *pool, size_t size)
{
    void              *p;
    ngx_uint_t         n;
    ngx_pool_large_t  *large;

    p = ngx_alloc(size, pool-&amp;gt;log); //向系统申请size大小堆内存
    if (p == NULL) {
        return NULL;
    }

    n = 0;

    //查找一个空的large区，如果有，则将分配的空间p交由它管理（最多3次）
    for (large = pool-&amp;gt;large; large; large = large-&amp;gt;next) {
        if (large-&amp;gt;alloc == NULL) { //ngx_pfree函数会产生空的large区
            large-&amp;gt;alloc = p;
            return p;
        }

        if (n++ &amp;gt; 3) { //超过一定次数，放弃查找空的large区
            break;
        }
    }

    //创建一个新的large节点
    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);
    if (large == NULL) {
        ngx_free(p);
        return NULL;
    }

    //新分配的空间p交由新建的large节点管理，并且插入到large链表头部
    large-&amp;gt;alloc = p;
    large-&amp;gt;next = pool-&amp;gt;large;
    pool-&amp;gt;large = large;

    return p;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;销毁内存池&#34;&gt;销毁内存池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 销毁内存池
 */
void
ngx_destroy_pool(ngx_pool_t *pool)
{
    ngx_pool_t          *p, *n;
    ngx_pool_large_t    *l;
    ngx_pool_cleanup_t  *c;

    for (c = pool-&amp;gt;cleanup; c; c = c-&amp;gt;next) {
        if (c-&amp;gt;handler) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,
                           &amp;quot;run cleanup: %p&amp;quot;, c);
            c-&amp;gt;handler(c-&amp;gt;data);
        }
    }

#if (NGX_DEBUG)

    /*
     * we could allocate the pool-&amp;gt;log from this pool
     * so we cannot use this log while free()ing the pool
     */

    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {
        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0, &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);
    }

    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {
        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,
                       &amp;quot;free: %p, unused: %uz&amp;quot;, p, p-&amp;gt;d.end - p-&amp;gt;d.last);

        if (n == NULL) {
            break;
        }
    }

#endif

    //释放大内存块（链表）
    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {
        if (l-&amp;gt;alloc) {
            ngx_free(l-&amp;gt;alloc);
        }
    }

    //释放小内存块 (链表)
    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {
        ngx_free(p);

        if (n == NULL) {
            break;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;重置内存池&#34;&gt;重置内存池&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 重置内存池
 * 1. 释放大块内存
 * 2. 重置可开始分配位置指针、分配失败次数为0、可用小内存块current指针指向首个内存块
 */
void
ngx_reset_pool(ngx_pool_t *pool)
{
    ngx_pool_t        *p;
    ngx_pool_large_t  *l;

    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) { //遍历大块内存链表，释放内存
        if (l-&amp;gt;alloc) {
            ngx_free(l-&amp;gt;alloc);
        }
    }

    for (p = pool; p; p = p-&amp;gt;d.next) {
        p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //恢复至初始为位置
        p-&amp;gt;d.failed = 0; //分配失败次数重置为0
    }

    pool-&amp;gt;current = pool; //current指向首个内存块
    pool-&amp;gt;chain = NULL;
    pool-&amp;gt;large = NULL;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;回收大块内存链表上的某个节点内存&#34;&gt;回收大块内存链表上的某个节点内存&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;/*
 * 回收大块内存链表上的某个节点内存
 */
ngx_int_t
ngx_pfree(ngx_pool_t *pool, void *p)
{
    ngx_pool_large_t  *l;

    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {
        if (p == l-&amp;gt;alloc) {
            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,
                           &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);
            ngx_free(l-&amp;gt;alloc);
            l-&amp;gt;alloc = NULL;

            return NGX_OK;
        }
    }

    return NGX_DECLINED;
}
&lt;/code&gt;&lt;/pre&gt;
">Nginx源码分析之--内存池</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/gperftools-fen-xi-nginx/"" data-c="
          &lt;h2 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;yum install libunwind-devel graphviz-devel ghostscript automake libtool -y&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;编译gpreftools&#34;&gt;编译gpreftools&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;源代码：https://github.com/gperftools/gperftools/archive/gperftools-2.7.tar.gz&lt;/li&gt;
&lt;li&gt;编译安装
&lt;ul&gt;
&lt;li&gt;./autogen.sh&lt;/li&gt;
&lt;li&gt;./configure&lt;/li&gt;
&lt;li&gt;make &amp;amp;&amp;amp; make install&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;导出LD_LIBRARY_PATH
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;export LD_LIBRARY_PATH=&amp;quot;$LD_LIBRARY_PATH:/usr/local/lib&amp;quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;nginx使用tcmalloc和启用google_perftools_module模块&#34;&gt;nginx使用tcmalloc和启用google_perftools_module模块&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;--with-ld-opt=-ltcmalloc --with-google_perftools_module&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
">gperftools分析Nginx</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/tcp-xie-yi/"" data-c="
          &lt;p&gt;本文是对tcp协议基础知识的整理介绍。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;tcp建连-断连&#34;&gt;tcp建连、断连&lt;/h2&gt;
&lt;h3 id=&#34;示意图&#34;&gt;示意图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;1&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1586241639078.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;为什么需要三次握手&#34;&gt;为什么需要三次握手？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;防止失效的连接请求到达服务器。&lt;/li&gt;
&lt;li&gt;具体描述：如果client发送的连接请求SYN包在网络中滞留了较长时间，server最终仍会收到并发回连接确认SYN+ACK。而client等待一个超时时间后，认为刚才滞留的连接请求包丢失了，则会重新发送SYN包发起连接请求。如果不进行第三次握手，那么server收到滞留的SYN包就打开的连接是无效的；如果有第三次握手，那么client会忽略server对滞留的SYN包的响应SYN+ACK，不回复ACK包，server收不到第三次握手ACK包就不会新建连接。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;tcp面向连接什么含义&#34;&gt;tcp面向连接什么含义？&lt;/h3&gt;
&lt;p&gt;为了在client和server间维护连接，需建立一定的数据结构来维护双方的交互状态，用这样的数据结构来保证面向连接的特性。&lt;/p&gt;
&lt;h3 id=&#34;为什么需要四次挥手&#34;&gt;为什么需要四次挥手？&lt;/h3&gt;
&lt;p&gt;一端发送FIN包请求释放连接，对端收到这个FIN报文后进入了&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态。这个状态下，仍然可以向对方发送未发送完毕的数据，数据发送完毕后也要向对端发送FIN报文释放连接，忘了发FIN包(调用close())会导致bug。也就是说，TCP是全双工传输，两端都必须发送FIN包，才能完全断开连接。&lt;/p&gt;
&lt;h3 id=&#34;time_wait状态&#34;&gt;TIME_WAIT状态&lt;/h3&gt;
&lt;p&gt;主动发送FIN包的一端，在收到对端的FIN报文后进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，这个状态一般要保持一个较长的时间2MSL。原因如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保最后一个应答FIN的报文ACK能够到达。因为如果对端没有收到ACK应答，则会重发FIN包。&lt;/li&gt;
&lt;li&gt;让当前连接在网络中可能的所有报文达到生存期上限后消失，使得下一个新的连接不会收到旧的连接的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三次握手内核实现原理示意图&#34;&gt;三次握手内核实现原理示意图&lt;/h2&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;2&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1586239797212.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
&lt;h3 id=&#34;队列长度配置&#34;&gt;队列长度配置&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SYN队列长度配置: &lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态连接的最大个数&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;ACCEPT队列长度：
&lt;ul&gt;
&lt;li&gt;系统全局： &lt;code&gt;net.core.somaxconn = 262144 #系统全局ACCPET队列最大长度的配置&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;应用层: socket API listen传参控制&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syn攻击&#34;&gt;SYN攻击&lt;/h3&gt;
&lt;p&gt;攻击者迅速伪造不同IP地址的SYN报文，快速占满SYN队列，使得正常的SYN包无法加入队列。&lt;/p&gt;
&lt;h4 id=&#34;应对syn攻击的参数&#34;&gt;应对SYN攻击的参数&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;net.core.netdev_max_backlog = 262144 #接收自网卡、但是未被内核协议栈处理的IP报文队列长度&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_abort_on_overflow = 1 #设置为1时表示: 队列满则响应RST包，丢弃连接&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&#34;tcp_syncookies&#34;&gt;tcp_syncookies&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1 #启用tcp cookie, 使得SYN队列满仍能建立连接&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;控制tcp三次握手的参数&#34;&gt;控制TCP三次握手的参数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SYN_SENT状态&lt;br&gt;
&lt;code&gt;net.ip4.tcp_syn_retries = 6 #主动建立连接，发送SYN的重试次数&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.ip_local_port_range = 32768 60999 #建立连接时的本地端口可选范围&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SYN_RCVD状态&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;
&lt;code&gt;net.ipv4.tcp_synack_retries = 3 #被动建立连接时，发送SYN/ACK的重试次数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;tfotcp-fast-open&#34;&gt;TFO(TCP Fast Open)&lt;/h2&gt;
&lt;p&gt;配置: &lt;code&gt;net.ipv4.tcp_fastopen&lt;/code&gt;。（&lt;strong&gt;注意&lt;/strong&gt;：内核版本要求在Linux 3.7以上）&lt;br&gt;
可选值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;0: 关闭(默认)&lt;/li&gt;
&lt;li&gt;1: 作为客户端时可以使用TFO&lt;/li&gt;
&lt;li&gt;2: 作为服务端时可以使用TFO&lt;/li&gt;
&lt;li&gt;3: 都可以使用TFO，无论是作为服务端还是客户端&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;示意图-2&#34;&gt;示意图&lt;/h3&gt;
&lt;figure data-type=&#34;image&#34; tabindex=&#34;3&#34;&gt;&lt;img src=&#34;https://xly0713.github.io/post-images/1586580242109.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/figure&gt;
">TCP协议基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/dns/"" data-c="
          &lt;p&gt;本文是对DNS协议的简单整理介绍。&lt;/p&gt;
&lt;!-- more --&gt;
&lt;h2 id=&#34;dns是什么&#34;&gt;DNS是什么？&lt;/h2&gt;
&lt;p&gt;DNS是互联网世界的地址薄，类似于电话本，主要提供将域名映射到IP地址的功能。&lt;/p&gt;
&lt;h2 id=&#34;dns的树状层次结构&#34;&gt;DNS的树状层次结构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;第一层: 根DNS服务器，负责返回顶级DNS(TLD)服务器的IP地址。目前全世界有13台服务节点。&lt;/li&gt;
&lt;li&gt;第二层: TLD服务器，负责返回权威DNS服务器的IP地址。&lt;/li&gt;
&lt;li&gt;第三层: 权威DNS服务器，负责返回相应主机或域名的IP地址。&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1586003718190.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns的解析流程&#34;&gt;DNS的解析流程&lt;/h2&gt;
&lt;p&gt;在未命中缓存的情况下，DNS完成域名的解析需要经过如下步骤:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户在浏览器中输入“example.com”, 查询由本地DNS服务(&lt;strong&gt;递归服务器&lt;/strong&gt;)解析器接收。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;查询&lt;strong&gt;根DNS域名服务器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;根DNS服务器&lt;/strong&gt;使用&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;(例如.com或.net)的地址响应给&lt;strong&gt;递归服务器&lt;/strong&gt;。如：“example.com”，则返回.com TLD的IP地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向.com&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;发出请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;响应&lt;strong&gt;权威DNS服务器&lt;/strong&gt;的IP地址。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向&lt;strong&gt;权威DNS服务器&lt;/strong&gt;翻出请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;权威DNS服务器&lt;/strong&gt;响应example.com的IP地址给&lt;strong&gt;递归服务器&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;递归DNS服务器&lt;/strong&gt;将example.com的IP地址响应给浏览器。（&lt;em&gt;DNS解析完成&lt;/em&gt;）&lt;/li&gt;
&lt;li&gt;浏览器向example.com的IP地址发出HTTP请求...&lt;br&gt;
&lt;img src=&#34;https://xly0713.github.io/post-images/1586005095657.png&#34; alt=&#34;&#34; loading=&#34;lazy&#34;&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dns缓存&#34;&gt;DNS缓存&lt;/h2&gt;
&lt;p&gt;在未命中缓存的情形下，DNS解析的流程是复杂且耗时的。DNS数据可以被缓存在多个位置，每个位置可以在一段时间内(记录生存时间TTL)缓存DNS数据记录:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器DNS缓存&lt;/li&gt;
&lt;li&gt;操作系统级DNS缓存&lt;/li&gt;
&lt;li&gt;递归DNS服务器级别缓存。&lt;em&gt;如果域名缓存未命中，但是命中了该域名的NS记录，则跳过请求根和TLD服务器；如果没有NS记录，但是命中了TLD的记录，则跳过请求根服务器；如果没有命中TLD的记录，则要完整走完迭代访问根DNS服务器到权威服务器这一全流程了。&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns记录类型&#34;&gt;DNS记录类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;常见类型：&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;A记录: 域名映射的IPv4地址。&lt;/li&gt;
&lt;li&gt;CNAME记录：域名别名映射，将域名指向另外一个域名。&lt;/li&gt;
&lt;li&gt;NS记录：域名映射的权威服务器记录。&lt;/li&gt;
&lt;li&gt;AAAA记录：域名映射的IPv6地址。&lt;/li&gt;
&lt;li&gt;MX记录：域名映射的邮箱服务器地址。&lt;/li&gt;
&lt;li&gt;TXT记录：允许管理员在记录中存储文本。&lt;/li&gt;
&lt;li&gt;SOA记录：存储有关域的管理员信息。&lt;/li&gt;
&lt;li&gt;SRV记录：指定特定服务的端口。&lt;/li&gt;
&lt;li&gt;PTR记录：在反向查询中提供域名。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;dns协议报文格式&#34;&gt;DNS协议报文格式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://jocent.me/2017/06/18/dns-protocol-principle.html&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;胶水记录glue-record&#34;&gt;胶水记录(Glue record)&lt;/h2&gt;
&lt;p&gt;当给&lt;strong&gt;域名A&lt;/strong&gt;配置NS记录时，如果NS记录为&lt;strong&gt;域名A&lt;/strong&gt;的子域名，则必须配置NS记录的A记录。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通常需要在域名提供商哪里申请两个域名，而不建议采用胶水记录方式。&lt;/li&gt;
&lt;li&gt;参考链接：https://www.jianshu.com/p/7d69ec2976c7&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dns优秀的go开源项目&#34;&gt;DNS优秀的go开源项目&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;https://github.com/miekg/dns&lt;/li&gt;
&lt;li&gt;https://github.com/abh/geodns （使用miekg/dns）&lt;/li&gt;
&lt;/ul&gt;
">DNS协议基础</a>
      </div>
      
      <div class="item">
        <a class="result-title" href="https://xly0713.github.io/post/about/"" data-c="
          &lt;blockquote&gt;
&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关于本站&#34;&gt;🏠 关于本站&lt;/h2&gt;
&lt;p&gt;本站主要用来记录一些技术，帮助自己整理零碎的知识，希望对他人有所帮助。欢迎&lt;a href=&#34;/atom.xml&#34;&gt;RSS&lt;/a&gt;订阅本站。&lt;/p&gt;
&lt;h2 id=&#34;博主是谁&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;
&lt;p&gt;博主是一名后台研发攻城狮，关注云计算相关领域，目前专注于CDN技术和直播技术。&lt;/p&gt;
&lt;h2 id=&#34;联系我呀&#34;&gt;📬 联系我呀&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;邮件: xly880713@gmail.com&lt;/li&gt;
&lt;/ul&gt;
">关于</a>
      </div>
      
    </div>
  </div>
</div>
<script>
  // var escape = "[{&#34;content&#34;:&#34;&lt;p&gt;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;http框架初始化流程图\&#34;&gt;http框架初始化流程图&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1589099904999.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h2 id=\&#34;结合流程简图和代码描述总体流程\&#34;&gt;结合流程简图和代码描述总体流程&lt;/h2&gt;\n&lt;p&gt;当配置文件nginx.conf配置了http{...}并被解析到时，http框架通过执行ngx_http_block函数开始初始化：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;static char *\nngx_http_block(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    char                        *rv;\n    ngx_uint_t                   mi, m, s;\n    ngx_conf_t                   pcf;\n    ngx_http_module_t           *module;\n    ngx_http_conf_ctx_t         *ctx;\n    ngx_http_core_loc_conf_t    *clcf;\n    ngx_http_core_srv_conf_t   **cscfp;\n    ngx_http_core_main_conf_t   *cmcf;\n\n    if (*(ngx_http_conf_ctx_t **) conf) {\n        return &amp;quot;is duplicate&amp;quot;;\n    }\n\n    /* the main http context */\n\n    ctx = ngx_pcalloc(cf-&amp;gt;pool, sizeof(ngx_http_conf_ctx_t));\n    if (ctx == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    *(ngx_http_conf_ctx_t **) conf = ctx;\n\n    /*初始化所有HTTP模块的ctx_index序号*/\n    ngx_http_max_module = ngx_count_modules(cf-&amp;gt;cycle, NGX_HTTP_MODULE);\n\n    /*分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组main_conf、srv_conf、loc_conf*/\n    ctx-&amp;gt;main_conf = ngx_pcalloc(cf-&amp;gt;pool,\n                                 sizeof(void *) * ngx_http_max_module);\n    if (ctx-&amp;gt;main_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx-&amp;gt;srv_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);\n    if (ctx-&amp;gt;srv_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ctx-&amp;gt;loc_conf = ngx_pcalloc(cf-&amp;gt;pool, sizeof(void *) * ngx_http_max_module);\n    if (ctx-&amp;gt;loc_conf == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    /*\n     * 处理http{}块内的main级别配置时，对每个HTTP模块，都会调用create_(main|srv|loc)_conf等3个方法\n     */\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue; //跳过非http模块\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;\n\n        if (module-&amp;gt;create_main_conf) {\n            ctx-&amp;gt;main_conf[mi] = module-&amp;gt;create_main_conf(cf); //main级别\n            if (ctx-&amp;gt;main_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&amp;gt;create_srv_conf) {\n            ctx-&amp;gt;srv_conf[mi] = module-&amp;gt;create_srv_conf(cf); //server级别\n            if (ctx-&amp;gt;srv_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n\n        if (module-&amp;gt;create_loc_conf) {\n            ctx-&amp;gt;loc_conf[mi] = module-&amp;gt;create_loc_conf(cf); //location级别\n            if (ctx-&amp;gt;loc_conf[mi] == NULL) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    pcf = *cf;\n    cf-&amp;gt;ctx = ctx;\n\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue;\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n\n        if (module-&amp;gt;preconfiguration) {\n            if (module-&amp;gt;preconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    /* 解析http{} main配置 */\n    cf-&amp;gt;module_type = NGX_HTTP_MODULE;\n    cf-&amp;gt;cmd_type = NGX_HTTP_MAIN_CONF;\n    rv = ngx_conf_parse(cf, NULL); //解析内部配置\n\n    if (rv != NGX_CONF_OK) {\n        goto failed;\n    }\n\n    cmcf = ctx-&amp;gt;main_conf[ngx_http_core_module.ctx_index];\n    cscfp = cmcf-&amp;gt;servers.elts;\n\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue;\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n        mi = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx_index;\n\n        //调用所有HTTP模块的init_main_conf方法，保存main级别配置\n        if (module-&amp;gt;init_main_conf) {\n            rv = module-&amp;gt;init_main_conf(cf, ctx-&amp;gt;main_conf[mi]);\n            if (rv != NGX_CONF_OK) {\n                goto failed;\n            }\n        }\n\n        //合并ngx_modules[m]模块main、srv、loc配置\n        rv = ngx_http_merge_servers(cf, cmcf, module, mi);\n        if (rv != NGX_CONF_OK) {\n            goto failed;\n        }\n    }\n\n    /* 构造location组成的静态二叉平衡查找树 */\n    for (s = 0; s &amp;lt; cmcf-&amp;gt;servers.nelts; s++) {\n\n        clcf = cscfp[s]-&amp;gt;ctx-&amp;gt;loc_conf[ngx_http_core_module.ctx_index];\n\n        //将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序\n        if (ngx_http_init_locations(cf, cscfp[s], clcf) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        //根据已经排序过的的双向链表，构建静态的二叉查找树\n        if (ngx_http_init_static_location_trees(cf, clcf) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n    }\n\n    /* 初始化可添加处理方法的HTTP阶段的动态数组 */\n    if (ngx_http_init_phases(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    if (ngx_http_init_headers_in_hash(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /* 调用所有HTTP模块的postconfiguration方法，使之可以介入HTTP请求处理阶段 */\n    for (m = 0; cf-&amp;gt;cycle-&amp;gt;modules[m]; m++) {\n        if (cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;type != NGX_HTTP_MODULE) {\n            continue;\n        }\n\n        module = cf-&amp;gt;cycle-&amp;gt;modules[m]-&amp;gt;ctx;\n\n        if (module-&amp;gt;postconfiguration) {\n            if (module-&amp;gt;postconfiguration(cf) != NGX_OK) {\n                return NGX_CONF_ERROR;\n            }\n        }\n    }\n\n    if (ngx_http_variables_init_vars(cf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    /*\n     * http{}&#39;s cf-&amp;gt;ctx was needed while the configuration merging\n     * and in postconfiguration process\n     */\n\n    *cf = pcf;\n\n    //根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组\n    if (ngx_http_init_phase_handlers(cf, cmcf) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n\n    //构造监听端口与server间的关联关系，设置新连接事件的回调方法\n    if (ngx_http_optimize_servers(cf, cmcf, cmcf-&amp;gt;ports) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    return NGX_CONF_OK;\n\nfailed:\n\n    *cf = pcf;\n\n    return rv;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;初始化所有http模块的ctx_index序号\&#34;&gt;初始化所有HTTP模块的ctx_index序号&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;ctx_index表示模块在同类型模块中的索引，比如ngx_http_core_module是HTTP模块（NGX_HTTP_MODULE）的首个模块，那么该模块的ctx_index为0。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;分配解析http块下main级别配置项时存放http模块结构体指针的3个数组\&#34;&gt;分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;分配main_conf数组用于保存各个HTTP模块在main级别可能创建的xx_main_conf_t结构体&lt;/li&gt;\n&lt;li&gt;分配srv_conf数组用于保存各个HTTP模块在main级别可能创建的xx_srv_conf_t结构体&lt;/li&gt;\n&lt;li&gt;分配loc_conf数组用于保存各个HTTP模块在main级别可能创建的xx_loc_conf_t结构体&lt;/li&gt;\n&lt;li&gt;另外，必须同时创建3个数组。因为对于HTTP模块来说，某个指令有可能同时出现在main、srv、loc级别。实际应用配置项时，具体以那个级别的配置项为准，需要合并处理。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;依次调用所有http模块的create_mainsrvloc_conf共3个方法\&#34;&gt;依次调用所有HTTP模块的create_(main|srv|loc)_conf共3个方法&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的这3个回调方法，如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用create_main_conf，分配每个HTTP模块main级别的xx_main_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;li&gt;调用create_srv_conf，分配每个HTTP模块main级别的xx_srv_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;li&gt;调用create_loc_conf，分配每个HTTP模块main级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用所有http模块的preconfiguration方法\&#34;&gt;调用所有HTTP模块的preconfiguration方法&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;preconfiguration&lt;/code&gt;回调方法，如果实现，则:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用preconfiguration方法, 一般用于添加变量&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;解析http块下的所有main级别配置项\&#34;&gt;解析http{}块下的所有main级别配置项&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;交由conf模块解析http{}块下的配置\n&lt;ul&gt;\n&lt;li&gt;特别的，如果内部碰到server{}块时，则会分配srv_conf、loc_conf数组分别用于保存各个HTTP模块在server级别可能创建的xx_srv_conf_t、xx_loc_conf_t结构体。然后调用create_srv_conf、create_loc_conf分配每个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体内存，并对字段赋初始值\n&lt;ul&gt;\n&lt;li&gt;特别的，如果内部碰到location{}块时，则会分配loc_conf数组分别用于保存各个HTTP模块在location级别可能创建的xx_loc_conf_t结构体。然后调用create_loc_conf分配每个HTTP模块在location级别的xx_loc_conf_t结构体内存，并对字段赋初始值&lt;/li&gt;\n&lt;li&gt;location{}下的配置解析完，则各个HTTP模块在location级别的xxx_loc_conf_t结构体赋值完成&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;server{}下的配置解析完，则各个HTTP模块在server级别的xx_(srv|loc)_conf_t结构体赋值完成&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用所有http模块的init_main_conf方法\&#34;&gt;调用所有HTTP模块的init_main_conf方法&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的init_main_conf回调方法, 如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;配置解析完成后，调用init_main_conf方法，最终确定并保存各个HTTP模块在main级别的xx_main_conf_t配置结构体&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;合并main-srv-loc级别下server-location相关的配置项\&#34;&gt;合并main、srv、loc级别下server、location相关的配置项&lt;/h3&gt;\n&lt;p&gt;对每一server{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_srv_conf和merge_loc_conf回调方法, 如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用merge_srv_conf和merge_loc_conf方法，最终确定并保存各个HTTP模块在server级别的xx_(srv|loc)_conf_t配置结构体&lt;/li&gt;\n&lt;/ul&gt;\n&lt;p&gt;对于每一个location{}而言，每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的merge_loc_conf回调方法, 如果实现, 则:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用merge_loc_conf方法，最终确定并保存各个HTTP模块在location级别的xx_loc_conf_t配置结构体&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构造location组成的静态二叉平衡查找树\&#34;&gt;构造location组成的静态二叉平衡查找树&lt;/h3&gt;\n&lt;p&gt;对于每一个server而言，&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;将ngx_http_core_loc_conf_t组成的双向链表按照location匹配字符串进行排序&lt;/li&gt;\n&lt;li&gt;根据已经排序过的的双向链表，构建静态的二叉查找树。这样处理请求时可以加速找到location&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;初始化可添加处理方法的http阶段的动态数组\&#34;&gt;初始化可添加处理方法的HTTP阶段的动态数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;http请求处理的11个阶段，分配数组，用于后续添加模块自定义的handler方法&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;调用所有http模块的postconfiguration方法使之可以介入http阶段\&#34;&gt;调用所有HTTP模块的postconfiguration方法使之可以介入HTTP阶段&lt;/h3&gt;\n&lt;p&gt;每个HTTP模块可以实现模块上下文&lt;code&gt;ngx_http_module_t&lt;/code&gt;的&lt;code&gt;postconfiguration&lt;/code&gt;方法，如果实现，则：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;调用postconfiguration，将handler方法添加到上一步常见的某个阶段(哪个阶段由模块自行决定，但只有7个阶段可以介入)的数组中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;根据各个http模块介入的处理方法构造出phase_engine_handlers数组\&#34;&gt;根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;根据前两步构造的的动态数组，调用&lt;code&gt;ngx_http_init_phase_handlers&lt;/code&gt;函数构造出phase_engine_handlers数组&lt;/li&gt;\n&lt;li&gt;特别的，有四个阶段不允许介入或者介入无效，分别是：&lt;code&gt;NGX_HTTP_FIND_CONFIG_PHASE&lt;/code&gt;、&lt;br&gt;\n&lt;code&gt;NGX_HTTP_POST_REWRITE_PHASE&lt;/code&gt;、&lt;code&gt;NGX_HTTP_POST_ACCESS_PHASE&lt;/code&gt;、&lt;br&gt;\n&lt;code&gt;NGX_HTTP_PRECONTENT_PHASE&lt;/code&gt;(旧的Nginx的try_files阶段)&lt;/li&gt;\n&lt;li&gt;特别的，&lt;code&gt;NGX_HTTP_CONTENT_PHASE&lt;/code&gt;阶段，除了常规的postconfiguration介入方式(这种方式影响所有的location)。另外可以直接以ngx_command_t指定location的handler方式介入，只对location有该指令的location生效&lt;/li&gt;\n&lt;li&gt;特别的,  记录http日志（最后一个阶段log）特殊处理，并不会出现在phase_engine_handlers数组中&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构造server虚拟主机构成的支持通配符的散列表\&#34;&gt;构造server虚拟主机构成的支持通配符的散列表&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;ngx_http_server_names&lt;/code&gt;将server虚拟主机和对应的ngx_http_core_srv_conf_t结构体指针哈希化关联起来，这样处理请求时可以快速匹配server&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;构造监听端口与server间的关联关系并设置新连接事件的回调方法\&#34;&gt;构造监听端口与server间的关联关系，并设置新连接事件的回调方法&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;将监听端口&lt;code&gt;ngx_http_conf_port_t&lt;/code&gt;和addr地址&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;关联&lt;/li&gt;\n&lt;li&gt;进一步，将&lt;code&gt;ngx_http_conf_addr_t&lt;/code&gt;和server虚拟主机关联。该结构体有3个哈希表结构字段，&lt;br&gt;\n分别用于索引完全匹配的sever_name、通配符前置、通配符后置的server虚拟主机结构体&lt;code&gt;ngx_http_core_srv_conf_t&lt;/code&gt;结构体指针&lt;/li&gt;\n&lt;li&gt;设置新连接事件的回调方法: &lt;code&gt;ngx_http_init_connection&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;http请求的11个阶段\&#34;&gt;http请求的11个阶段&lt;/h2&gt;\n&lt;h3 id=\&#34;构造phase_engine_handlers数组\&#34;&gt;构造phase_engine_handlers数组&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;ngx_http_init_phase_handlers函数在http初始化时调用&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;//根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组\nstatic ngx_int_t\nngx_http_init_phase_handlers(ngx_conf_t *cf, ngx_http_core_main_conf_t *cmcf)\n{\n    ngx_int_t                   j;\n    ngx_uint_t                  i, n;\n    ngx_uint_t                  find_config_index, use_rewrite, use_access;\n    ngx_http_handler_pt        *h;\n    ngx_http_phase_handler_t   *ph;\n    ngx_http_phase_handler_pt   checker;\n\n    cmcf-&amp;gt;phase_engine.server_rewrite_index = (ngx_uint_t) -1;\n    cmcf-&amp;gt;phase_engine.location_rewrite_index = (ngx_uint_t) -1;\n    find_config_index = 0;\n    use_rewrite = cmcf-&amp;gt;phases[NGX_HTTP_REWRITE_PHASE].handlers.nelts ? 1 : 0;\n    use_access = cmcf-&amp;gt;phases[NGX_HTTP_ACCESS_PHASE].handlers.nelts ? 1 : 0;\n\n    n = 1                  /* find config phase */\n        + use_rewrite      /* post rewrite phase */\n        + use_access;      /* post access phase */\n\n    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意:不包含NGX_HTTP_LOG_PHASE阶段,该阶段另行特殊处理\n        n += cmcf-&amp;gt;phases[i].handlers.nelts; //累加计算总的HTTP阶段处理方法个数\n    }\n\n    ph = ngx_pcalloc(cf-&amp;gt;pool,\n                     n * sizeof(ngx_http_phase_handler_t) + sizeof(void *));\n    if (ph == NULL) {\n        return NGX_ERROR;\n    }\n\n    cmcf-&amp;gt;phase_engine.handlers = ph;\n    n = 0;\n\n    for (i = 0; i &amp;lt; NGX_HTTP_LOG_PHASE; i++) { //注意: 不包含NGX_HTTP_LOG_PHASE阶段\n        h = cmcf-&amp;gt;phases[i].handlers.elts;\n\n        switch (i) {\n\n        case NGX_HTTP_SERVER_REWRITE_PHASE:\n            if (cmcf-&amp;gt;phase_engine.server_rewrite_index == (ngx_uint_t) -1) {\n                cmcf-&amp;gt;phase_engine.server_rewrite_index = n;\n            }\n            checker = ngx_http_core_rewrite_phase;\n\n            break;\n\n        case NGX_HTTP_FIND_CONFIG_PHASE:\n            find_config_index = n;\n\n            ph-&amp;gt;checker = ngx_http_core_find_config_phase;\n            n++;\n            ph++;\n\n            continue;\n\n        case NGX_HTTP_REWRITE_PHASE:\n            if (cmcf-&amp;gt;phase_engine.location_rewrite_index == (ngx_uint_t) -1) {\n                cmcf-&amp;gt;phase_engine.location_rewrite_index = n;\n            }\n            checker = ngx_http_core_rewrite_phase;\n\n            break;\n\n        case NGX_HTTP_POST_REWRITE_PHASE:\n            if (use_rewrite) {\n                ph-&amp;gt;checker = ngx_http_core_post_rewrite_phase;\n                ph-&amp;gt;next = find_config_index;\n                n++;\n                ph++;\n            }\n\n            continue;\n\n        case NGX_HTTP_ACCESS_PHASE:\n            checker = ngx_http_core_access_phase;\n            n++;\n            break;\n\n        case NGX_HTTP_POST_ACCESS_PHASE:\n            if (use_access) {\n                ph-&amp;gt;checker = ngx_http_core_post_access_phase;\n                ph-&amp;gt;next = n;\n                ph++;\n            }\n\n            continue;\n\n        case NGX_HTTP_CONTENT_PHASE:\n            checker = ngx_http_core_content_phase;\n            break;\n\n        default: //NGX_HTTP_POST_READ_PHASE、NGX_HTTP_PREACCESS_PHASE、NGX_HTTP_PRECONTENT_PHASE\n            checker = ngx_http_core_generic_phase;\n        }\n\n        n += cmcf-&amp;gt;phases[i].handlers.nelts; //跳过本阶段的所有handler, 也即下一阶段的首个handler\n\n        //注意:每个HTTP处理阶段中最后加入到handlers[]中的会首先添加到cmcf-&amp;gt;phase_engine.handlers\n        for (j = cmcf-&amp;gt;phases[i].handlers.nelts - 1; j &amp;gt;= 0; j--) {\n            ph-&amp;gt;checker = checker;\n            ph-&amp;gt;handler = h[j];\n            ph-&amp;gt;next = n; //下一阶段的首个handler序号\n            ph++;\n        }\n    }\n\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;checker方法\&#34;&gt;checker方法&lt;/h3&gt;\n&lt;h4 id=\&#34;ngx_http_core_generic_phase\&#34;&gt;ngx_http_core_generic_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_(POST_READ | PREACCESS | PRECONTENT)_PHASE等阶段的checker方法\n */\nngx_int_t\nngx_http_core_generic_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t  rc;\n\n    /*\n     * generic phase checker,\n     * used by the post read and pre-access phases\n     */\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;generic phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    //调用HTTP模块添加的handler处理方法(由各个HTTP模块的postconfiguration钩子函数添加)\n    rc = ph-&amp;gt;handler(r);\n\n    if (rc == NGX_OK) {\n        r-&amp;gt;phase_handler = ph-&amp;gt;next; //rc为NGX_OK时，进入下一阶段就行处理, 当前阶段即使有其他处理方法也会跳过\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_DECLINED) {\n        r-&amp;gt;phase_handler++; //下一个处理方法，可能仍是当前阶段，也有可能是下一个阶段的首个处理方法\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_AGAIN || rc == NGX_DONE) {\n        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块\n    }\n\n    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */\n\n    ngx_http_finalize_request(r, rc); //返回错误NGX_ERROR或者NGX_HTTP_开头的返回码，则结束请求\n\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_rewrite_phase\&#34;&gt;ngx_http_core_rewrite_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_(SERVER_REWRITE | REWRITE)_PHASE等阶段的checker方法\n */\nngx_int_t\nngx_http_core_rewrite_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t  rc;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    rc = ph-&amp;gt;handler(r); //执行挂载的handler方法\n\n    if (rc == NGX_DECLINED) {\n        r-&amp;gt;phase_handler++; //当前处理方法执行完毕，执行下一个处理方法\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_DONE) {\n        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块\n    }\n\n    /* NGX_OK, NGX_AGAIN, NGX_ERROR, NGX_HTTP_...  */\n\n    ngx_http_finalize_request(r, rc); //结束请求\n\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_find_config_phase\&#34;&gt;ngx_http_core_find_config_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 根据请求的URI寻找匹配的location表达式，不允许用户模块介入。即使介入也无效，因为入参ph未使用\n */\nngx_int_t\nngx_http_core_find_config_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    u_char                    *p;\n    size_t                     len;\n    ngx_int_t                  rc;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    r-&amp;gt;content_handler = NULL;\n    r-&amp;gt;uri_changed = 0;\n\n    rc = ngx_http_core_find_location(r);\n\n    if (rc == NGX_ERROR) {\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (!r-&amp;gt;internal &amp;amp;&amp;amp; clcf-&amp;gt;internal) {\n        ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND);\n        return NGX_OK;\n    }\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;using configuration \\&amp;quot;%s%V\\&amp;quot;&amp;quot;,\n                   (clcf-&amp;gt;noname ? &amp;quot;*&amp;quot; : (clcf-&amp;gt;exact_match ? &amp;quot;=&amp;quot; : &amp;quot;&amp;quot;)),\n                   &amp;amp;clcf-&amp;gt;name);\n\n    ngx_http_update_location_config(r);\n\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;http cl:%O max:%O&amp;quot;,\n                   r-&amp;gt;headers_in.content_length_n, clcf-&amp;gt;client_max_body_size);\n\n    if (r-&amp;gt;headers_in.content_length_n != -1\n        &amp;amp;&amp;amp; !r-&amp;gt;discard_body\n        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size\n        &amp;amp;&amp;amp; clcf-&amp;gt;client_max_body_size &amp;lt; r-&amp;gt;headers_in.content_length_n)\n    {\n        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                      &amp;quot;client intended to send too large body: %O bytes&amp;quot;,\n                      r-&amp;gt;headers_in.content_length_n);\n\n        r-&amp;gt;expect_tested = 1;\n        (void) ngx_http_discard_request_body(r);\n        ngx_http_finalize_request(r, NGX_HTTP_REQUEST_ENTITY_TOO_LARGE);\n        return NGX_OK;\n    }\n\n    if (rc == NGX_DONE) {\n        ngx_http_clear_location(r);\n\n        r-&amp;gt;headers_out.location = ngx_list_push(&amp;amp;r-&amp;gt;headers_out.headers);\n        if (r-&amp;gt;headers_out.location == NULL) {\n            ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n            return NGX_OK;\n        }\n\n        r-&amp;gt;headers_out.location-&amp;gt;hash = 1;\n        ngx_str_set(&amp;amp;r-&amp;gt;headers_out.location-&amp;gt;key, &amp;quot;Location&amp;quot;);\n\n        if (r-&amp;gt;args.len == 0) {\n            r-&amp;gt;headers_out.location-&amp;gt;value = clcf-&amp;gt;name;\n\n        } else {\n            len = clcf-&amp;gt;name.len + 1 + r-&amp;gt;args.len;\n            p = ngx_pnalloc(r-&amp;gt;pool, len);\n\n            if (p == NULL) {\n                ngx_http_clear_location(r);\n                ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n                return NGX_OK;\n            }\n\n            r-&amp;gt;headers_out.location-&amp;gt;value.len = len;\n            r-&amp;gt;headers_out.location-&amp;gt;value.data = p;\n\n            p = ngx_cpymem(p, clcf-&amp;gt;name.data, clcf-&amp;gt;name.len);\n            *p++ = &#39;?&#39;;\n            ngx_memcpy(p, r-&amp;gt;args.data, r-&amp;gt;args.len);\n        }\n\n        ngx_http_finalize_request(r, NGX_HTTP_MOVED_PERMANENTLY);\n        return NGX_OK;\n    }\n\n    r-&amp;gt;phase_handler++; //下一阶段\n    return NGX_AGAIN;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_post_rewrite_phase\&#34;&gt;ngx_http_core_post_rewrite_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_POST_REWRITE_PHASE阶段的checker方法\n */\nngx_int_t\nngx_http_core_post_rewrite_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    ngx_http_core_srv_conf_t  *cscf;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;post rewrite phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    if (!r-&amp;gt;uri_changed) {\n        r-&amp;gt;phase_handler++;\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;uri changes: %d&amp;quot;, r-&amp;gt;uri_changes);\n\n    /*\n     * gcc before 3.3 compiles the broken code for\n     *     if (r-&amp;gt;uri_changes-- == 0)\n     * if the r-&amp;gt;uri_changes is defined as\n     *     unsigned  uri_changes:4\n     */\n\n    r-&amp;gt;uri_changes--;\n\n    if (r-&amp;gt;uri_changes == 0) { //url改写次数超限，结束请求\n        ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                      &amp;quot;rewrite or internal redirection cycle &amp;quot;\n                      &amp;quot;while processing \\&amp;quot;%V\\&amp;quot;&amp;quot;, &amp;amp;r-&amp;gt;uri);\n\n        ngx_http_finalize_request(r, NGX_HTTP_INTERNAL_SERVER_ERROR);\n        return NGX_OK;\n    }\n\n    r-&amp;gt;phase_handler = ph-&amp;gt;next;\n\n    cscf = ngx_http_get_module_srv_conf(r, ngx_http_core_module);\n    r-&amp;gt;loc_conf = cscf-&amp;gt;ctx-&amp;gt;loc_conf;\n\n    return NGX_AGAIN;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_access_phase\&#34;&gt;ngx_http_core_access_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_ACCESS_PHASE阶段的checker方法\n */\nngx_int_t\nngx_http_core_access_phase(ngx_http_request_t *r, ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t                  rc;\n    ngx_http_core_loc_conf_t  *clcf;\n\n    if (r != r-&amp;gt;main) { //子请求\n        r-&amp;gt;phase_handler = ph-&amp;gt;next; //跳到下一个阶段\n        return NGX_AGAIN;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    rc = ph-&amp;gt;handler(r); //执行模块挂载的handler方法\n\n    if (rc == NGX_DECLINED) {\n        r-&amp;gt;phase_handler++; //下一个处理方法\n        return NGX_AGAIN;\n    }\n\n    if (rc == NGX_AGAIN || rc == NGX_DONE) {\n        return NGX_OK; //不更改r-&amp;gt;phase_handler的值，当前处理方法有机会再次被调用。但是必须把控制权交还event模块\n    }\n\n    clcf = ngx_http_get_module_loc_conf(r, ngx_http_core_module);\n\n    if (clcf-&amp;gt;satisfy == NGX_HTTP_SATISFY_ALL) {\n\n        if (rc == NGX_OK) {\n            r-&amp;gt;phase_handler++; //satisfy all, 则执行下一个handler方法\n            return NGX_AGAIN;\n        }\n\n    } else { //satisfy any\n        if (rc == NGX_OK) {\n            r-&amp;gt;access_code = 0;\n\n            if (r-&amp;gt;headers_out.www_authenticate) {\n                r-&amp;gt;headers_out.www_authenticate-&amp;gt;hash = 0;\n            }\n\n            r-&amp;gt;phase_handler = ph-&amp;gt;next; //satisfy any, 则跳到下一个阶段\n            return NGX_AGAIN;\n        }\n\n        if (rc == NGX_HTTP_FORBIDDEN || rc == NGX_HTTP_UNAUTHORIZED) {\n            if (r-&amp;gt;access_code != NGX_HTTP_UNAUTHORIZED) {\n                r-&amp;gt;access_code = rc;\n            }\n\n            r-&amp;gt;phase_handler++; //下一个handler方法\n            return NGX_AGAIN;\n        }\n    }\n\n    /* rc == NGX_ERROR || rc == NGX_HTTP_...  */\n\n    ngx_http_finalize_request(r, rc); //结束请求\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_post_access_phase\&#34;&gt;ngx_http_core_post_access_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_POST_ACCESS_PHASE阶段的checker方法, 入参ph未使用，即不允许介入\n */\nngx_int_t\nngx_http_core_post_access_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    ngx_int_t  access_code;\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;post access phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    access_code = r-&amp;gt;access_code;\n\n    if (access_code) { //access_code非0，表明没有访问权限\n        if (access_code == NGX_HTTP_FORBIDDEN) {\n            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                          &amp;quot;access forbidden by rule&amp;quot;);\n        }\n\n        r-&amp;gt;access_code = 0;\n        ngx_http_finalize_request(r, access_code);\n        return NGX_OK;\n    }\n\n    r-&amp;gt;phase_handler++;\n    return NGX_AGAIN;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h4 id=\&#34;ngx_http_core_content_phase\&#34;&gt;ngx_http_core_content_phase&lt;/h4&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * NGX_HTTP_CONTENT_PHASE阶段的checker方法\n */\nngx_int_t\nngx_http_core_content_phase(ngx_http_request_t *r,\n    ngx_http_phase_handler_t *ph)\n{\n    size_t     root;\n    ngx_int_t  rc;\n    ngx_str_t  path;\n\n    if (r-&amp;gt;content_handler) { //介入的特殊方式: 某location特有的handler方法, 不影响其他location\n        r-&amp;gt;write_event_handler = ngx_http_request_empty_handler;\n        ngx_http_finalize_request(r, r-&amp;gt;content_handler(r));\n        return NGX_OK;\n    }\n\n    ngx_log_debug1(NGX_LOG_DEBUG_HTTP, r-&amp;gt;connection-&amp;gt;log, 0,\n                   &amp;quot;content phase: %ui&amp;quot;, r-&amp;gt;phase_handler);\n\n    rc = ph-&amp;gt;handler(r); //执行postconfiguration钩子函数添加的handler方法\n\n    if (rc != NGX_DECLINED) {\n        ngx_http_finalize_request(r, rc);\n        return NGX_OK;\n    }\n\n    /* rc == NGX_DECLINED */\n\n    ph++;\n\n    if (ph-&amp;gt;checker) {\n        r-&amp;gt;phase_handler++; //下一个handler方法\n        return NGX_AGAIN;\n    }\n\n    /* no content handler was found */\n\n    if (r-&amp;gt;uri.data[r-&amp;gt;uri.len - 1] == &#39;/&#39;) {\n\n        if (ngx_http_map_uri_to_path(r, &amp;amp;path, &amp;amp;root, 0) != NULL) {\n            ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0,\n                          &amp;quot;directory index of \\&amp;quot;%s\\&amp;quot; is forbidden&amp;quot;, path.data);\n        }\n\n        ngx_http_finalize_request(r, NGX_HTTP_FORBIDDEN);\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_ERR, r-&amp;gt;connection-&amp;gt;log, 0, &amp;quot;no handler found&amp;quot;);\n\n    ngx_http_finalize_request(r, NGX_HTTP_NOT_FOUND); //404\n    return NGX_OK;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;处理请求经过10个阶段\&#34;&gt;处理请求经过10个阶段&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 10个阶段处理HTTP请求\n */\nvoid\nngx_http_core_run_phases(ngx_http_request_t *r)\n{\n    ngx_int_t                   rc;\n    ngx_http_phase_handler_t   *ph;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    ph = cmcf-&amp;gt;phase_engine.handlers;\n\n    while (ph[r-&amp;gt;phase_handler].checker) {\n\n        rc = ph[r-&amp;gt;phase_handler].checker(r, &amp;amp;ph[r-&amp;gt;phase_handler]);\n\n        if (rc == NGX_OK) {\n            return;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;记录http日志阶段特殊处理\&#34;&gt;记录http日志阶段特殊处理&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 记录访问日志。log阶段的handler链并不是在ngx_http_core_run_phases函数中执行, 它只需在请求处理逻辑结束后才执行一次\n */\nstatic void\nngx_http_log_request(ngx_http_request_t *r)\n{\n    ngx_uint_t                  i, n;\n    ngx_http_handler_pt        *log_handler;\n    ngx_http_core_main_conf_t  *cmcf;\n\n    cmcf = ngx_http_get_module_main_conf(r, ngx_http_core_module);\n\n    log_handler = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.elts;\n    n = cmcf-&amp;gt;phases[NGX_HTTP_LOG_PHASE].handlers.nelts;\n\n    for (i = 0; i &amp;lt; n; i++) {\n        log_handler[i](r);\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-yuan-ma-fen-xi-zhi-http-kuang-jia&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx源码分析之--http框架&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Nginx&#34;,&#34;slug&#34;:&#34;ZUZBgmRmp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/ZUZBgmRmp/&#34;},{&#34;name&#34;:&#34;源码分析&#34;,&#34;slug&#34;:&#34;1FH1KPhrG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/1FH1KPhrG/&#34;}],&#34;date&#34;:&#34;2020-05-10 11:33:32&#34;,&#34;dateFormat&#34;:&#34;2020-05-10&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/nginx-yuan-ma-fen-xi-zhi-http-kuang-jia/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;20 min read&#34;,&#34;time&#34;:1156000,&#34;words&#34;:4089,&#34;minutes&#34;:20},&#34;description&#34;:&#34;Nginx的http功能和模块使用广泛，那么Nginx的http框架是如何初始化的呢？http请求的11个处理阶段又是怎么设计的呢？\n\nhttp框架初始化流程图\n\n结合流程简图和代码描述总体流程\n当配置文件nginx.conf配置了http...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#http%E6%A1%86%E6%9E%B6%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B%E5%9B%BE\&#34;&gt;http框架初始化流程图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E5%90%88%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE%E5%92%8C%E4%BB%A3%E7%A0%81%E6%8F%8F%E8%BF%B0%E6%80%BB%E4%BD%93%E6%B5%81%E7%A8%8B\&#34;&gt;结合流程简图和代码描述总体流程&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84ctx_index%E5%BA%8F%E5%8F%B7\&#34;&gt;初始化所有HTTP模块的ctx_index序号&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%85%8D%E8%A7%A3%E6%9E%90http%E5%9D%97%E4%B8%8Bmain%E7%BA%A7%E5%88%AB%E9%85%8D%E7%BD%AE%E9%A1%B9%E6%97%B6%E5%AD%98%E6%94%BEhttp%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88%E7%9A%843%E4%B8%AA%E6%95%B0%E7%BB%84\&#34;&gt;分配解析http{}块下main级别配置项时存放HTTP模块结构体指针的3个数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BE%9D%E6%AC%A1%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84create_mainsrvloc_conf%E5%85%B13%E4%B8%AA%E6%96%B9%E6%B3%95\&#34;&gt;依次调用所有HTTP模块的create_(main|srv|loc)_conf共3个方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84preconfiguration%E6%96%B9%E6%B3%95\&#34;&gt;调用所有HTTP模块的preconfiguration方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%A7%A3%E6%9E%90http%E5%9D%97%E4%B8%8B%E7%9A%84%E6%89%80%E6%9C%89main%E7%BA%A7%E5%88%AB%E9%85%8D%E7%BD%AE%E9%A1%B9\&#34;&gt;解析http{}块下的所有main级别配置项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84init_main_conf%E6%96%B9%E6%B3%95\&#34;&gt;调用所有HTTP模块的init_main_conf方法&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%90%88%E5%B9%B6main-srv-loc%E7%BA%A7%E5%88%AB%E4%B8%8Bserver-location%E7%9B%B8%E5%85%B3%E7%9A%84%E9%85%8D%E7%BD%AE%E9%A1%B9\&#34;&gt;合并main、srv、loc级别下server、location相关的配置项&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0location%E7%BB%84%E6%88%90%E7%9A%84%E9%9D%99%E6%80%81%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%9F%A5%E6%89%BE%E6%A0%91\&#34;&gt;构造location组成的静态二叉平衡查找树&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%AF%E6%B7%BB%E5%8A%A0%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E7%9A%84http%E9%98%B6%E6%AE%B5%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84\&#34;&gt;初始化可添加处理方法的HTTP阶段的动态数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%B0%83%E7%94%A8%E6%89%80%E6%9C%89http%E6%A8%A1%E5%9D%97%E7%9A%84postconfiguration%E6%96%B9%E6%B3%95%E4%BD%BF%E4%B9%8B%E5%8F%AF%E4%BB%A5%E4%BB%8B%E5%85%A5http%E9%98%B6%E6%AE%B5\&#34;&gt;调用所有HTTP模块的postconfiguration方法使之可以介入HTTP阶段&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B9%E6%8D%AE%E5%90%84%E4%B8%AAhttp%E6%A8%A1%E5%9D%97%E4%BB%8B%E5%85%A5%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95%E6%9E%84%E9%80%A0%E5%87%BAphase_engine_handlers%E6%95%B0%E7%BB%84\&#34;&gt;根据各个HTTP模块介入的处理方法构造出phase_engine_handlers数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0server%E8%99%9A%E6%8B%9F%E4%B8%BB%E6%9C%BA%E6%9E%84%E6%88%90%E7%9A%84%E6%94%AF%E6%8C%81%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8\&#34;&gt;构造server虚拟主机构成的支持通配符的散列表&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0%E7%9B%91%E5%90%AC%E7%AB%AF%E5%8F%A3%E4%B8%8Eserver%E9%97%B4%E7%9A%84%E5%85%B3%E8%81%94%E5%85%B3%E7%B3%BB%E5%B9%B6%E8%AE%BE%E7%BD%AE%E6%96%B0%E8%BF%9E%E6%8E%A5%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E6%96%B9%E6%B3%95\&#34;&gt;构造监听端口与server间的关联关系，并设置新连接事件的回调方法&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#http%E8%AF%B7%E6%B1%82%E7%9A%8411%E4%B8%AA%E9%98%B6%E6%AE%B5\&#34;&gt;http请求的11个阶段&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E9%80%A0phase_engine_handlers%E6%95%B0%E7%BB%84\&#34;&gt;构造phase_engine_handlers数组&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#checker%E6%96%B9%E6%B3%95\&#34;&gt;checker方法&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_generic_phase\&#34;&gt;ngx_http_core_generic_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_rewrite_phase\&#34;&gt;ngx_http_core_rewrite_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_find_config_phase\&#34;&gt;ngx_http_core_find_config_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_post_rewrite_phase\&#34;&gt;ngx_http_core_post_rewrite_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_access_phase\&#34;&gt;ngx_http_core_access_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_post_access_phase\&#34;&gt;ngx_http_core_post_access_phase&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#ngx_http_core_content_phase\&#34;&gt;ngx_http_core_content_phase&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%A4%84%E7%90%86%E8%AF%B7%E6%B1%82%E7%BB%8F%E8%BF%8710%E4%B8%AA%E9%98%B6%E6%AE%B5\&#34;&gt;处理请求经过10个阶段&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%AE%B0%E5%BD%95http%E6%97%A5%E5%BF%97%E9%98%B6%E6%AE%B5%E7%89%B9%E6%AE%8A%E5%A4%84%E7%90%86\&#34;&gt;记录http日志阶段特殊处理&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;zsh替换bash，可以让命令行操作更高效。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;安装zsh\&#34;&gt;安装zsh&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;yum install zsh -y\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装oh-my-zsh\&#34;&gt;安装oh-my-zsh&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;安装zsh-autosuggestions插件\&#34;&gt;安装zsh-autosuggestions插件&lt;/h2&gt;\n&lt;pre&gt;&lt;code&gt;git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;修改~zshrc文件\&#34;&gt;修改~/.zshrc文件&lt;/h2&gt;\n&lt;p&gt;找到plugins变量，增加zsh-autosuggestions，如下：&lt;/p&gt;\n&lt;pre&gt;&lt;code&gt;plugins=(zsh-autosuggestions)\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;zsh-ti-dai-bash&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;zsh替换bash，可以让命令行操作更高效。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;zsh替代bash&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;效率工具&#34;,&#34;slug&#34;:&#34;xiao-lu-gong-ju&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/xiao-lu-gong-ju/&#34;}],&#34;date&#34;:&#34;2020-05-01 21:26:09&#34;,&#34;dateFormat&#34;:&#34;2020-05-01&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/zsh-ti-dai-bash/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:25000,&#34;words&#34;:84,&#34;minutes&#34;:1},&#34;description&#34;:&#34;zsh替换bash，可以让命令行操作更高效。\n\n安装zsh\nyum install zsh -y\n\n安装oh-my-zsh\nsh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/oh...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85zsh\&#34;&gt;安装zsh&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85oh-my-zsh\&#34;&gt;安装oh-my-zsh&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85zsh-autosuggestions%E6%8F%92%E4%BB%B6\&#34;&gt;安装zsh-autosuggestions插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BF%AE%E6%94%B9~zshrc%E6%96%87%E4%BB%B6\&#34;&gt;修改~/.zshrc文件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;本文是对ATS的安装、配置、日志等相关基础知识的整理。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;安装-以trafficserver-805版本为例\&#34;&gt;安装 （以trafficserver-8.0.5版本为例）&lt;/h2&gt;\n&lt;h3 id=\&#34;下载源代码并解压\&#34;&gt;下载源代码并解压&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget\nwget https://mirror.bit.edu.cn/apache/trafficserver/trafficserver-8.0.5.tar.bz2\ntar xf trafficserver-8.0.5.tar.bz2\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;准备c17编译环境\&#34;&gt;准备c++17编译环境&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install centos-release-scl\nyum -y install yum-utils\nyum-config-manager --enable rhel-server-rhscl-7-rpms\nyum -y install devtoolset-7\n\nscl enable devtoolset-7 zsh\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装tcl-dev-package\&#34;&gt;安装TCL dev package&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install tcl-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装openssl-devel\&#34;&gt;安装openssl-devel&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install openssl-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装lua-devel\&#34;&gt;安装lua-devel&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install lua-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;安装ncurses-devel\&#34;&gt;安装ncurses-devel&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install ncurses-devel\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;生成makefile\&#34;&gt;生成Makefile&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;./configure --prefix=/opt/ats\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;构建-测试-安装\&#34;&gt;构建、测试、安装&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;make\nmake test\nmake install\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;汇总安装步骤\&#34;&gt;汇总安装步骤&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;yum -y install bzip2 wget tcl-devel openssl-devel lua-devel  ncurses-devel \nyum -y install centos-release-scl yum-utils\nyum-config-manager --enable rhel-server-rhscl-7-rpms\nyum -y install devtoolset-7\nscl enable devtoolset-7 zsh\n\n./configure --prefix=/opt/ats\nmake\nmake test\nmake install\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;配置\&#34;&gt;配置&lt;/h2&gt;\n&lt;h3 id=\&#34;核心配置文件recordsconfig\&#34;&gt;核心配置文件records.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;li&gt;特别的，可以配置启用UI方便查看ATS运行时关键信息、检索和删除缓存等&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;反向代理回源映射配置文件remapconfig\&#34;&gt;反向代理回源映射配置文件remap.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;缓存相关配置文件cacheconfig\&#34;&gt;缓存相关配置文件cache.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;存储配置storageconfig\&#34;&gt;存储配置storage.config&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;暂略，待补充&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;日志\&#34;&gt;日志&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;在records.config中配置日志路径、分割方式等&lt;/li&gt;\n&lt;li&gt;squid风格的日志，使用traffic_logcat查看&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;插件\&#34;&gt;插件&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;https://github.com/portl4t/ts-lua\&#34;&gt;lua插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://docs.trafficserver.apache.org/en/8.0.x/admin-guide/plugins/index.en.html\&#34;&gt;官方插件&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;https://docs.trafficserver.apache.org/en/8.0.x/developer-guide/plugins/index.en.html\&#34;&gt;插件开发指南&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;ats-ru-men&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;本文是对ATS的安装、配置、日志等相关基础知识的整理。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;ATS入门&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Cache&#34;,&#34;slug&#34;:&#34;cache&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/cache/&#34;},{&#34;name&#34;:&#34;CDN&#34;,&#34;slug&#34;:&#34;cdn&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/cdn/&#34;}],&#34;date&#34;:&#34;2020-04-12 12:00:50&#34;,&#34;dateFormat&#34;:&#34;2020-04-12&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/ats-ru-men/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;2 min read&#34;,&#34;time&#34;:98000,&#34;words&#34;:348,&#34;minutes&#34;:2},&#34;description&#34;:&#34;本文是对ATS的安装、配置、日志等相关基础知识的整理。\n\n安装 （以trafficserver-8.0.5版本为例）\n下载源代码并解压\nyum -y install bzip2 wget\nwget https://mirror.bit.ed...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85-%E4%BB%A5trafficserver-805%E7%89%88%E6%9C%AC%E4%B8%BA%E4%BE%8B\&#34;&gt;安装 （以trafficserver-8.0.5版本为例）&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%8B%E8%BD%BD%E6%BA%90%E4%BB%A3%E7%A0%81%E5%B9%B6%E8%A7%A3%E5%8E%8B\&#34;&gt;下载源代码并解压&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%87%86%E5%A4%87c17%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83\&#34;&gt;准备c++17编译环境&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85tcl-dev-package\&#34;&gt;安装TCL dev package&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85openssl-devel\&#34;&gt;安装openssl-devel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85lua-devel\&#34;&gt;安装lua-devel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85ncurses-devel\&#34;&gt;安装ncurses-devel&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%94%9F%E6%88%90makefile\&#34;&gt;生成Makefile&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%9E%84%E5%BB%BA-%E6%B5%8B%E8%AF%95-%E5%AE%89%E8%A3%85\&#34;&gt;构建、测试、安装&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%B1%87%E6%80%BB%E5%AE%89%E8%A3%85%E6%AD%A5%E9%AA%A4\&#34;&gt;汇总安装步骤&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%85%8D%E7%BD%AE\&#34;&gt;配置&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6recordsconfig\&#34;&gt;核心配置文件records.config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E5%9B%9E%E6%BA%90%E6%98%A0%E5%B0%84%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6remapconfig\&#34;&gt;反向代理回源映射配置文件remap.config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%93%E5%AD%98%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6cacheconfig\&#34;&gt;缓存相关配置文件cache.config&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AD%98%E5%82%A8%E9%85%8D%E7%BD%AEstorageconfig\&#34;&gt;存储配置storage.config&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%97%A5%E5%BF%97\&#34;&gt;日志&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8F%92%E4%BB%B6\&#34;&gt;插件&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;Nginx作为高性能的web服务器，它是如何管理内存的呢？&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;内存池的优点\&#34;&gt;内存池的优点&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;pool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;&lt;/li&gt;\n&lt;li&gt;内存统一分配和回收，避免内存泄漏；&lt;/li&gt;\n&lt;li&gt;整块分配，避免内存过于碎片化;&lt;/li&gt;\n&lt;li&gt;内存对齐处理，减少CPU读取内存次数，提高寻址效率；&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;内存池相关的数据结构\&#34;&gt;内存池相关的数据结构&lt;/h2&gt;\n&lt;h3 id=\&#34;结构体示意图\&#34;&gt;结构体示意图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1587183416580.jpg\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;数据结构定义\&#34;&gt;数据结构定义&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;typedef struct ngx_pool_s            ngx_pool_t;\ntypedef struct ngx_pool_large_s  ngx_pool_large_t;\n\nstruct ngx_pool_s { //内存池头部结构\n    ngx_pool_data_t       d;        //内存池的数据区，即真正分配内存的区域\n    size_t                max;      //每次可分配最大内存，用于判定是走大内存分配还是小内存分配逻辑\n    ngx_pool_t           *current;  //指向当前内存池小块内存可用的首个节点\n    ngx_chain_t          *chain;    //缓冲区链表\n    ngx_pool_large_t     *large;    //内存块大于max内存块的链表\n    ngx_pool_cleanup_t   *cleanup;  //销毁内存池回调函数\n    ngx_log_t            *log;      //错误日志指针\n};\n\ntypedef struct {\n    u_char               *last;     //当前内存块已使用到此处，下一次使用从此处开始\n    u_char               *end;      //内存块结束位置\n    ngx_pool_t           *next;     //内存池有很多内存块，通过next指针组成链表\n    ngx_uint_t            failed;   //内存块分配失败次数\n} ngx_pool_data_t; //小内存块(链表)\n\n//大内存块(链表)\nstruct ngx_pool_large_s {\n    ngx_pool_large_t     *next;  //下一数据块地址\n    void                 *alloc; //当前数据块地址\n};\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h2 id=\&#34;内存池主要函数\&#34;&gt;内存池主要函数&lt;/h2&gt;\n&lt;h3 id=\&#34;新建内存池\&#34;&gt;新建内存池&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 新建一个内存池\n */\nngx_pool_t *\nngx_create_pool(size_t size, ngx_log_t *log)\n{\n    ngx_pool_t  *p;\n\n    //调用系统内存分配函数，分配一块堆内存，且做对齐处理\n    p = ngx_memalign(NGX_POOL_ALIGNMENT, size, log);\n    if (p == NULL) {\n        return NULL;\n    }\n\n    p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t);\n    p-&amp;gt;d.end = (u_char *) p + size;\n    p-&amp;gt;d.next = NULL;\n    p-&amp;gt;d.failed = 0;\n\n    size = size - sizeof(ngx_pool_t);\n    //max最大为pagesize-1(比如:x86时为4095), 即：无论小块内存空间是否足够，超过pagesize-1大小的内存均走large块分配\n    p-&amp;gt;max = (size &amp;lt; NGX_MAX_ALLOC_FROM_POOL) ? size : NGX_MAX_ALLOC_FROM_POOL;\n\n    p-&amp;gt;current = p;\n    p-&amp;gt;chain = NULL;\n    p-&amp;gt;large = NULL;\n    p-&amp;gt;cleanup = NULL;\n    p-&amp;gt;log = log;\n\n    return p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;从内存池申请内存\&#34;&gt;从内存池申请内存&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;先对齐再分配内存&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 从内存池中申请一块内存\n * （1）如果申请的内存小于定义的max，则从内存池中分配内存，需先对齐再分配\n * （2）否则分配大块内存挂载到large指针上\n */\nvoid *\nngx_palloc(ngx_pool_t *pool, size_t size)\n{\n#if !(NGX_DEBUG_PALLOC)\n    if (size &amp;lt;= pool-&amp;gt;max) {\n        return ngx_palloc_small(pool, size, 1); //小块内存(先对齐)\n    }\n#endif\n\n    return ngx_palloc_large(pool, size);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;先对齐再分配内存, 并填充0&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 从内存池中申请内存，并填充0\n */\nvoid *\nngx_pcalloc(ngx_pool_t *pool, size_t size)\n{\n    void *p;\n\n    p = ngx_palloc(pool, size);\n    if (p) {\n        ngx_memzero(p, size);\n    }\n\n    return p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;ul&gt;\n&lt;li&gt;不用对齐分配内存&lt;/li&gt;\n&lt;/ul&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 从内存池中申请一块内存 （小块内存无需先对齐）\n */\nvoid *\nngx_pnalloc(ngx_pool_t *pool, size_t size)\n{\n#if !(NGX_DEBUG_PALLOC)\n    if (size &amp;lt;= pool-&amp;gt;max) {\n        return ngx_palloc_small(pool, size, 0); //小块内存（无需先对齐）\n    }\n#endif\n\n    return ngx_palloc_large(pool, size);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;从内存池申请内存小块内存\&#34;&gt;从内存池申请内存小块内存&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 分配小块内存\n * 1. 循环遍历内存块ngx_pool_data_t链表\n * 2. 如果当前内存块剩余大小满足申请的内存大小，则移动相应指针，返回分配的内存指针\n * 3. 否则，移动到下一个内存块\n * 4. 如果所有内存块都没能满足申请的内存大小，则重新申请一块内存块挂载到链表上，并返回分配的内存地址\n */\nstatic ngx_inline void *\nngx_palloc_small(ngx_pool_t *pool, size_t size, ngx_uint_t align)\n{\n    u_char      *m;\n    ngx_pool_t  *p;\n\n    p = pool-&amp;gt;current;\n\n    do {\n        m = p-&amp;gt;d.last; //最后使用位置\n\n        if (align) {\n            m = ngx_align_ptr(m, NGX_ALIGNMENT); //先内存对齐, 减少CPU读取内存次数\n        }\n\n        if ((size_t) (p-&amp;gt;d.end - m) &amp;gt;= size) { //当前内存块剩余空间足够\n            p-&amp;gt;d.last = m + size; //最后使用位置更新，剩余空间变小\n\n            return m;\n        }\n\n        p = p-&amp;gt;d.next;\n\n    } while (p);\n\n    //现有小块内存均无法分配，则新建内存块后再分配\n    return ngx_palloc_block(pool, size);\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;新建小内存块再分配\&#34;&gt;新建小内存块再分配&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 再次申请小块内存，并挂载到小块内存链表上，并返回当次申请的内存指针\n*/\nstatic void *\nngx_palloc_block(ngx_pool_t *pool, size_t size)\n{\n    u_char      *m;\n    size_t       psize;\n    ngx_pool_t  *p, *new;\n\n    psize = (size_t) (pool-&amp;gt;d.end - (u_char *) pool);\n\n    m = ngx_memalign(NGX_POOL_ALIGNMENT, psize, pool-&amp;gt;log);\n    if (m == NULL) {\n        return NULL;\n    }\n\n    new = (ngx_pool_t *) m;\n\n    new-&amp;gt;d.end = m + psize;\n    new-&amp;gt;d.next = NULL;\n    new-&amp;gt;d.failed = 0;\n\n    m += sizeof(ngx_pool_data_t);\n    m = ngx_align_ptr(m, NGX_ALIGNMENT);\n    new-&amp;gt;d.last = m + size;\n\n    for (p = pool-&amp;gt;current; p-&amp;gt;d.next; p = p-&amp;gt;d.next) {\n        //调整各个内存块分配失败次数，如果失败次数大于4，则此块内存节点不再使用\n        if (p-&amp;gt;d.failed++ &amp;gt; 4) {\n            pool-&amp;gt;current = p-&amp;gt;d.next;\n        }\n    }\n\n    p-&amp;gt;d.next = new;\n\n    return m;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;分配大内存\&#34;&gt;分配大内存&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 分配大内存块\n */\nstatic void *\nngx_palloc_large(ngx_pool_t *pool, size_t size)\n{\n    void              *p;\n    ngx_uint_t         n;\n    ngx_pool_large_t  *large;\n\n    p = ngx_alloc(size, pool-&amp;gt;log); //向系统申请size大小堆内存\n    if (p == NULL) {\n        return NULL;\n    }\n\n    n = 0;\n\n    //查找一个空的large区，如果有，则将分配的空间p交由它管理（最多3次）\n    for (large = pool-&amp;gt;large; large; large = large-&amp;gt;next) {\n        if (large-&amp;gt;alloc == NULL) { //ngx_pfree函数会产生空的large区\n            large-&amp;gt;alloc = p;\n            return p;\n        }\n\n        if (n++ &amp;gt; 3) { //超过一定次数，放弃查找空的large区\n            break;\n        }\n    }\n\n    //创建一个新的large节点\n    large = ngx_palloc_small(pool, sizeof(ngx_pool_large_t), 1);\n    if (large == NULL) {\n        ngx_free(p);\n        return NULL;\n    }\n\n    //新分配的空间p交由新建的large节点管理，并且插入到large链表头部\n    large-&amp;gt;alloc = p;\n    large-&amp;gt;next = pool-&amp;gt;large;\n    pool-&amp;gt;large = large;\n\n    return p;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;销毁内存池\&#34;&gt;销毁内存池&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 销毁内存池\n */\nvoid\nngx_destroy_pool(ngx_pool_t *pool)\n{\n    ngx_pool_t          *p, *n;\n    ngx_pool_large_t    *l;\n    ngx_pool_cleanup_t  *c;\n\n    for (c = pool-&amp;gt;cleanup; c; c = c-&amp;gt;next) {\n        if (c-&amp;gt;handler) {\n            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,\n                           &amp;quot;run cleanup: %p&amp;quot;, c);\n            c-&amp;gt;handler(c-&amp;gt;data);\n        }\n    }\n\n#if (NGX_DEBUG)\n\n    /*\n     * we could allocate the pool-&amp;gt;log from this pool\n     * so we cannot use this log while free()ing the pool\n     */\n\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {\n        ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0, &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);\n    }\n\n    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {\n        ngx_log_debug2(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,\n                       &amp;quot;free: %p, unused: %uz&amp;quot;, p, p-&amp;gt;d.end - p-&amp;gt;d.last);\n\n        if (n == NULL) {\n            break;\n        }\n    }\n\n#endif\n\n    //释放大内存块（链表）\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {\n        if (l-&amp;gt;alloc) {\n            ngx_free(l-&amp;gt;alloc);\n        }\n    }\n\n    //释放小内存块 (链表)\n    for (p = pool, n = pool-&amp;gt;d.next; /* void */; p = n, n = n-&amp;gt;d.next) {\n        ngx_free(p);\n\n        if (n == NULL) {\n            break;\n        }\n    }\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;重置内存池\&#34;&gt;重置内存池&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 重置内存池\n * 1. 释放大块内存\n * 2. 重置可开始分配位置指针、分配失败次数为0、可用小内存块current指针指向首个内存块\n */\nvoid\nngx_reset_pool(ngx_pool_t *pool)\n{\n    ngx_pool_t        *p;\n    ngx_pool_large_t  *l;\n\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) { //遍历大块内存链表，释放内存\n        if (l-&amp;gt;alloc) {\n            ngx_free(l-&amp;gt;alloc);\n        }\n    }\n\n    for (p = pool; p; p = p-&amp;gt;d.next) {\n        p-&amp;gt;d.last = (u_char *) p + sizeof(ngx_pool_t); //恢复至初始为位置\n        p-&amp;gt;d.failed = 0; //分配失败次数重置为0\n    }\n\n    pool-&amp;gt;current = pool; //current指向首个内存块\n    pool-&amp;gt;chain = NULL;\n    pool-&amp;gt;large = NULL;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&lt;h3 id=\&#34;回收大块内存链表上的某个节点内存\&#34;&gt;回收大块内存链表上的某个节点内存&lt;/h3&gt;\n&lt;pre&gt;&lt;code&gt;/*\n * 回收大块内存链表上的某个节点内存\n */\nngx_int_t\nngx_pfree(ngx_pool_t *pool, void *p)\n{\n    ngx_pool_large_t  *l;\n\n    for (l = pool-&amp;gt;large; l; l = l-&amp;gt;next) {\n        if (p == l-&amp;gt;alloc) {\n            ngx_log_debug1(NGX_LOG_DEBUG_ALLOC, pool-&amp;gt;log, 0,\n                           &amp;quot;free: %p&amp;quot;, l-&amp;gt;alloc);\n            ngx_free(l-&amp;gt;alloc);\n            l-&amp;gt;alloc = NULL;\n\n            return NGX_OK;\n        }\n    }\n\n    return NGX_DECLINED;\n}\n&lt;/code&gt;&lt;/pre&gt;\n&#34;,&#34;fileName&#34;:&#34;nginx-yuan-ma-xue-xi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;Nginx作为高性能的web服务器，它是如何管理内存的呢？&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;Nginx源码分析之--内存池&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Nginx&#34;,&#34;slug&#34;:&#34;ZUZBgmRmp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/ZUZBgmRmp/&#34;},{&#34;name&#34;:&#34;源码分析&#34;,&#34;slug&#34;:&#34;1FH1KPhrG&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/1FH1KPhrG/&#34;}],&#34;date&#34;:&#34;2020-04-11 22:09:35&#34;,&#34;dateFormat&#34;:&#34;2020-04-11&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/nginx-yuan-ma-xue-xi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;9 min read&#34;,&#34;time&#34;:482000,&#34;words&#34;:1761,&#34;minutes&#34;:9},&#34;description&#34;:&#34;Nginx作为高性能的web服务器，它是如何管理内存的呢？\n\n内存池的优点\n\npool化处理，避免多次向系统申请内存，减少用户态和内核态切换，提高内存分配效率;\n内存统一分配和回收，避免内存泄漏；\n整块分配，避免内存过于碎片化;\n内存对齐处...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9A%84%E4%BC%98%E7%82%B9\&#34;&gt;内存池的优点&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84\&#34;&gt;内存池相关的数据结构&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BB%93%E6%9E%84%E4%BD%93%E7%A4%BA%E6%84%8F%E5%9B%BE\&#34;&gt;结构体示意图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89\&#34;&gt;数据结构定义&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%86%85%E5%AD%98%E6%B1%A0%E4%B8%BB%E8%A6%81%E5%87%BD%E6%95%B0\&#34;&gt;内存池主要函数&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%BB%BA%E5%86%85%E5%AD%98%E6%B1%A0\&#34;&gt;新建内存池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98\&#34;&gt;从内存池申请内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%BB%8E%E5%86%85%E5%AD%98%E6%B1%A0%E7%94%B3%E8%AF%B7%E5%86%85%E5%AD%98%E5%B0%8F%E5%9D%97%E5%86%85%E5%AD%98\&#34;&gt;从内存池申请内存小块内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%96%B0%E5%BB%BA%E5%B0%8F%E5%86%85%E5%AD%98%E5%9D%97%E5%86%8D%E5%88%86%E9%85%8D\&#34;&gt;新建小内存块再分配&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%88%86%E9%85%8D%E5%A4%A7%E5%86%85%E5%AD%98\&#34;&gt;分配大内存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%94%80%E6%AF%81%E5%86%85%E5%AD%98%E6%B1%A0\&#34;&gt;销毁内存池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%87%8D%E7%BD%AE%E5%86%85%E5%AD%98%E6%B1%A0\&#34;&gt;重置内存池&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%9B%9E%E6%94%B6%E5%A4%A7%E5%9D%97%E5%86%85%E5%AD%98%E9%93%BE%E8%A1%A8%E4%B8%8A%E7%9A%84%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E5%86%85%E5%AD%98\&#34;&gt;回收大块内存链表上的某个节点内存&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;h2 id=\&#34;安装依赖\&#34;&gt;安装依赖&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;yum install libunwind-devel graphviz-devel ghostscript automake libtool -y&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;编译gpreftools\&#34;&gt;编译gpreftools&lt;/h2&gt;\n&lt;ol&gt;\n&lt;li&gt;源代码：https://github.com/gperftools/gperftools/archive/gperftools-2.7.tar.gz&lt;/li&gt;\n&lt;li&gt;编译安装\n&lt;ul&gt;\n&lt;li&gt;./autogen.sh&lt;/li&gt;\n&lt;li&gt;./configure&lt;/li&gt;\n&lt;li&gt;make &amp;amp;&amp;amp; make install&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;导出LD_LIBRARY_PATH\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;export LD_LIBRARY_PATH=&amp;quot;$LD_LIBRARY_PATH:/usr/local/lib&amp;quot;&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;nginx使用tcmalloc和启用google_perftools_module模块\&#34;&gt;nginx使用tcmalloc和启用google_perftools_module模块&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;code&gt;--with-ld-opt=-ltcmalloc --with-google_perftools_module&lt;/code&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;gperftools-fen-xi-nginx&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;gperftools分析Nginx&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;Nginx&#34;,&#34;slug&#34;:&#34;ZUZBgmRmp&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/ZUZBgmRmp/&#34;}],&#34;date&#34;:&#34;2020-02-09 19:00:55&#34;,&#34;dateFormat&#34;:&#34;2020-02-09&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/gperftools-fen-xi-nginx/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:21000,&#34;words&#34;:68,&#34;minutes&#34;:1},&#34;description&#34;:&#34;安装依赖\n\nyum install libunwind-devel graphviz-devel ghostscript automake libtool -y\n\n编译gpreftools\n\n源代码：https://github.com/g...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96\&#34;&gt;安装依赖&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%BC%96%E8%AF%91gpreftools\&#34;&gt;编译gpreftools&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#nginx%E4%BD%BF%E7%94%A8tcmalloc%E5%92%8C%E5%90%AF%E7%94%A8google_perftools_module%E6%A8%A1%E5%9D%97\&#34;&gt;nginx使用tcmalloc和启用google_perftools_module模块&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;本文是对tcp协议基础知识的整理介绍。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;tcp建连-断连\&#34;&gt;tcp建连、断连&lt;/h2&gt;\n&lt;h3 id=\&#34;示意图\&#34;&gt;示意图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;1\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1586241639078.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;为什么需要三次握手\&#34;&gt;为什么需要三次握手？&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;防止失效的连接请求到达服务器。&lt;/li&gt;\n&lt;li&gt;具体描述：如果client发送的连接请求SYN包在网络中滞留了较长时间，server最终仍会收到并发回连接确认SYN+ACK。而client等待一个超时时间后，认为刚才滞留的连接请求包丢失了，则会重新发送SYN包发起连接请求。如果不进行第三次握手，那么server收到滞留的SYN包就打开的连接是无效的；如果有第三次握手，那么client会忽略server对滞留的SYN包的响应SYN+ACK，不回复ACK包，server收不到第三次握手ACK包就不会新建连接。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;tcp面向连接什么含义\&#34;&gt;tcp面向连接什么含义？&lt;/h3&gt;\n&lt;p&gt;为了在client和server间维护连接，需建立一定的数据结构来维护双方的交互状态，用这样的数据结构来保证面向连接的特性。&lt;/p&gt;\n&lt;h3 id=\&#34;为什么需要四次挥手\&#34;&gt;为什么需要四次挥手？&lt;/h3&gt;\n&lt;p&gt;一端发送FIN包请求释放连接，对端收到这个FIN报文后进入了&lt;code&gt;CLOSE_WAIT&lt;/code&gt;状态。这个状态下，仍然可以向对方发送未发送完毕的数据，数据发送完毕后也要向对端发送FIN报文释放连接，忘了发FIN包(调用close())会导致bug。也就是说，TCP是全双工传输，两端都必须发送FIN包，才能完全断开连接。&lt;/p&gt;\n&lt;h3 id=\&#34;time_wait状态\&#34;&gt;TIME_WAIT状态&lt;/h3&gt;\n&lt;p&gt;主动发送FIN包的一端，在收到对端的FIN报文后进入&lt;code&gt;TIME_WAIT&lt;/code&gt;状态，这个状态一般要保持一个较长的时间2MSL。原因如下：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;确保最后一个应答FIN的报文ACK能够到达。因为如果对端没有收到ACK应答，则会重发FIN包。&lt;/li&gt;\n&lt;li&gt;让当前连接在网络中可能的所有报文达到生存期上限后消失，使得下一个新的连接不会收到旧的连接的数据。&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;三次握手内核实现原理示意图\&#34;&gt;三次握手内核实现原理示意图&lt;/h2&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;2\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1586239797212.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&lt;h3 id=\&#34;队列长度配置\&#34;&gt;队列长度配置&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;SYN队列长度配置: &lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态连接的最大个数&lt;/code&gt;;&lt;/li&gt;\n&lt;li&gt;ACCEPT队列长度：\n&lt;ul&gt;\n&lt;li&gt;系统全局： &lt;code&gt;net.core.somaxconn = 262144 #系统全局ACCPET队列最大长度的配置&lt;/code&gt;&lt;/li&gt;\n&lt;li&gt;应用层: socket API listen传参控制&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;syn攻击\&#34;&gt;SYN攻击&lt;/h3&gt;\n&lt;p&gt;攻击者迅速伪造不同IP地址的SYN报文，快速占满SYN队列，使得正常的SYN包无法加入队列。&lt;/p&gt;\n&lt;h4 id=\&#34;应对syn攻击的参数\&#34;&gt;应对SYN攻击的参数&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;net.core.netdev_max_backlog = 262144 #接收自网卡、但是未被内核协议栈处理的IP报文队列长度&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_abort_on_overflow = 1 #设置为1时表示: 队列满则响应RST包，丢弃连接&lt;/code&gt;&lt;/p&gt;\n&lt;h4 id=\&#34;tcp_syncookies\&#34;&gt;tcp_syncookies&lt;/h4&gt;\n&lt;p&gt;&lt;code&gt;net.ipv4.tcp_syncookies = 1 #启用tcp cookie, 使得SYN队列满仍能建立连接&lt;/code&gt;&lt;/p&gt;\n&lt;h3 id=\&#34;控制tcp三次握手的参数\&#34;&gt;控制TCP三次握手的参数&lt;/h3&gt;\n&lt;ul&gt;\n&lt;li&gt;\n&lt;p&gt;SYN_SENT状态&lt;br&gt;\n&lt;code&gt;net.ip4.tcp_syn_retries = 6 #主动建立连接，发送SYN的重试次数&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.ip_local_port_range = 32768 60999 #建立连接时的本地端口可选范围&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;li&gt;\n&lt;p&gt;SYN_RCVD状态&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 8192 #SYN_RCVD状态(半)连接的最大个数&lt;/code&gt;&lt;br&gt;\n&lt;code&gt;net.ipv4.tcp_synack_retries = 3 #被动建立连接时，发送SYN/ACK的重试次数&lt;/code&gt;&lt;/p&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;tfotcp-fast-open\&#34;&gt;TFO(TCP Fast Open)&lt;/h2&gt;\n&lt;p&gt;配置: &lt;code&gt;net.ipv4.tcp_fastopen&lt;/code&gt;。（&lt;strong&gt;注意&lt;/strong&gt;：内核版本要求在Linux 3.7以上）&lt;br&gt;\n可选值：&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;0: 关闭(默认)&lt;/li&gt;\n&lt;li&gt;1: 作为客户端时可以使用TFO&lt;/li&gt;\n&lt;li&gt;2: 作为服务端时可以使用TFO&lt;/li&gt;\n&lt;li&gt;3: 都可以使用TFO，无论是作为服务端还是客户端&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h3 id=\&#34;示意图-2\&#34;&gt;示意图&lt;/h3&gt;\n&lt;figure data-type=\&#34;image\&#34; tabindex=\&#34;3\&#34;&gt;&lt;img src=\&#34;https://xly0713.github.io/post-images/1586580242109.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/figure&gt;\n&#34;,&#34;fileName&#34;:&#34;tcp-xie-yi&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;本文是对tcp协议基础知识的整理介绍。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;TCP协议基础&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;网络协议&#34;,&#34;slug&#34;:&#34;Q1k2X6rnU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/Q1k2X6rnU/&#34;}],&#34;date&#34;:&#34;2020-02-02 20:41:15&#34;,&#34;dateFormat&#34;:&#34;2020-02-02&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/tcp-xie-yi/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;4 min read&#34;,&#34;time&#34;:196000,&#34;words&#34;:882,&#34;minutes&#34;:4},&#34;description&#34;:&#34;本文是对tcp协议基础知识的整理介绍。\n\ntcp建连、断连\n示意图\n\n为什么需要三次握手？\n\n防止失效的连接请求到达服务器。\n具体描述：如果client发送的连接请求SYN包在网络中滞留了较长时间，server最终仍会收到并发回连接确认SY...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp%E5%BB%BA%E8%BF%9E-%E6%96%AD%E8%BF%9E\&#34;&gt;tcp建连、断连&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E6%84%8F%E5%9B%BE\&#34;&gt;示意图&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\&#34;&gt;为什么需要三次握手？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp%E9%9D%A2%E5%90%91%E8%BF%9E%E6%8E%A5%E4%BB%80%E4%B9%88%E5%90%AB%E4%B9%89\&#34;&gt;tcp面向连接什么含义？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\&#34;&gt;为什么需要四次挥手？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#time_wait%E7%8A%B6%E6%80%81\&#34;&gt;TIME_WAIT状态&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E7%A4%BA%E6%84%8F%E5%9B%BE\&#34;&gt;三次握手内核实现原理示意图&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E9%98%9F%E5%88%97%E9%95%BF%E5%BA%A6%E9%85%8D%E7%BD%AE\&#34;&gt;队列长度配置&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#syn%E6%94%BB%E5%87%BB\&#34;&gt;SYN攻击&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%BA%94%E5%AF%B9syn%E6%94%BB%E5%87%BB%E7%9A%84%E5%8F%82%E6%95%B0\&#34;&gt;应对SYN攻击的参数&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tcp_syncookies\&#34;&gt;tcp_syncookies&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E6%8E%A7%E5%88%B6tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%8F%82%E6%95%B0\&#34;&gt;控制TCP三次握手的参数&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#tfotcp-fast-open\&#34;&gt;TFO(TCP Fast Open)&lt;/a&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E7%A4%BA%E6%84%8F%E5%9B%BE-2\&#34;&gt;示意图&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;p&gt;本文是对DNS协议的简单整理介绍。&lt;/p&gt;\n&lt;!-- more --&gt;\n&lt;h2 id=\&#34;dns是什么\&#34;&gt;DNS是什么？&lt;/h2&gt;\n&lt;p&gt;DNS是互联网世界的地址薄，类似于电话本，主要提供将域名映射到IP地址的功能。&lt;/p&gt;\n&lt;h2 id=\&#34;dns的树状层次结构\&#34;&gt;DNS的树状层次结构&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;第一层: 根DNS服务器，负责返回顶级DNS(TLD)服务器的IP地址。目前全世界有13台服务节点。&lt;/li&gt;\n&lt;li&gt;第二层: TLD服务器，负责返回权威DNS服务器的IP地址。&lt;/li&gt;\n&lt;li&gt;第三层: 权威DNS服务器，负责返回相应主机或域名的IP地址。&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1586003718190.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dns的解析流程\&#34;&gt;DNS的解析流程&lt;/h2&gt;\n&lt;p&gt;在未命中缓存的情况下，DNS完成域名的解析需要经过如下步骤:&lt;/p&gt;\n&lt;ol&gt;\n&lt;li&gt;用户在浏览器中输入“example.com”, 查询由本地DNS服务(&lt;strong&gt;递归服务器&lt;/strong&gt;)解析器接收。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;查询&lt;strong&gt;根DNS域名服务器&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;根DNS服务器&lt;/strong&gt;使用&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;(例如.com或.net)的地址响应给&lt;strong&gt;递归服务器&lt;/strong&gt;。如：“example.com”，则返回.com TLD的IP地址。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向.com&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;发出请求。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;顶级DNS(TLD)服务器&lt;/strong&gt;响应&lt;strong&gt;权威DNS服务器&lt;/strong&gt;的IP地址。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归服务器&lt;/strong&gt;向&lt;strong&gt;权威DNS服务器&lt;/strong&gt;翻出请求。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;权威DNS服务器&lt;/strong&gt;响应example.com的IP地址给&lt;strong&gt;递归服务器&lt;/strong&gt;。&lt;/li&gt;\n&lt;li&gt;&lt;strong&gt;递归DNS服务器&lt;/strong&gt;将example.com的IP地址响应给浏览器。（&lt;em&gt;DNS解析完成&lt;/em&gt;）&lt;/li&gt;\n&lt;li&gt;浏览器向example.com的IP地址发出HTTP请求...&lt;br&gt;\n&lt;img src=\&#34;https://xly0713.github.io/post-images/1586005095657.png\&#34; alt=\&#34;\&#34; loading=\&#34;lazy\&#34;&gt;&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;dns缓存\&#34;&gt;DNS缓存&lt;/h2&gt;\n&lt;p&gt;在未命中缓存的情形下，DNS解析的流程是复杂且耗时的。DNS数据可以被缓存在多个位置，每个位置可以在一段时间内(记录生存时间TTL)缓存DNS数据记录:&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;浏览器DNS缓存&lt;/li&gt;\n&lt;li&gt;操作系统级DNS缓存&lt;/li&gt;\n&lt;li&gt;递归DNS服务器级别缓存。&lt;em&gt;如果域名缓存未命中，但是命中了该域名的NS记录，则跳过请求根和TLD服务器；如果没有NS记录，但是命中了TLD的记录，则跳过请求根服务器；如果没有命中TLD的记录，则要完整走完迭代访问根DNS服务器到权威服务器这一全流程了。&lt;/em&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dns记录类型\&#34;&gt;DNS记录类型&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;常见类型：&lt;/li&gt;\n&lt;/ul&gt;\n&lt;ol&gt;\n&lt;li&gt;A记录: 域名映射的IPv4地址。&lt;/li&gt;\n&lt;li&gt;CNAME记录：域名别名映射，将域名指向另外一个域名。&lt;/li&gt;\n&lt;li&gt;NS记录：域名映射的权威服务器记录。&lt;/li&gt;\n&lt;li&gt;AAAA记录：域名映射的IPv6地址。&lt;/li&gt;\n&lt;li&gt;MX记录：域名映射的邮箱服务器地址。&lt;/li&gt;\n&lt;li&gt;TXT记录：允许管理员在记录中存储文本。&lt;/li&gt;\n&lt;li&gt;SOA记录：存储有关域的管理员信息。&lt;/li&gt;\n&lt;li&gt;SRV记录：指定特定服务的端口。&lt;/li&gt;\n&lt;li&gt;PTR记录：在反向查询中提供域名。&lt;/li&gt;\n&lt;/ol&gt;\n&lt;h2 id=\&#34;dns协议报文格式\&#34;&gt;DNS协议报文格式&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;https://jocent.me/2017/06/18/dns-protocol-principle.html&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;胶水记录glue-record\&#34;&gt;胶水记录(Glue record)&lt;/h2&gt;\n&lt;p&gt;当给&lt;strong&gt;域名A&lt;/strong&gt;配置NS记录时，如果NS记录为&lt;strong&gt;域名A&lt;/strong&gt;的子域名，则必须配置NS记录的A记录。&lt;/p&gt;\n&lt;ul&gt;\n&lt;li&gt;通常需要在域名提供商哪里申请两个域名，而不建议采用胶水记录方式。&lt;/li&gt;\n&lt;li&gt;参考链接：https://www.jianshu.com/p/7d69ec2976c7&lt;/li&gt;\n&lt;/ul&gt;\n&lt;h2 id=\&#34;dns优秀的go开源项目\&#34;&gt;DNS优秀的go开源项目&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;https://github.com/miekg/dns&lt;/li&gt;\n&lt;li&gt;https://github.com/abh/geodns （使用miekg/dns）&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;dns&#34;,&#34;abstract&#34;:&#34;&lt;p&gt;本文是对DNS协议的简单整理介绍。&lt;/p&gt;\n&#34;,&#34;title&#34;:&#34;DNS协议基础&#34;,&#34;tags&#34;:[{&#34;name&#34;:&#34;网络协议&#34;,&#34;slug&#34;:&#34;Q1k2X6rnU&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/Q1k2X6rnU/&#34;},{&#34;name&#34;:&#34;GSLB&#34;,&#34;slug&#34;:&#34;pRwAbJURI&#34;,&#34;used&#34;:true,&#34;link&#34;:&#34;https://xly0713.github.io/tag/pRwAbJURI/&#34;}],&#34;date&#34;:&#34;2020-01-30 20:31:48&#34;,&#34;dateFormat&#34;:&#34;2020-01-30&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/dns/&#34;,&#34;hideInList&#34;:false,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;3 min read&#34;,&#34;time&#34;:176000,&#34;words&#34;:794,&#34;minutes&#34;:3},&#34;description&#34;:&#34;本文是对DNS协议的简单整理介绍。\n\nDNS是什么？\nDNS是互联网世界的地址薄，类似于电话本，主要提供将域名映射到IP地址的功能。\nDNS的树状层次结构\n\n第一层: 根DNS服务器，负责返回顶级DNS(TLD)服务器的IP地址。目前全世界...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E6%98%AF%E4%BB%80%E4%B9%88\&#34;&gt;DNS是什么？&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E7%9A%84%E6%A0%91%E7%8A%B6%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84\&#34;&gt;DNS的树状层次结构&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E7%9A%84%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B\&#34;&gt;DNS的解析流程&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E7%BC%93%E5%AD%98\&#34;&gt;DNS缓存&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E8%AE%B0%E5%BD%95%E7%B1%BB%E5%9E%8B\&#34;&gt;DNS记录类型&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F\&#34;&gt;DNS协议报文格式&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%83%B6%E6%B0%B4%E8%AE%B0%E5%BD%95glue-record\&#34;&gt;胶水记录(Glue record)&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#dns%E4%BC%98%E7%A7%80%E7%9A%84go%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE\&#34;&gt;DNS优秀的go开源项目&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;},{&#34;content&#34;:&#34;&lt;blockquote&gt;\n&lt;p&gt;欢迎来到我的小站呀，很高兴遇见你！🤝&lt;/p&gt;\n&lt;/blockquote&gt;\n&lt;h2 id=\&#34;关于本站\&#34;&gt;🏠 关于本站&lt;/h2&gt;\n&lt;p&gt;本站主要用来记录一些技术，帮助自己整理零碎的知识，希望对他人有所帮助。欢迎&lt;a href=\&#34;/atom.xml\&#34;&gt;RSS&lt;/a&gt;订阅本站。&lt;/p&gt;\n&lt;h2 id=\&#34;博主是谁\&#34;&gt;👨‍💻 博主是谁&lt;/h2&gt;\n&lt;p&gt;博主是一名后台研发攻城狮，关注云计算相关领域，目前专注于CDN技术和直播技术。&lt;/p&gt;\n&lt;h2 id=\&#34;联系我呀\&#34;&gt;📬 联系我呀&lt;/h2&gt;\n&lt;ul&gt;\n&lt;li&gt;邮件: xly880713@gmail.com&lt;/li&gt;\n&lt;/ul&gt;\n&#34;,&#34;fileName&#34;:&#34;about&#34;,&#34;abstract&#34;:&#34;&#34;,&#34;title&#34;:&#34;关于&#34;,&#34;tags&#34;:[],&#34;date&#34;:&#34;2019-01-25 19:09:48&#34;,&#34;dateFormat&#34;:&#34;2019-01-25&#34;,&#34;feature&#34;:&#34;&#34;,&#34;link&#34;:&#34;https://xly0713.github.io/post/about/&#34;,&#34;hideInList&#34;:true,&#34;isTop&#34;:false,&#34;stats&#34;:{&#34;text&#34;:&#34;1 min read&#34;,&#34;time&#34;:21000,&#34;words&#34;:105,&#34;minutes&#34;:1},&#34;description&#34;:&#34;\n欢迎来到我的小站呀，很高兴遇见你！🤝\n\n🏠 关于本站\n本站主要用来记录一些技术，帮助自己整理零碎的知识，希望对他人有所帮助。欢迎RSS订阅本站。\n👨‍💻 博主是谁\n博主是一名后台研发攻城狮，关注云计算相关领域，目前专注于CDN技术...&#34;,&#34;toc&#34;:&#34;&lt;ul class=\&#34;markdownIt-TOC\&#34;&gt;\n&lt;li&gt;\n&lt;ul&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%85%B3%E4%BA%8E%E6%9C%AC%E7%AB%99\&#34;&gt;🏠 关于本站&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E5%8D%9A%E4%B8%BB%E6%98%AF%E8%B0%81\&#34;&gt;👨‍💻 博主是谁&lt;/a&gt;&lt;/li&gt;\n&lt;li&gt;&lt;a href=\&#34;#%E8%81%94%E7%B3%BB%E6%88%91%E5%91%80\&#34;&gt;📬 联系我呀&lt;/a&gt;&lt;/li&gt;\n&lt;/ul&gt;\n&lt;/li&gt;\n&lt;/ul&gt;\n&#34;}]";
  // var json = escape.substr(1, escape.length - 2);
  // var datas = json.split(',');
  // for (let i=0; i < datas.length; i++) {
  //   let item = datas[i];
  //   let attrs = item.split('34;:&#34')
  //   debugger
  //   console.log(datas[i])
  // }
  let escapeMap = new Map();
  escapeMap.set('&#34;', '"');
  escapeMap.set('&gt;', '>');
  escapeMap.set('&#39;', "'");
  escapeMap.set('&lt;', '<');
  escapeMap.set('&quot;', '"');
  escapeMap.set('&amp;', '&');
</script> -->

<!-- <script src="/media/js/mouse/peace.js"></script> -->
</html>